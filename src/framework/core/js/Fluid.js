/*!
 * Fluid Infusion v6.0.0
 *
 * Infusion is distributed under the Educational Community License 2.0 and new BSD licenses:
 * http://wiki.fluidproject.org/display/fluid/Fluid+Licensing
 *
 * Copyright The Infusion copyright holders
 * See the AUTHORS.md file at the top-level directory of this distribution and at
 * https://github.com/fluid-project/infusion/raw/main/AUTHORS.md
 */
/*
Copyright The Infusion copyright holders
See the AUTHORS.md file at the top-level directory of this distribution and at
https://github.com/fluid-project/infusion/raw/main/AUTHORS.md.

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/main/Infusion-LICENSE.txt

*/

/* global preactSignalsCore */

"use strict";

// noinspection ES6ConvertVarToLetConst // otherwise this is a duplicate on minifying
var {signal, effect, computed} = preactSignalsCore;

// noinspection ES6ConvertVarToLetConst // otherwise this is a duplicate on minifying
var fluid = fluid || {}; // eslint-disable-line no-redeclare

fluid.version = "Infusion 6.0.0";

// Export this for use in environments like node.js, where it is useful for
// configuring stack trace behaviour
fluid.Error = Error;

fluid.environment = {
    fluid: fluid
};

fluid.global = fluid.global || typeof window !== "undefined" ?
    window : typeof self !== "undefined" ? self : {};

// A standard utility to schedule the invocation of a function after the current
// stack returns. On browsers this defaults to setTimeout(func, 0) but in
// other environments can be customised - e.g. to process.nextTick in node.js
// In future, this could be optimised in the browser to not dispatch into the event queue
// See https://github.com/YuzuJS/setImmediate for a more verbose but very robust replacement
fluid.invokeLater = function (func) {
    return setTimeout(func, 0);
};

// The following flag defeats all logging/tracing activities in the most performance-critical parts of the framework.
// This should really be performed by a build-time step which eliminates calls to pushActivity/popActivity and fluid.log.
fluid.defeatLogging = true;

// This flag enables the accumulating of all "activity" records generated by pushActivity into a running trace, rather
// than removing them from the stack record permanently when receiving popActivity. This trace will be consumed by
// visual debugging tools.
fluid.activityTracing = false;
fluid.activityTrace = [];

const activityParser = /(%\w+)/g;

fluid.renderActivityArgument = function (arg) {
    if (fluid.isComponent(arg)) {
        return fluid.dumpComponentAndPath(arg);
    } else {
        return arg;
    }
};

// Renders a single activity element in a form suitable to be sent to a modern browser's console
// unsupported, non-API function
fluid.renderOneActivity = function (activity, nowhile) {
    const togo = nowhile === true ? [] : ["    while "];
    const message = activity.message;
    let index = activityParser.lastIndex = 0;
    while (true) {
        const match = activityParser.exec(message);
        if (match) {
            const key = match[1].substring(1);
            togo.push(message.substring(index, match.index));
            togo.push(fluid.renderActivityArgument(activity.args[key]));
            index = activityParser.lastIndex;
        }
        else {
            break;
        }
    }
    if (index < message.length) {
        togo.push(message.substring(index));
    }
    return togo;
};

// Renders an activity stack in a form suitable to be sent to a modern browser's console
// unsupported, non-API function
fluid.renderActivity = function (activityStack, renderer) {
    renderer = renderer || fluid.renderOneActivity;
    return activityStack.map(renderer);
};

// TODO: This really needs to be threaded through the signal graph rather than stored on the call stack
fluid.activityStack = [];

// Return an array of objects describing the current activity
// unsupported, non-API function
fluid.getActivityStack = function () {
    return fluid.activityStack;
};

// Renders either the current activity or the supplied activity to the console
fluid.logActivity = function (activity) {
    activity = activity || fluid.getActivityStack();
    const rendered = fluid.renderActivity(activity).reverse();
    if (rendered.length > 0) {
        fluid.log("Current activity: ");
        fluid.each(rendered, function (args) {
            fluid.log.apply(null, args);
        });
    }
};

// Execute the supplied function with the specified activity description pushed onto the stack
// unsupported, non-API function
fluid.pushActivity = function (type, message, args) {
    const record = {type: type, message: message, args: args, time: new Date().getTime()};
    if (fluid.activityTracing) {
        fluid.activityTrace.push(record);
    }
    if (fluid.passLogLevel(fluid.logLevel.TRACE)) {
        fluid.log.apply(null, fluid.renderOneActivity(record, true));
    }
    const activityStack = fluid.getActivityStack();
    activityStack.push(record);
};

// Undo the effect of the most recent pushActivity, or multiple frames if an argument is supplied
fluid.popActivity = function (popframes) {
    popframes = popframes || 1;
    if (fluid.activityTracing) {
        fluid.activityTrace.push({pop: popframes});
    }
    const activityStack = fluid.getActivityStack();
    const popped = activityStack.length - popframes;
    activityStack.length = popped < 0 ? 0 : popped;
};

// "this-ist" style Error so that we can distinguish framework errors whilst still retaining access to platform Error features
// Solution taken from http://stackoverflow.com/questions/8802845/inheriting-from-the-error-object-where-is-the-message-property#answer-17936621
fluid.FluidError = function (/*message*/) {
    const togo = Error.apply(this, arguments);
    this.message = togo.message;
    this.stack = togo.stack;
    return this;
};

fluid.FluidError.prototype = Object.create(Error.prototype);

// The framework's built-in "log" failure handler - this logs the supplied message as well as any framework activity in progress via fluid.log
fluid.logFailure = function (args, activity) {
    fluid.log.apply(null, [fluid.logLevel.FAIL, "ASSERTION FAILED: "].concat(args));
    fluid.logActivity(activity);
};

fluid.renderLoggingArg = function (arg) {
    return arg === undefined ? "undefined" : fluid.isPrimitive(arg) || !fluid.isPlainObject(arg) ? arg : JSON.stringify(arg);
};

// The framework's built-in "fail" failure handler - this throws an exception of type <code>fluid.FluidError</code>
fluid.builtinFail = function (args /*, activity*/) {
    const message = args.map(fluid.renderLoggingArg).join(" ");
    throw new fluid.FluidError("Assertion failure - check console for more details: " + message);
};

/**
 * Signals an error to the framework. The default behaviour is to log a structured error message and throw an exception. This strategy may be configured
 * by adding and removing suitably namespaced listeners to the special event <code>fluid.failureEvent</code>
 *
 * @param {...String} messages - The error messages to log.
 *
 * All arguments after the first are passed on to (and should be suitable to pass on to) the native console.log
 * function.
 */
fluid.fail = function (...messages) {
    const activity = fluid.makeArray(fluid.getActivityStack()); // Take copy since we will destructively modify
    fluid.popActivity(activity.length); // clear any current activity - TODO: the framework currently has no exception handlers, although it will in time
    if (fluid.failureEvent) { // notify any framework failure prior to successfully setting up the failure event below
        fluid.failureEvent.fire(messages, activity);
    } else {
        fluid.logFailure(messages, activity);
        fluid.builtinFail(messages, activity);
    }
};

// TODO: rescued from kettleCouchDB.js - clean up in time
fluid.expect = function (name, target, members) {
    fluid.transform(fluid.makeArray(members), function (key) {
        if (target[key] === undefined) {
            fluid.fail(name + " missing required member " + key);
        }
    });
};

// Logging

/** Returns whether logging is enabled - legacy method
 * @return {Boolean} `true` if the current logging level exceeds `fluid.logLevel.IMPORTANT`
 */
fluid.isLogging = function () {
    return fluid.logLevelStack[0].priority > fluid.logLevel.IMPORTANT.priority;
};

/** Determines whether the supplied argument is a valid logLevel marker
 * @param {any} arg - The value to be tested
 * @return {Boolean} `true` if the supplied argument is a logLevel marker
 */
fluid.isLogLevel = function (arg) {
    return fluid.isMarker(arg) && arg.priority !== undefined;
};

/** Check whether the current framework logging level would cause a message logged with the specified level to be
 * logged. Clients who issue particularly expensive log payload arguments are recommended to guard their logging
 * statements with this function
 * @param {LogLevel} testLogLevel - The logLevel value which the current logging level will be tested against.
 * Accepts one of the members of the <code>fluid.logLevel</code> structure.
 * @return {Boolean} Returns <code>true</code> if a message supplied at that log priority would be accepted at the current logging level.
 */

fluid.passLogLevel = function (testLogLevel) {
    return testLogLevel.priority <= fluid.logLevelStack[0].priority;
};

/** Method to allow user to control the current framework logging level. The supplied level will be pushed onto a stack
 * of logging levels which may be popped via `fluid.popLogging`.
 * @param {Boolean|LogLevel} enabled - Either a boolean, for which <code>true</code>
 * represents <code>fluid.logLevel.INFO</code> and <code>false</code> represents <code>fluid.logLevel.IMPORTANT</code> (the default),
 * or else any other member of the structure <code>fluid.logLevel</code>
 * Messages whose priority is strictly less than the current logging level will not be shown by `fluid.log`
 */
fluid.setLogging = function (enabled) {
    let logLevel;
    if (typeof enabled === "boolean") {
        logLevel = fluid.logLevel[enabled ? "INFO" : "IMPORTANT"];
    } else if (fluid.isLogLevel(enabled)) {
        logLevel = enabled;
    } else {
        fluid.fail("Unrecognised fluid logging level ", enabled);
    }
    fluid.logLevelStack.unshift(logLevel);
    fluid.defeatLogging = !fluid.isLogging();
};

fluid.setLogLevel = fluid.setLogging;

/** Undo the effect of the most recent "setLogging", returning the logging system to its previous state
 * @return {LogLevel} The logLevel that was just popped
 */
fluid.popLogging = function () {
    const togo = fluid.logLevelStack.length === 1 ? fluid.logLevelStack[0] : fluid.logLevelStack.shift();
    fluid.defeatLogging = !fluid.isLogging();
    return togo;
};

/** Actually do the work of logging <code>args</code> to the environment's console. If the standard "console"
 * stream is available, the message will be sent there.
 * @param {Array} args - The complete array of arguments to be logged
 */
fluid.doBrowserLog = function (args) {
    /* eslint-disable no-console */
    if (typeof(console) !== "undefined") {
        if (console.debug) {
            console.debug.apply(console, args);
        } else if (typeof(console.log) === "function") {
            console.log.apply(console, args);
        }
        /* eslint-enable no-console */
    }
    /* eslint-enable no-console */
};

/* Log a message to a suitable environmental console. If the first argument to fluid.log is
 * one of the members of the <code>fluid.logLevel</code> structure, this will be taken as the priority
 * of the logged message - else if will default to <code>fluid.logLevel.INFO</code>. If the logged message
 * priority does not exceed that set by the most recent call to the <code>fluid.setLogging</code> function,
 * the message will not appear.
 */
fluid.log = function (/* message /*, ... */) {
    const directArgs = fluid.makeArray(arguments);
    let userLogLevel = fluid.logLevel.INFO;
    if (fluid.isLogLevel(directArgs[0])) {
        userLogLevel = directArgs.shift();
    }
    if (fluid.passLogLevel(userLogLevel)) {
        fluid.loggingEvent.fire(directArgs);
    }
};

// Functional programming utilities.

// Type checking functions

/**
 * Check whether the argument is a primitive type
 *
 * @param {any} value - The value to be tested
 * @return {Boolean} `true` if the supplied value is a JavaScript (ES5) primitive
 */
fluid.isPrimitive = function (value) {
    const valueType = typeof(value);
    return !value || valueType === "string" || valueType === "boolean" || valueType === "number" || valueType === "function";
};

/** Determines whether the supplied object can be treated as an array (primarily, by iterating over numeric keys bounded from 0 to length).
 * The strategy used is an optimised approach taken from an earlier version of jQuery - detecting whether the toString() version
 * of the object agrees with the textual form [object Array], or else whether the object is a
 * jQuery object (the most common source of "fake arrays").
 *
 * @param {any} totest - The value to be tested
 * @return {Boolean} `true` if the supplied value is an array
 */
// Note: The primary place jQuery->Array conversion is used in the framework is in dynamic components with a jQuery source.
fluid.isArrayable = function (totest) {
    return Boolean(totest) && (Object.prototype.toString.call(totest) === "[object Array]");
};

/**
 * Determines whether the supplied object is a plain JSON-forming container - that is, it is either a plain Object
 * or a plain Array. Note that this differs from jQuery's isPlainObject which does not pass Arrays.
 *
 * @param {any} totest - The object to be tested
 * @param {Boolean} [strict] - (optional) If `true`, plain Arrays will fail the test rather than passing.
 * @return {Boolean} - `true` if `totest` is a plain object, `false` otherwise.
 */
fluid.isPlainObject = function (totest, strict) {
    const string = Object.prototype.toString.call(totest);
    if (string === "[object Array]") {
        return !strict;
    } else if (string !== "[object Object]") {
        return false;
    } // FLUID-5226: This inventive strategy taken from jQuery detects whether the object's prototype is directly Object.prototype by virtue of having an "isPrototypeOf" direct member
    return !totest.constructor || !totest.constructor.prototype || Object.prototype.hasOwnProperty.call(totest.constructor.prototype, "isPrototypeOf");
};

/**
 * Returns a string typeCode representing the type of the supplied value at a coarse level.
 * Returns <code>primitive</code>, <code>array</code> or <code>object</code> depending on whether the supplied object has
 * one of those types, by use of the <code>fluid.isPrimitive</code>, <code>fluid.isPlainObject</code> and <code>fluid.isArrayable</code> utilities
 *
 * @param {any} totest - The value to be tested
 * @return {String} Either `primitive`, `array` or `object` depending on the type of the supplied value
 */
fluid.typeCode = function (totest) {
    return fluid.isPrimitive(totest) || !fluid.isPlainObject(totest) ? "primitive" :
        fluid.isArrayable(totest) ? "array" : "object";
};

/** Determine whether the supplied value is an IL reference. The test is passed if the value is a string whose
 * first character is "{" and has closing "}" character somewhere in the string
 * @param {any} ref - The value to be tested
 * @return {Boolean} `true` if the supplied value is an IL reference
 */
fluid.isILReference = function (ref) {
    return typeof(ref) === "string" && ref.charAt(0) === "{";
};

/** Determine whether the supplied value is a reference or an expander. The test is passed if either fluid.isIoCReference passes
 * or the value has an "expander" member
 * @param {any} ref - The value to be tested
 * @return {Boolean} `true` if the supplied value is a reference or expander
 */
fluid.isReferenceOrExpander = function (ref) {
    return ref && (fluid.isILReference(ref) || ref.expander);
};

fluid.isDOMNode = function (obj) {
    // This could be more sound, but messy:
    // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
    // The real problem is browsers like IE6, 7 and 8 which still do not feature a "constructor" property on DOM nodes
    return obj && typeof(obj.nodeType) === "number";
};

fluid.isComponent = function (obj) {
    return obj && obj.constructor === fluid.componentConstructor;
};

fluid.isUncopyable = function (totest) {
    return fluid.isPrimitive(totest) || !fluid.isPlainObject(totest);
};

/** A function which raises a failure if executed */
fluid.notImplemented = function () {
    fluid.fail("This operation is not implemented");
};

/* Return an empty container as the same type as the argument (either an array or hash). */
fluid.freshContainer = function (tocopy) {
    return fluid.isArrayable(tocopy) ? [] : {};
};

/**
 * Determine whether the supplied object path exceeds the maximum strategy recursion depth of fluid.strategyRecursionBailout -
 * if it does, fluid.fail will be issued with a diagnostic
 *
 * @param {String} funcName - The name of the function to appear in the diagnostic if issued
 * @param {String[]} segs - The segments of the path that the strategy has reached
 */
fluid.testStrategyRecursion = function (funcName, segs) {
    if (segs.length > fluid.strategyRecursionBailout) {
        fluid.fail("Runaway recursion encountered in " + funcName + " - reached path depth of " + fluid.strategyRecursionBailout + " via path of " + segs.join(".") +
            "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout");
    }
};

fluid.copyRecurse = function (tocopy, segs) {
    fluid.testStrategyRecursion("fluid.copy", segs);
    if (fluid.isUncopyable(tocopy)) {
        return tocopy;
    } else {
        return fluid.transform(tocopy, function (value, key) {
            segs.push(key);
            const togo = fluid.copyRecurse(value, segs);
            segs.pop();
            return togo;
        });
    }
};

/* Performs a deep copy (clone) of its argument. This will guard against cloning a circular object by terminating if it reaches a path depth
 * greater than <code>fluid.strategyRecursionBailout</code>
 */

fluid.copy = function (tocopy) {
    return fluid.copyRecurse(tocopy, []);
};


/* Corrected version of jQuery makeArray that returns an empty array on undefined rather than crashing.
 * We don't deal with as many pathological cases as jQuery */
fluid.makeArray = function (arg) {
    const togo = [];
    if (arg !== null && arg !== undefined) {
        if (fluid.isPrimitive(arg) || fluid.isPlainObject(arg, true) || typeof(arg.length) !== "number") {
            togo.push(arg);
        }
        else {
            for (let i = 0; i < arg.length; ++i) {
                togo[i] = arg[i];
            }
        }
    }
    return togo;
};

/**
 * Pushes an element or elements onto an array, initialising the array as a member of a holding object if it is
 * not already allocated.
 * @param {Array|Object} holder - The holding object whose member is to receive the pushed element(s).
 * @param {String} member - The member of the <code>holder</code> onto which the element(s) are to be pushed
 * @param {Array|Any} topush - If an array, these elements will be added to the end of the array using Array.push.apply.
 * If a non-array, it will be pushed to the end of the array using Array.push.
 */
fluid.pushArray = function (holder, member, topush) {
    const array = holder[member] ? holder[member] : (holder[member] = []);
    if (Array.isArray(topush)) {
        array.push.apply(array, topush);
    } else {
        array.push(topush);
    }
};

fluid.transform = function (source, func) {
    if (source) {
        const togo = {};
        for (const key in source) {
            togo[key] = func(source[key], key);
        }
        return togo;
    } else {
        return source;
    }
};

fluid.each = function (source, func) {
    if (source) {
        for (const key in source) {
            func(source[key], key);
        }
    }
};

/**
 * Return the last element of an array. If the array is of length 0, returns `undefined`.
 * @param {Arrayable} array - The array to be peeked into
 * @return {any} start - The last element of the array
 */
fluid.peek = function (array) {
    return array.length === 0 ? undefined : array[array.length - 1];
};

/** Scan through an array or hash of objects, removing those which match a predicate. Similar to
 * jQuery.grep, only acts on the list in-place by removal, rather than by creating
 * a new list by inclusion.
 * @param {Array|Object} source - The array or hash of objects to be scanned over. Note that in the case this is an array,
 * the iteration will proceed from the end of the array towards the front.
 * @param {Function} fn - A predicate function determining whether an element should be
 * removed. This accepts the standard signature (object, index) and returns a "truthy"
 * result in order to determine that the supplied object should be removed from the structure.
 * @param {Array|Object} [target] - (optional) A target object of the same type as <code>source</code>, which will
 * receive any objects removed from it.
 * @return {Array|Object} - <code>target</code>, containing the removed elements, if it was supplied, or else <code>source</code>
 * modified by the operation of removing the matched elements.
 */
fluid.remove_if = function (source, fn, target) {
    if (fluid.isArrayable(source)) {
        for (let i = source.length - 1; i >= 0; --i) {
            if (fn(source[i], i)) {
                if (target) {
                    target.unshift(source[i]);
                }
                source.splice(i, 1);
            }
        }
    } else {
        for (const key in source) {
            if (fn(source[key], key)) {
                if (target) {
                    target[key] = source[key];
                }
                delete source[key];
            }
        }
    }
    return target || source;
};

/** Returns an array of size count, filled with increasing integers, starting at 0 or at the index specified by first.
 * @param {Number} count - Size of the filled array to be returned
 * @param {Number} [first] - (optional, defaults to 0) First element to appear in the array
 */

fluid.iota = function (count, first) {
    first = first || 0;
    const togo = [];
    for (let i = 0; i < count; ++i) {
        togo[togo.length] = first++;
    }
    return togo;
};

/** Extracts a particular member from each top-level member of a container, returning a new container of the same type
 * @param {Array|Object} holder - The container to be filtered
 * @param {String|String[]} name - An EL path to be fetched from each top-level member
 * @return {Array|Object} - The desired structure of fetched members
 */
fluid.getMembers = function (holder, name) {
    return fluid.transform(holder, function (member) {
        return fluid.get(member, name);
    });
};

/** Accepts an object to be filtered, and an array of keys. Either all keys not present in
 * the array are removed, or only keys present in the array are returned.
 * @param {Object} toFilter - The object to be filtered - this will be NOT modified by the operation (current implementation
 * passes through $.extend shallow algorithm)
 * @param {String[]} keys - The array of keys to operate with
 * @param {Boolean} exclude - If <code>true</code>, the keys listed are removed rather than included
 * @return {Object} the filtered object (the same object that was supplied as <code>toFilter</code>
 */
fluid.filterKeys = function (toFilter, keys, exclude) {
    return fluid.remove_if($.extend({}, toFilter), function (value, key) {
        return exclude ^ (keys.indexOf(key) === -1);
    });
};

/* A convenience wrapper for <code>fluid.filterKeys</code> with the parameter <code>exclude</code> set to <code>true</code>
 *  Returns the supplied object with listed keys removed */
fluid.censorKeys = function (toCensor, keys) {
    return fluid.filterKeys(toCensor, keys, true);
};

/**
 * Returns the converted integer if the input string can be converted to an integer. Otherwise, return NaN.
 *
 * @param {String|Number} string - A string to be returned in integer form.
 * @return {Number|NaN} - The numeric value if the string can be converted, otherwise, returns NaN.
 */
fluid.parseInteger = function (string) {
    return isFinite(string) && ((string % 1) === 0) ? Number(string) : NaN;
};

/**
 * Calls Object.freeze at each level of containment of the supplied object.
 *
 * @param {any} tofreeze - The material to freeze.
 * @param {String[]} [segs] - Implementation-internal - path segments that recursion has reached.
 * @return {any} - The supplied argument, recursively frozen.
 */
fluid.freezeRecursive = function (tofreeze, segs) {
    segs = segs || [];
    fluid.testStrategyRecursion("fluid.freezeRecursive", segs);
    if (fluid.isPlainObject(tofreeze)) {
        fluid.each(tofreeze, function (value, key) {
            segs.push(key);
            fluid.freezeRecursive(value, segs);
            segs.pop();
        });
        return Object.freeze(tofreeze);
    } else {
        return tofreeze;
    }
};

/*
 * A set of special "marker values" used in signalling in function arguments and return values,
 * to partially compensate for JavaScript's lack of distinguished types. These should never appear
 * in JSON structures or other kinds of static configuration. An API specifically documents if it
 * accepts or returns any of these values, and if so, what its semantic is  - most are of private
 * use internal to the framework
 */
fluid.marker = function () {};

fluid.makeMarker = function (value, extra, mutable) {
    const togo = Object.create(fluid.marker.prototype);
    Object.assign(togo, {...extra || {}, ...{value}});
    return mutable ? togo : Object.freeze(togo);
};

fluid.makeUnavailable = (waitset = []) => fluid.makeMarker("UNAVAILABLE", {waitset}, true);

fluid.isUnavailable = totest => fluid.isMarker(totest, "UNAVAILABLE");

/* A special "marker object" representing that no value is present (where
 * signalling using the value "undefined" is not possible - e.g. the return value from a "strategy"). This
 * is intended for "ephemeral use", i.e. returned directly from strategies and transforms and should not be
 * stored in data structures */
// TODO: No longer currently consumed by fluid.transform but maybe we want it back
fluid.NO_VALUE = fluid.makeMarker("NO_VALUE");

/* Determine whether an object is any marker, or a particular marker - omit the 2nd argument to detect any marker
 */
fluid.isMarker = function (totest, type) {
    if (!(totest instanceof fluid.marker)) {
        return false;
    }
    if (!type) {
        return true;
    }
    return totest.value === type.value;
};

fluid.logLevelsSpec = {
    "FATAL":      0,
    "FAIL":       5,
    "WARN":      10,
    "IMPORTANT": 12, // The default logging "off" level - corresponds to the old "false"
    "INFO":      15, // The default logging "on" level - corresponds to the old "true"
    "TRACE":     20
};

/* A structure holding all supported log levels as supplied as a possible first argument to fluid.log
 * Members with a higher value of the "priority" field represent lower priority logging levels */
fluid.logLevel = fluid.transform(fluid.logLevelsSpec, (key, value) => fluid.makeMarker(key, {priority: value}));

fluid.logLevelStack = [fluid.logLevel.IMPORTANT]; // The stack of active logging levels, with the current level at index 0

/** Parse an EL expression separated by periods (.) into its component segments.
 * @param {String} path - The path expression to be split
 * @return {String[]} Path parsed into segments.
 * TODO: This needs to be upgraded to handle (the same) escaping rules (as RSF), so that
 * path segments containing periods and backslashes etc. can be processed, and be harmonised
 * with the more complex implementations in fluid.pathUtil(data binding).
 */
fluid.parsePath = function (path) {
    return path === "" ? [] : String(path).split(".");
};

fluid.pathToSegs = function (path) {
    return fluid.isPrimitive(path) ? fluid.parsePath(path) : path;
};

fluid.get = function (root, path, i) {
    const segs = fluid.pathToSegs(path);
    const limit = (i === undefined ? segs.length : i + 1);
    for (let j = 0; j < limit; ++j) {
        root = root ? root[segs[j]] : undefined;
    }
    return root;
};

fluid.derefSignal = function (signal, path) {
    return computed( () => {
        const value = signal.value;
        return fluid.get(value, path);
    });
};

fluid.set = function (root, path, newValue) {
    const segs = fluid.pathToSegs(path);
    for (let i = 0; i < segs.length - 1; ++i) {
        if (!root[segs[i]]) {
            root[segs[i]] = {};
        }
        root = root[segs[i]];
    }
    root[segs[segs.length - 1]] = newValue;
};


/** Returns any value held at a particular global path. This may be an object or a function, depending on what has been stored there.
 * @param {String|String[]} path - The global path from which the value is to be fetched
 * @param {Object} [env] - [optional] An environmental overlay object which will be consulted before any lookups in the global namespace.
 * @return {any} The value that was stored at the path, or undefined if there is none.
 */

fluid.getGlobalValue = function (path) {
    if (path) {
        const segs = fluid.pathToSegs(path);
        return fluid.get(fluid.global, segs);
    }
};

/* eslint-disable jsdoc/require-returns-check */
/**
 * Allows for the calling of a function from an EL expression "functionPath", with the arguments "args"
 * @param {Object} functionPath - An EL expression
 * @param {Object} args - An array of arguments to be applied to the function, specified in functionPath
 * @return {any} - The return value from the invoked function.
 */
/* eslint-enable jsdoc/require-returns-check */
fluid.invokeGlobalFunction = function (functionPath, args) {
    const func = fluid.getGlobalValue(functionPath);
    if (!func) {
        fluid.fail("Error invoking global function: " + functionPath + " could not be located");
    } else {
        const argsArray = fluid.isArrayable(args) ? args : fluid.makeArray(args);
        return func.apply(null, argsArray);
    }
};

/* Registers a new global function at a given path */

fluid.registerGlobalFunction = function (functionPath, func) {
    fluid.set(fluid.global, functionPath, func);
};

fluid.setGlobalValue = fluid.registerGlobalFunction;


/** Ensures that the supplied path has an object allocated in the global Infusion namespace, and retrieves the current value.
 * If no value is stored, a fresh {} will be assigned at the path, and to all currently empty paths leading to the global namespace root.
 * In a browser environment, the global Infusion namespace is rooted in the global `window`.
 * @param {String|String[]} path - The global path at which the namespace is to be allocated.
 * @return {any} Any current value held at the supplied path - or a freshly allocated {} to be held at that path if it was previously empty
 */
fluid.registerNamespace = function (path) {
    let existing = fluid.getGlobalValue(path);
    if (!existing) {
        existing = {};
        fluid.setGlobalValue(path, existing);
    }
    return existing;
};

// stubs for two functions in FluidDebugging.js
fluid.dumpEl = x => x;
fluid.renderTimestamp = x => x;

/*** The Fluid instance id ***/

// unsupported, NON-API function
fluid.generateUniquePrefix = function () {
    return (Math.floor(Math.random() * 1e12)).toString(36) + "-";
};

const fluid_prefix = fluid.generateUniquePrefix();

fluid.fluidInstance = fluid_prefix;

let fluid_guid = 1;

/** Allocate a string value that will be unique within this Infusion instance (frame or process), and
 * globally unique with high probability (50% chance of collision after a million trials)
 * @return {String} A fresh unique id
 */

fluid.allocateGuid = function () {
    return fluid_prefix + (fluid_guid++);
};

/*** The Fluid Event system. ***/

fluid.registerNamespace("fluid.event");

// Fluid priority system for encoding relative positions of, e.g. listeners, transforms, options, in lists

fluid.extremePriority = 4e9; // around 2^32 - allows headroom of 21 fractional bits for sub-priorities
fluid.priorityTypes = {
    first: -1,
    last: 1,
    before: 0,
    after: 0
};
// TODO: This should be properly done with defaults blocks and a much more performant fluid.indexDefaults
fluid.extremalPriorities = {
    // a built-in definition to allow test infrastructure "last" listeners to sort after all impl listeners, and authoring/debugging listeners to sort after those
    // these are "priority intensities", and will be flipped for "first" listeners
    none: 0,
    transaction: 10,
    testing: 20,
    authoring: 30
};

// unsupported, NON-API function
// TODO: Note - no "fixedOnly = true" sites remain in the framework
fluid.parsePriorityConstraint = function (constraint, fixedOnly, site) {
    const segs = constraint.split(":");
    const type = segs[0];
    const lookup = fluid.priorityTypes[type];
    if (lookup === undefined) {
        fluid.fail("Invalid constraint type in priority field " + constraint + ": the only supported values are " + fluid.keys(fluid.priorityTypes).join(", ") + " or numeric");
    }
    if (fixedOnly && lookup === 0) {
        fluid.fail("Constraint type in priority field " + constraint + " is not supported in a " + site + " record - you must use either a numeric value or first, last");
    }
    return {
        type: segs[0],
        target: segs[1]
    };
};

// unsupported, NON-API function
fluid.parsePriority = function (priority, count, fixedOnly, site) {
    priority = priority || 0;
    const togo = {
        count: count || 0,
        fixed: null,
        constraint: null,
        site: site
    };
    if (typeof(priority) === "number") {
        togo.fixed = -priority;
    } else {
        togo.constraint = fluid.parsePriorityConstraint(priority, fixedOnly, site);
    }
    const multiplier = togo.constraint ? fluid.priorityTypes[togo.constraint.type] : 0;
    if (multiplier !== 0) {
        const target = togo.constraint.target || "none";
        const extremal = fluid.extremalPriorities[target];
        if (extremal === undefined) {
            fluid.fail("Unrecognised extremal priority target " + target + ": the currently supported values are " + fluid.keys(fluid.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities");
        }
        togo.fixed = multiplier * (fluid.extremePriority + extremal);
    }
    if (togo.fixed !== null) {
        togo.fixed += togo.count / 1024; // use some fractional bits to encode count bias
    }

    return togo;
};

fluid.renderPriority = function (parsed) {
    return parsed.constraint ? (parsed.constraint.target ? parsed.constraint.type + ":" + parsed.constraint.target : parsed.constraint.type ) : Math.floor(parsed.fixed);
};

// unsupported, NON-API function
fluid.compareByPriority = function (recA, recB) {
    if (recA.priority.fixed !== null && recB.priority.fixed !== null) {
        return recA.priority.fixed - recB.priority.fixed;
    } else { // sort constraint records to the end
        // relies on JavaScript boolean coercion rules (ECMA 9.3 toNumber)
        return (recA.priority.fixed === null) - (recB.priority.fixed === null);
    }
};

fluid.honourConstraint = function (array, firstConstraint, c) {
    const constraint = array[c].priority.constraint;
    const matchIndex = array.findIndex(element => element.namespace === constraint.target);

    if (matchIndex === -1) { // TODO: We should report an error during firing if this condition persists until then
        return true;
    } else if (matchIndex >= firstConstraint) {
        return false;
    } else {
        const offset = constraint.type === "after" ? 1 : 0;
        const target = matchIndex + offset;
        const temp = array[c];
        for (let shift = c; shift >= target; --shift) {
            array[shift] = array[shift - 1];
        }
        array[target] = temp;
        return true;
    }
};

// unsupported, NON-API function
// Priorities accepted from users have higher numbers representing high priority (sort first) -
// Note weird subtlety that because things arrive dynamically constraints may not see their targets for a while.
fluid.sortByPriority = function (array) {
    array.sort(fluid.compareByPriority);

    let firstConstraint = array.findIndex(element => element.priority.constraint && fluid.priorityTypes[element.priority.constraint.type] === 0);
    if (firstConstraint === -1) {
        firstConstraint = array.length;
    }

    while (true) {
        if (firstConstraint === array.length) {
            return array;
        }
        const oldFirstConstraint = firstConstraint;
        for (let c = firstConstraint; c < array.length; ++c) {
            const applied = fluid.honourConstraint(array, firstConstraint, c);
            if (applied) {
                ++firstConstraint;
            }
        }
        if (firstConstraint === oldFirstConstraint) {
            const holders = array.slice(firstConstraint);
            fluid.fail("Could not find targets for any constraints in " + holders[0].priority.site + " ", holders,
                ": none of the targets (" + holders.map(holder => holder.priority.constraint.target).join(", ") +
                ") matched any namespaces of the elements in (", array.slice(0, firstConstraint), ") - this is caused by either an invalid or circular reference");
        }
    }
};

/**
 * Parse a hash containing prioritised records (for example, as found in a ContextAwareness record) and return a sorted array of these records in priority order.
 *
 * @param {Object} records - A hash of key names to prioritised records. Each record may contain an member `namespace` - if it does not, the namespace will be taken from the
 * record's key. It may also contain a `String` member `priority` encoding a priority with respect to these namespaces as document at http://docs.fluidproject.org/infusion/development/Priorities.html .
 * @param {String} name - A human-readable name describing the supplied records, which will be incorporated into the message of any error encountered when resolving the priorities
 * @return {Array} An array of the same elements supplied to `records`, sorted into priority order. The supplied argument `records` will not be modified.
 */
fluid.parsePriorityRecords = function (records, name) {
    const array = fluid.hashToArray(records, "namespace", function (newElement, oldElement) {
        $.extend(newElement, oldElement);
        newElement.priority = fluid.parsePriority(oldElement.priority, 0, false, name);
    });
    fluid.sortByPriority(array);
    return array;
};

fluid.event.identifyListener = function (listener, soft) {
    if (typeof(listener) !== "string" && !listener.$$fluid_guid && !soft) {
        listener.$$fluid_guid = fluid.allocateGuid();
    }
    return listener.$$fluid_guid;
};

// unsupported, NON-API function
fluid.event.impersonateListener = function (origListener, newListener) {
    fluid.event.identifyListener(origListener);
    newListener.$$fluid_guid = origListener.$$fluid_guid;
};


// unsupported, NON-API function
fluid.event.sortListeners = function (listeners) {
    let togo = [];
    Object.values(listeners).forEach(oneNamespace => {
        let headHard; // notify only the first listener with hard namespace - or else all if all are soft
        for (let i = 0; i < oneNamespace.length; ++i) {
            const thisListener = oneNamespace[i];
            if (!thisListener.softNamespace && !headHard) {
                headHard = thisListener;
            }
        }
        if (headHard) {
            togo.push(headHard);
        } else {
            togo = togo.concat(oneNamespace);
        }
    });
    return fluid.sortByPriority(togo);
};

// unsupported, NON-API function
fluid.event.resolveListener = function (listener) {
    const listenerName = listener.globalName || (typeof(listener) === "string" ? listener : null);
    if (listenerName) {
        const listenerFunc = fluid.getGlobalValue(listenerName);
        if (!listenerFunc) {
            fluid.fail("Unable to look up name " + listenerName + " as a global function");
        } else {
            listener = listenerFunc;
        }
    }
    return listener;
};

/* Generate a name for a component for debugging purposes */
fluid.nameComponent = function (that) {
    return that ? fluid.dumpComponentAndPath(that) : "[unknown component]";
};

fluid.event.nameEvent = function (that, eventName) {
    return eventName + " of " + fluid.nameComponent(that);
};

// A function to tag the type of a Fluid event firer (primarily to mark it uncopyable)
fluid.event.firer = function () {};

/** Construct an "event firer" object which can be used to register and deregister
 * listeners, to which "events" can be fired. These events consist of an arbitrary
 * function signature. General documentation on the Fluid events system is at
 * http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html .
 *
 * @param {Object} options - A structure to configure this event firer. Supported fields:
 *     {String} name - a readable name for this firer to be used in diagnostics and debugging
 *     {Boolean} preventable - If <code>true</code> the return value of each handler will
 * be checked for <code>false</code> in which case further listeners will be shortcircuited, and this
 * will be the return value of fire()
 *     {Boolean} promise - If `true`, the event firer will receive a "thenable" signature allowing
 * it to function as a promise. In this case the event should be fired with only one argument, and
 * not more than once.
 * @return {Object} - The newly-created event firer.
 */
fluid.makeEventFirer = function (options) {
    options = options || {};
    const name = options.name || "<anonymous>";
    let that;

    const lazyInit = function () { // Lazy init function to economise on object references for events which are never listened to
        // The authoritative list of all listeners, a hash indexed by namespace, looking up to a stack (array) of
        // listener records in "burial order"
        that.listeners = {};
        // An index of all listeners by "id" - we should consider removing this since it is only used during removal
        // and because that.listeners is a hash of stacks we can't really accelerate removal by much
        that.byId = {};
        // The "live" list of listeners which will be notified in order on any firing. Recomputed on any use of
        // addListener/removeListener
        that.sortedListeners = [];
        // Very low-level destruction notification scheme primarily intended for FLUID-6445. Will be an array of nullary functions
        that.onDestroy = null;
        // arguments after 3rd are not part of public API
        // listener as Object is used only by ChangeApplier to tunnel path, segs, etc as part of its "spec"
        /** Adds a listener to this event.
         * @param {Function|String} listener - The listener function to be added, or a global name resolving to a function. The signature of the function is arbitrary and matches that sent to event.fire()
         * @param {String} [namespace] - (Optional) A namespace for this listener. At most one listener with a particular namespace can be active on an event at one time. Removing successively added listeners with a particular
         * namespace will expose previously added ones in a stack idiom
         * @param {String|Number} [priority] - A priority for the listener relative to others, perhaps expressed with a constraint relative to the namespace of another - see
         * http://docs.fluidproject.org/infusion/development/Priorities.html
         * @param {String} [softNamespace] - An unsupported internal option that is not part of the public API.
         * @param {String} [listenerId] - An unsupported internal option that is not part of the public API.
         */
        that.addListener = function (listener, namespace, priority, softNamespace, listenerId) {
            let record;
            if (that.destroyed) {
                fluid.fail("Cannot add listener to destroyed event firer " + that.name);
            }
            if (!listener) {
                return;
            }
            if (fluid.isPlainObject(listener, true) && !fluid.isApplicable(listener)) {
                record = listener;
                listener = record.listener;
                namespace = record.namespace;
                priority = record.priority;
                softNamespace = record.softNamespace;
                listenerId = record.listenerId;
            }
            if (typeof(listener) === "string") {
                listener = {globalName: listener};
            }
            const id = listenerId || fluid.event.identifyListener(listener);
            namespace = namespace || id;
            record = Object.assign(record || {}, {
                namespace: namespace,
                listener: listener,
                softNamespace: softNamespace,
                listenerId: listenerId,
                priority: fluid.parsePriority(priority, that.sortedListeners.length, false, "listeners")
            });
            that.byId[id] = record;

            const thisListeners = (that.listeners[namespace] = fluid.makeArray(that.listeners[namespace]));
            thisListeners[softNamespace ? "push" : "unshift"](record);

            that.sortedListeners = fluid.event.sortListeners(that.listeners);
        };
        that.addListener.apply(null, arguments);
    };
    that = Object.create(fluid.event.firer.prototype);
    Object.assign(that, {
        eventId: fluid.allocateGuid(),
        name: name,
        ownerId: options.ownerId,
        typeName: "fluid.event.firer",
        destroy: function () {
            that.destroyed = true;
            fluid.each(that.onDestroy, function (func) {
                func();
            });
        },
        addListener: function () {
            lazyInit.apply(null, arguments);
        },
        /**
         * Removes a listener previously registered with this event.
         *
         * @param {Function|String} listener - Either the listener function, the namespace of a listener
         * (in which case a previous listener with that namespace may be uncovered) or an id sent to the
         * undocumented `listenerId` argument of `addListener
         */
        // Can be supplied either listener, namespace, or id (which may match either listener function's guid or original listenerId argument)
        removeListener: function (listener) {
            if (!that.listeners) { return; }
            let namespace, id, record;
            if (typeof(listener) === "string") {
                namespace = listener;
                record = that.listeners[namespace];
                if (!record) { // it was an id and not a namespace - take the namespace from its record later
                    id = namespace;
                    namespace = null;
                }
            }
            else if (typeof(listener) === "function") {
                id = fluid.event.identifyListener(listener, true);
                if (!id) {
                    fluid.fail("Cannot remove unregistered listener function ", listener, " from event " + that.name);
                }
            }
            const rec = that.byId[id];
            const softNamespace = rec && rec.softNamespace;
            namespace = namespace || (rec && rec.namespace) || id;
            delete that.byId[id];
            record = that.listeners[namespace];
            if (record) {
                if (softNamespace) {
                    fluid.remove_if(record, function (thisLis) {
                        return thisLis.listener.$$fluid_guid === id || thisLis.listenerId === id;
                    });
                } else {
                    record.shift();
                }
                if (record.length === 0) {
                    delete that.listeners[namespace];
                }
            }
            that.sortedListeners = fluid.event.sortListeners(that.listeners);
        },
        /* Fires this event to all listeners which are active. They will be notified in order of priority. The signature of this method is free. */
        fire: function () {
            const listeners = that.sortedListeners;
            if (options.promise) {
                that.promisePayload = arguments[0];
            }
            if (!listeners || that.destroyed) { return; }
            for (let i = 0; i < listeners.length; ++i) {
                const lisrec = listeners[i];
                if (typeof(lisrec.listener) !== "function") {
                    lisrec.listener = fluid.event.resolveListener(lisrec.listener);
                }
                const listener = lisrec.listener;
                const ret = listener.apply(null, arguments);
                let value;
                if (options.preventable && ret === false || that.destroyed) {
                    value = false;
                }
                if (value !== undefined) {
                    return value;
                }
            }
        }
    });
    if (options.promise) {
        that.then = function (func) {
            if ("promisePayload" in that) {
                func(that.promisePayload);
            } else {
                that.addListener(func);
            }
        };
    }
    return that;
};

// unsupported, NON-API function
// Fires to an event which may not be instantiated (in which case no-op) - primary modern usage is to resolve FLUID-5904
fluid.fireEvent = function (component, eventName, args) {
    const firer = component.events && component.events[eventName];
    if (firer) {
        firer.fire.apply(null, fluid.makeArray(args));
    }
};

// unsupported, NON-API function
fluid.event.addListenerToFirer = function (firer, value, namespace, wrapper) {
    wrapper = wrapper || (x => x);
    if (fluid.isArrayable(value)) {
        for (let i = 0; i < value.length; ++i) {
            fluid.event.addListenerToFirer(firer, value[i], namespace, wrapper);
        }
    } else if (typeof(value) === "function" || typeof(value) === "string") {
        wrapper(firer).addListener(value, namespace);
    } else if (value && typeof(value) === "object") {
        wrapper(firer).addListener(value.listener, namespace || value.namespace, value.priority, value.softNamespace, value.listenerId);
    }
};

// unsupported, NON-API function - non-IOC passthrough
fluid.event.resolveListenerRecord = function (records) {
    return { records: records };
};

fluid.expandImmediate = function (material) {
    fluid.fail("fluid.expandImmediate could not be loaded - please include FluidIL.js in order to operate IL event with descriptor " + material);
};

// unsupported, NON-API function
fluid.mergeListeners = function (that, events, listeners) {
    fluid.each(listeners, function (value, key) {
        let firer, namespace;
        if (fluid.isILReference(key)) {
            firer = fluid.expandImmediate(key, that);
            if (!firer) {
                fluid.fail("Error in listener record: key " + key + " could not be looked up to an event firer - did you miss out \"events.\" when referring to an event firer?");
            }
        } else {
            const keydot = key.indexOf(".");

            if (keydot !== -1) {
                namespace = key.substring(keydot + 1);
                key = key.substring(0, keydot);
            }
            if (!events[key]) {
                fluid.fail("Listener registered for event " + key + " which is not defined for this component");
            }
            firer = events[key];
        }
        const record = fluid.event.resolveListenerRecord(value, that, key, namespace, true);
        fluid.event.addListenerToFirer(firer, record.records, namespace, record.adderWrapper);
    });
};

// unsupported, NON-API function
fluid.eventFromRecord = function (eventSpec, eventKey, that) {
    const isILEvent = eventSpec && (typeof(eventSpec) !== "string" || fluid.isILReference(eventSpec));
    let event;
    if (isILEvent) {
        if (!fluid.event.resolveEvent) {
            fluid.fail("fluid.event.resolveEvent could not be loaded - please include FluidIL.js in order to operate IL driven event with descriptor ",
                eventSpec);
        } else {
            event = fluid.event.resolveEvent(that, eventKey, eventSpec);
        }
    } else {
        event = fluid.makeEventFirer({
            name: fluid.event.nameEvent(that, eventKey),
            preventable: eventSpec === "preventable",
            promise: eventSpec === "promise",
            ownerId: that.id
        });
    }
    return event;
};

// unsupported, NON-API function
fluid.mergeListenerPolicy = function (target, source, key) {
    if (typeof(key) !== "string") {
        fluid.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + key + " from ", source);
    }
    // cf. triage in mergeListeners
    const hasNamespace = !fluid.isILReference(key) && key.indexOf(".") !== -1;
    return hasNamespace ? (source || target) : fluid.arrayConcatPolicy(target, source);
};

// unsupported, NON-API function
fluid.makeMergeListenersPolicy = function (merger, modelRelay) {
    return function (target, source) {
        target = target || {};
        if (modelRelay && (fluid.isArrayable(source) || "target" in source && (typeof(source.target) === "string" || source.target.segs))) { // This form allowed for modelRelay
            target[""] = merger(target[""], source, "");
        } else {
            fluid.each(source, function (listeners, key) {
                target[key] = merger(target[key], listeners, key);
            });
        }
        return target;
    };
};

fluid.validateListenersImplemented = function (that) {
    const errors = [];
    fluid.each(that.events, function (event, name) {
        fluid.each(event.sortedListeners, function (lisrec) {
            if (lisrec.listener === fluid.notImplemented || lisrec.listener.globalName === "fluid.notImplemented") {
                errors.push({name: name, namespace: lisrec.namespace, componentSource: fluid.model.getSimple(that.options.listeners, [name + "." + lisrec.namespace, 0, "componentSource"])});
            }
        });
    });
    return errors;
};

fluid.arrayConcatPolicy = function (target, source) {
    return fluid.makeArray(target).concat(fluid.makeArray(source));
};

/*** FLUID LOGGING SYSTEM ***/

// This event represents the process of resolving the action of a request to fluid.log. Each listener shares
// access to an array, shallow-copied from the original arguments list to fluid.log, which is assumed writeable
// and which they may splice, transform, etc. before it is dispatched to the listener with namespace "log" which
// actually performs the logging action
fluid.loggingEvent = fluid.makeEventFirer({name: "logging event"});

fluid.addTimestampArg = function (args) {
    const arg0 = fluid.renderTimestamp(new Date()) + ":  ";
    args.unshift(arg0);
};

fluid.loggingEvent.addListener(fluid.doBrowserLog, "log");
// Not intended to be overridden - just a positional placeholder so that the priority of
// actions filtering the log arguments before dispatching may be referred to it
fluid.loggingEvent.addListener(x => x, "filterArgs", "before:log");
fluid.loggingEvent.addListener(fluid.addTimestampArg, "addTimestampArg", "after:filterArgs");

/*** FLUID ERROR SYSTEM ***/

/** Upgrades a promise rejection payload (or Error) by suffixing an additional "while" reason into its "message" field
 * @param {Object|Error} originError - A rejection payload. This should (at least) have the member `isError: true` set, as well as a String `message` holding a rejection reason.
 * @param {String} whileMsg - A message describing the activity which led to this error
 * @return {Object} The rejected payload formed by shallow cloning the supplied argument (if it is not an `Error`) and suffixing its `message` member
 */
fluid.upgradeError = function (originError, whileMsg) {
    const error = originError instanceof Error ? originError :
        fluid.isPrimitive(originError) ? {message: originError} : fluid.extend({}, originError);
    error.message = error.message + whileMsg;
    return error;
};

fluid.failureEvent = fluid.makeEventFirer({name: "failure event"});

fluid.failureEvent.addListener(fluid.builtinFail, "fail");
fluid.failureEvent.addListener(fluid.logFailure, "log", "before:fail");

/*** DEFAULTS AND OPTIONS MERGING SYSTEM ***/

// A function to tag the types of all Fluid components
fluid.componentConstructor = function () {};

// Define the `name` property to be `"fluid.componentConstructor"` as a means to inspect if an Object is actually
// an Infusion component instance; while being agnostic of the Infusion codebase being present. For example this
// technique is used in the jquery.keyboard-a11y plugin for `fluid.thatistBridge`.
Object.defineProperty(fluid.componentConstructor, "name", {
    value: "fluid.componentConstructor"
});

fluid.domain = {};

fluid.layerStore = {};

fluid.rawLayer = function (layerName, layer) {
    let layerSig = fluid.layerStore[layerName];
    if (layerSig) {
        // TODO: immutable update - what else will we store in layer store?
        // TODO: if layer is undefined, we might want to lazily create the signal and instead return a thunk
        if (layer !== undefined) {
            layerSig.value = {raw: layer};
        }
    } else {
        // It might be a read of something never written, we still need a signal - although we would like these to be GCable somehow -
        // Turn layerStore into WeakMap?
        layerSig = fluid.layerStore[layerName] = signal({
            raw: layer
        });
    }
    return layerSig;
};

// Like a "reader macro"
fluid.readerExpandLayer = function (layer) {
    // TODO: Create links between old and new data
    return {...layer, parents: fluid.makeArray(layer.parents)};
};

// The types of merge record the system supports, with the weakest records first
fluid.mergeRecordTypes = {
    def:                1000, // and above
    defParents:         900,
    subcomponent:       700, // and above - wrt. nesting depth
    user:               600, // supplied as constructor arguments
    distribution:       100, // and above
    live:               0
};

fluid.mergeLayers = function (layers, root = {}) {
    // Big stuff coming here with deferencing of inner signal values etc.
    Object.assign.apply(null, [root].concat(layers.map(layer => layer.layer)));
    return root;
};

fluid.hierarchyResolver = function () {
    const flatDefs = {};
    const readerExpand = layer => fluid.readerExpandLayer(layer);
    const that = {
        flatDefs,
        storeParents: layer => {
            // TODO: If the raw layer def is unavailable we need to makeUnavailable return
            layer.parents.forEach(parent => that.storeLayer(parent));
        },
        storeLayer: (layerName) => {
            if (!flatDefs[layerName]) {
                const layer = fluid.rawLayer(layerName).value?.raw;
                if (layer) {
                    const readerExpanded = readerExpand(layer);
                    flatDefs[layerName] = readerExpanded;
                    that.storeParents(readerExpanded);
                }
            }
        },
        resolve: (layerName) => {
            const layer = flatDefs[layerName];
            if (layer) {
                const order = fluid.C3_precedence(layerName, flatDefs);
                const layers = order.map((layerName, i) => ({
                    layerType: "def",
                    priority: fluid.mergeRecordTypes.def + i,
                    layer: flatDefs[layerName]
                })).concat({
                    layerType: "defParents",
                    priority: fluid.mergeRecordTypes.defParents,
                    layer: {parents: order}
                });
                return {
                    layers, merged: fluid.mergeLayers(layers)
                };
            } else { // TODO: How deeply nested should this be? Does it occur within a layer or does it replace the layer structure?
                return fluid.makeUnavailable(["rawLayer", layerName]);
            }
        }
    };
    return that;
};


fluid.getMergedHierarchy = function (layerName) {
    return computed( () => {
        const resolver = fluid.hierarchyResolver();
        resolver.storeLayer(layerName);
        return resolver.resolve(layerName);
    });
};

fluid.hasParent = function (layer, parent) {
    return layer.parents && layer.parents.includes(parent);
};

/**
 * Retrieves and stores a layer's configuration centrally.
 * @param {String} layerName - The name of the grade whose options are to be read or written
 * @return {Object} - Signal for layers and merged
 */
fluid.fullDef = function (layerName) {
    return fluid.getMergedHierarchy(layerName);
};

fluid.writeDef = function (layerName, layer) {
    fluid.rawLayer(layerName, layer);
    const resolved = fluid.getMergedHierarchy(layerName);
    if (fluid.hasParent(resolved.value.merged, "fluid.component")) {
        fluid.makeComponentCreator(layerName);
    }
};

/**
 * Retrieves and stores a layer's configuration centrally.
 *
 * @param {String} layerName - The name of the grade whose options are to be read or written
 * @param {Object} [layer] - An (optional) object containing the options to be set
 * @return {Object|undefined} - If `options` is omitted, returns the defaults for `componentName`.  Otherwise,
 * creates an instance of the named component with the supplied options.
 */
fluid.def = function (layerName, layer) {
    if (layer === undefined) {
        return fluid.derefSignal(fluid.fullDef(layerName), ["merged"]);
    }
    else {
        fluid.writeDef(layerName, layer);
    }
};

fluid.validateCreator = function (componentName) {
    const resolved = fluid.getMergedHierarchy(componentName).value;
    if (fluid.isUnavailable(resolved)) {
        const blankGrades = resolved.waitset.map(oneWait => oneWait[1]);
        fluid.fail("The hierarchy of component with type " + componentName + " is incomplete - it inherits from the following layer(s): " +
            blankGrades.join(", ") + " for which the definitions are not available");
    }
};


// unsupported, NON-API function
// After some error checking, this *is* the component creator function
fluid.initFreeComponent = function (layerName, initArgs) {
    const id = fluid.allocateGuid();
    // TODO: Perhaps one day we will support a directive which allows the user to select a current component
    // root for free components other than the global root
    const instanceName = fluid.computeGlobalMemberName(layerName, id);

    // General pattern needs to become utility for subcomponent
    const instance = Object.create(fluid.componentConstructor.prototype);
    instance.id = id;
    const path = ["fluid", "domain", "instances", instanceName];
    // TODO: Actually the signal rather than the instance
    fluid.setGlobalValue(path, instance);

    const resolver = fluid.hierarchyResolver();
    // If we support other signatures we might want to do an early resolution, as we used to with "upDefaults"
    const argLayer = initArgs[0] || {};
    let instanceLayer;
    if (argLayer.parents) {
        // Create fictitious "nonce type" if user has supplied direct parents - remember we need to clean this up after the instance is gone
        fluid.rawLayer(instanceName, {...argLayer, parents: [layerName].concat(argLayer.parents)});
        instanceLayer = instanceName;
    } else {
        instanceLayer = layerName;
    }
    resolver.storeLayer(instanceLayer);
    const resolved = resolver.resolve(instanceLayer);
    const userLayer = {
        layerType: "user",
        layer: {
            ...argLayer
        }
    };

    // layers themselves need to be stored somewhere - recall the return should be a signal not a component
    // the merged result is actual a signal with respect to the supplied layers - fresh layers can arise or old ones can be removed
    // OK - so how will we REMOVE properties in the case we need to unmerge? This is what implies that the entire top level
    // of properties needs to be signalised? Or does the "instance" become a factory and we just construct a completely fresh
    // component instance if there is a change in top-level properties?
    // If we signalise the whole top layer then at least we don't need to ever discard the root reference.
    // And also - if anyone wants a "flattened" component, this naturally can't agree with the old root reference.
    // Does this commit us to "public zebras"?
    const layers = resolved.layers.concat([userLayer]);

    fluid.mergeLayers(layers, instance);

    return instance;
};

fluid.makeComponentCreator = function (componentName) {
    const creator = function () {
        fluid.validateCreator(componentName);
        return fluid.initFreeComponent(componentName, arguments);
    };
    const existing = fluid.getGlobalValue(componentName);
    if (existing) {
        Object.assign(creator, existing);
    }
    fluid.setGlobalValue(componentName, creator);
};

// Algorithm taken from Python 2.3's implementation from manual: https://www.python.org/download/releases/2.3/mro/#the-end
// Deals with FLUID-5800
/**
 * Merges multiple sequences of layer names into a single sequence using the C3 linearization method.
 * @param {String[][]} seqs - An array of sequences to be merged. **NOTE** The nested sequences will be modified by
 * this function.
 * @return {String[]} - The merged sequence.
 * @throws {Error} - Throws an error if the hierarchy is inconsistent.
 */
fluid.C3_merge = function (seqs) {
    fluid.log(`\n\nCPL[${seqs[0][0]}]=${JSON.stringify(seqs)}`);
    let res = [];
    let i = 0;

    while (true) {
        let nonemptyseqs = seqs.filter(seq => seq.length > 0);
        if (nonemptyseqs.length === 0) {
            return res;
        }

        i++;
        fluid.log(`\n${i} round: candidates...`);

        let cand = null;
        for (let seq of nonemptyseqs) {
            cand = seq[0];
            fluid.log(` ${cand}`);
            let nothead = nonemptyseqs.filter(s => s.indexOf(cand) > 0);
            if (nothead.length > 0) {
                cand = null; // reject candidate
            } else {
                break;
            }
        }

        if (!cand) {
            fluid.fail(`Inconsistent hierarchy for layer ${res[0]}: conflict between parent orders ${nonemptyseqs.map(ns => ns.toString()).join(", ")}`);
        }

        res.push(cand);
        for (let seq of nonemptyseqs) {
            if (seq[0] === cand) {
                seq.shift(); // remove cand
            }
        }
    }
};

/**
 * Computes C3 precedence of the parent layers of the supplied layer
 * @param {String} C - The name of the layer whose parent precedence is required
 * @param {Object<String, Object>} defs - A layer definition registry
 * @param {Set<String>} [visited=new Set()] - A set to keep track of visited classes to detect circular hierarchy.
 * @return {String[]} - The parent precedence list
 * @throws {Error} - Throws an error if the hierarchy is inconsistent, circular, or a layer is missing
 */
fluid.C3_precedence = function (C, defs, visited = new Set()) {
    if (visited.has(C)) {
        fluid.fail(`Circular hierarchy detected - layer ${C} has already been visited`);
    }

    visited.add(C);
    const def = defs[C];
    if (!def) {
        // TODO: Better diagnostic about where it is referenced
        fluid.fail(`Parent layer ${C} referenced which is not defined`);
    }
    const parents = Array.from(defs[C].parents);
    const precLists = parents.map(parent => fluid.C3_precedence(parent, defs, visited));
    const merged = fluid.C3_merge([[C]].concat(precLists).concat([parents]));

    visited.delete(C);
    return merged;
};




// A special marker object which will be placed at a current evaluation point in the tree in order
// to protect against circular evaluation
fluid.inEvaluationMarker = Object.freeze({"__CURRENTLY_IN_EVALUATION__": true});

// The Fluid Component System proper

// The base system grade definitions

fluid.def("fluid.function", {});

/**
 * Invoke a global function by name and named arguments. A courtesy to allow declaratively encoded function calls
 * to use named arguments rather than bare arrays.
 *
 * @param {String} name - A global name which can be resolved to a Function. The defaults for this name must
 * resolve onto a grade including "fluid.function". The defaults record should also contain an entry
 * <code>argumentMap</code>, a hash of argument names onto indexes.
 * @param {Object} [spec] - A named hash holding the argument values to be sent to the function. These will be looked
 * up in the <code>argumentMap</code> and resolved into a flat list of arguments.
 * @return {any} The return value from the function
 */
fluid.invokeGradedFunction = function (name, spec) {
    const defaults = fluid.def(name).value;
    if (!defaults || !defaults.argumentMap || !fluid.hasGrade(defaults, "fluid.function")) {
        fluid.fail("Cannot look up name " + name +
            " to a function with registered argumentMap - got defaults ", defaults);
    }
    const args = [];
    fluid.each(defaults.argumentMap, function (value, key) {
        args[value] = spec[key];
    });
    return fluid.invokeGlobalFunction(name, args);
};

fluid.def("fluid.component", {
    events: { // Three standard lifecycle points common to all components
        onCreate:     0,
        onDestroy:    0,
        afterDestroy: 0
    }
});

/* Compute a "nickname" given a fully qualified typename, by returning the last path
 * segment.
 */
fluid.computeNickName = function (typeName) {
    const segs = fluid.parsePath(typeName);
    return fluid.peek(segs);
};

/** Returns <code>true</code> if the supplied reference holds a component which has been destroyed or for which destruction has started
 * @param {Component} that - A reference to a component
 * @param {Boolean} [strict] - If `true`, the test will only check whether the component has been fully destroyed
 * @return {Boolean} `true` if the reference is to a component which has been destroyed
 **/
fluid.isDestroyed = function (that, strict) {
    return that.lifecycleStatus === "destroyed" || (!strict && that.lifecycleStatus === "destroying");
};

// Computes a name for a component appearing at the global root which is globally unique, from its nickName and id
fluid.computeGlobalMemberName = function (type, id) {
    const nickName = fluid.computeNickName(type);
    return nickName + "-" + id;
};

// ******* SELECTOR ENGINE *********

// selector regexps copied from jQuery - recent versions correct the range to start C0
// The initial portion of the main character selector: "just add water" to add on extra
// accepted characters, as well as the "\\\\." -> "\." portion necessary for matching
// period characters escaped in selectors
const charStart = "(?:[\\w\\u00c0-\\uFFFF*_-";

fluid.simpleCSSMatcher = {
    regexp: new RegExp("([#.]?)(" + charStart + "]|\\\\.)+)", "g"),
    charToTag: {
        "": "tag",
        "#": "id",
        ".": "clazz"
    }
};

fluid.ILSSMatcher = {
    regexp: new RegExp("([&#]?)(" + charStart + "]|\\.|\\/)+)", "g"),
    charToTag: {
        "": "context",
        "&": "context",
        "#": "id"
    }
};

const childSeg = new RegExp("\\s*(>)?\\s*", "g");
// var whiteSpace = new RegExp("^\\w*$");

// Parses a selector expression into a data structure holding a list of predicates
// 2nd argument is a "strategy" structure, e.g.  fluid.simpleCSSMatcher or fluid.IoCSSMatcher
// unsupported, non-API function
fluid.parseSelector = function (selstring, strategy) {
    const togo = [];
    selstring = selstring.trim();
    //ws-(ss*)[ws/>]
    const regexp = strategy.regexp;
    regexp.lastIndex = 0;
    let lastIndex = 0;
    while (true) {
        const atNode = []; // a list of predicates at a particular node
        let first = true;
        while (true) {
            const segMatch = regexp.exec(selstring);
            if (!segMatch) {
                break;
            }
            if (segMatch.index !== lastIndex) {
                if (first) {
                    fluid.fail("Error in selector string - cannot match child selector expression starting at " + selstring.substring(lastIndex));
                }
                else {
                    break;
                }
            }
            const thisNode = {};
            const text = segMatch[2];
            const targetTag = strategy.charToTag[segMatch[1]];
            if (targetTag) {
                thisNode[targetTag] = text;
            }
            atNode[atNode.length] = thisNode;
            lastIndex = regexp.lastIndex;
            first = false;
        }
        childSeg.lastIndex = lastIndex;
        const fullAtNode = {predList: atNode};
        const childMatch = childSeg.exec(selstring);
        if (!childMatch || childMatch.index !== lastIndex) {
            fluid.fail("Error in selector string - can not match child selector expression at " + selstring.substring(lastIndex));
        }
        if (childMatch[1] === ">") {
            fullAtNode.child = true;
        }
        togo[togo.length] = fullAtNode;
        // >= test here to compensate for IE bug http://blog.stevenlevithan.com/archives/exec-bugs
        if (childSeg.lastIndex >= selstring.length) {
            break;
        }
        lastIndex = childSeg.lastIndex;
        regexp.lastIndex = childSeg.lastIndex;
    }
    return togo;
};

// Message resolution and templating

/**
 *
 * Simple string template system.  Takes a template string containing tokens in the form of "%value" or
 * "%deep.path.to.value".  Returns a new string with the tokens replaced by the specified values.  Keys and values
 * can be of any data type that can be coerced into a string.
 *
 * @param {String} template - A string that contains placeholders for tokens of the form `%token` embedded into it.
 * @param {Object.<String.String>} values - A map of token names to the values which should be interpolated.
 * @return {String} The text of `template` whose tokens have been interpolated with values.
 */
fluid.stringTemplate = function (template, values) {
    let keys = Object.keys(values);
    keys = keys.sort((keya, keyb) => keyb.length - keya.length);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const templatePlaceholder = "%" + key;
        const replacementValue = values[key];

        let indexOfPlaceHolder = -1;
        while ((indexOfPlaceHolder = template.indexOf(templatePlaceholder)) !== -1) {
            template = template.slice(0, indexOfPlaceHolder) + replacementValue + template.slice(indexOfPlaceHolder + templatePlaceholder.length);
        }
    }
    return template;
};
