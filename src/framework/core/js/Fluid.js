/* global preactSignalsCore */

"use strict";

// noinspection ES6ConvertVarToLetConst // otherwise this is a duplicate on minifying
var {signal, effect, computed} = preactSignalsCore;

const fluidJSScope = function (fluid) {

    fluid.version = "Infusion 6.0.0";

    // Export this for use in environments like node.js, where it is useful for
    // configuring stack trace behaviour
    fluid.Error = Error;

    fluid.environment = {
        fluid: fluid
    };

    fluid.global = fluid.global || typeof window !== "undefined" ?
        window : typeof self !== "undefined" ? self : {};

    // A standard utility to schedule the invocation of a function after the current
    // stack returns. On browsers this defaults to setTimeout(func, 0) but in
    // other environments can be customised - e.g. to process.nextTick in node.js
    // In future, this could be optimised in the browser to not dispatch into the event queue
    // See https://github.com/YuzuJS/setImmediate for a more verbose but very robust replacement
    fluid.invokeLater = function (func) {
        return setTimeout(func, 0);
    };

    // The following flag defeats all logging/tracing activities in the most performance-critical parts of the framework.
    // This should really be performed by a build-time step which eliminates calls to pushActivity/popActivity and fluid.log.
    fluid.defeatLogging = true;

    // This flag enables the accumulating of all "activity" records generated by pushActivity into a running trace, rather
    // than removing them from the stack record permanently when receiving popActivity. This trace will be consumed by
    // visual debugging tools.
    fluid.activityTracing = false;
    fluid.activityTrace = [];

    const activityParser = /(%\w+)/g;

    // Patched in FluidIL.js
    fluid.isComponent = () => false;

    fluid.renderActivityArgument = function (arg) {
        if (fluid.isComponent(arg)) {
            return fluid.dumpComponentAndPath(arg);
        } else {
            return arg;
        }
    };

    // Renders a single activity element in a form suitable to be sent to a modern browser's console
    // unsupported, non-API function
    fluid.renderOneActivity = function (activity, nowhile) {
        const togo = nowhile === true ? [] : ["    while "];
        const message = activity.message;
        let index = activityParser.lastIndex = 0;
        while (true) {
            const match = activityParser.exec(message);
            if (match) {
                const key = match[1].substring(1);
                togo.push(message.substring(index, match.index));
                togo.push(fluid.renderActivityArgument(activity.args[key]));
                index = activityParser.lastIndex;
            } else {
                break;
            }
        }
        if (index < message.length) {
            togo.push(message.substring(index));
        }
        return togo;
    };

    // Renders an activity stack in a form suitable to be sent to a modern browser's console
    // unsupported, non-API function
    fluid.renderActivity = function (activityStack, renderer) {
        renderer = renderer || fluid.renderOneActivity;
        return activityStack.map(renderer);
    };

    // TODO: This really needs to be threaded through the signal graph rather than stored on the call stack
    fluid.activityStack = [];

    // Return an array of objects describing the current activity
    // unsupported, non-API function
    fluid.getActivityStack = function () {
        return fluid.activityStack;
    };

    // Renders either the current activity or the supplied activity to the console
    fluid.logActivity = function (activity) {
        activity = activity || fluid.getActivityStack();
        const rendered = fluid.renderActivity(activity).reverse();
        if (rendered.length > 0) {
            fluid.log("Current activity: ");
            fluid.each(rendered, function (args) {
                fluid.log.apply(null, args);
            });
        }
    };

    // Execute the supplied function with the specified activity description pushed onto the stack
    // unsupported, non-API function
    fluid.pushActivity = function (type, message, args) {
        const record = {type: type, message: message, args: args, time: new Date().getTime()};
        if (fluid.activityTracing) {
            fluid.activityTrace.push(record);
        }
        if (fluid.passLogLevel(fluid.logLevel.TRACE)) {
            fluid.log.apply(null, fluid.renderOneActivity(record, true));
        }
        const activityStack = fluid.getActivityStack();
        activityStack.push(record);
    };

    // Undo the effect of the most recent pushActivity, or multiple frames if an argument is supplied
    fluid.popActivity = function (popframes) {
        popframes = popframes || 1;
        if (fluid.activityTracing) {
            fluid.activityTrace.push({pop: popframes});
        }
        const activityStack = fluid.getActivityStack();
        const popped = activityStack.length - popframes;
        activityStack.length = popped < 0 ? 0 : popped;
    };

    // "this-ist" style Error so that we can distinguish framework errors whilst still retaining access to platform Error features
    // Solution taken from http://stackoverflow.com/questions/8802845/inheriting-from-the-error-object-where-is-the-message-property#answer-17936621
    fluid.FluidError = function (/*message*/) {
        const togo = Error.apply(this, arguments);
        this.message = togo.message;
        this.stack = togo.stack;
        return this;
    };

    fluid.FluidError.prototype = Object.create(Error.prototype);

    // The framework's built-in "log" failure handler - this logs the supplied message as well as any framework activity in progress via fluid.log
    fluid.logFailure = function (args, activity) {
        fluid.log.apply(null, [fluid.logLevel.FAIL, "ASSERTION FAILED: "].concat(args));
        fluid.logActivity(activity);
    };

    fluid.renderLoggingArg = function (arg) {
        return arg === undefined ? "undefined" : fluid.isPrimitive(arg) || !fluid.isPlainObject(arg) ? arg : JSON.stringify(arg);
    };

    // The framework's built-in "fail" failure handler - this throws an exception of type <code>fluid.FluidError</code>
    fluid.builtinFail = function (args /*, activity*/) {
        const message = args.map(fluid.renderLoggingArg).join(" ");
        throw new fluid.FluidError("Assertion failure - check console for more details: " + message);
    };

    /**
     * Signals an error to the framework. The default behaviour is to log a structured error message and throw an exception. This strategy may be configured
     * by adding and removing suitably namespaced listeners to the special event <code>fluid.failureEvent</code>
     *
     * @param {...String} messages - The error messages to log.
     *
     * All arguments after the first are passed on to (and should be suitable to pass on to) the native console.log
     * function.
     */
    fluid.fail = function (...messages) {
        const activity = fluid.makeArray(fluid.getActivityStack()); // Take copy since we will destructively modify
        fluid.popActivity(activity.length); // clear any current activity - TODO: the framework currently has no exception handlers, although it will in time
        if (fluid.failureEvent) { // notify any framework failure prior to successfully setting up the failure event below
            fluid.failureEvent.fire(messages, activity);
        } else {
            fluid.logFailure(messages, activity);
            fluid.builtinFail(messages, activity);
        }
    };

    // TODO: rescued from kettleCouchDB.js - clean up in time
    fluid.expect = function (name, target, members) {
        fluid.transform(fluid.makeArray(members), function (key) {
            if (target[key] === undefined) {
                fluid.fail(name + " missing required member " + key);
            }
        });
    };

    // Logging

    /** Returns whether logging is enabled - legacy method
     * @return {Boolean} `true` if the current logging level exceeds `fluid.logLevel.IMPORTANT`
     */
    fluid.isLogging = function () {
        return fluid.logLevelStack[0].priority > fluid.logLevel.IMPORTANT.priority;
    };

    /** Determines whether the supplied argument is a valid logLevel marker
     * @param {any} arg - The value to be tested
     * @return {Boolean} `true` if the supplied argument is a logLevel marker
     */
    fluid.isLogLevel = function (arg) {
        return fluid.isMarker(arg) && arg.priority !== undefined;
    };

    /** Check whether the current framework logging level would cause a message logged with the specified level to be
     * logged. Clients who issue particularly expensive log payload arguments are recommended to guard their logging
     * statements with this function
     * @param {LogLevel} testLogLevel - The logLevel value which the current logging level will be tested against.
     * Accepts one of the members of the <code>fluid.logLevel</code> structure.
     * @return {Boolean} Returns <code>true</code> if a message supplied at that log priority would be accepted at the current logging level.
     */

    fluid.passLogLevel = function (testLogLevel) {
        return testLogLevel.priority <= fluid.logLevelStack[0].priority;
    };

    /** Method to allow user to control the current framework logging level. The supplied level will be pushed onto a stack
     * of logging levels which may be popped via `fluid.popLogging`.
     * @param {Boolean|LogLevel} enabled - Either a boolean, for which <code>true</code>
     * represents <code>fluid.logLevel.INFO</code> and <code>false</code> represents <code>fluid.logLevel.IMPORTANT</code> (the default),
     * or else any other member of the structure <code>fluid.logLevel</code>
     * Messages whose priority is strictly less than the current logging level will not be shown by `fluid.log`
     */
    fluid.setLogging = function (enabled) {
        let logLevel;
        if (typeof enabled === "boolean") {
            logLevel = fluid.logLevel[enabled ? "INFO" : "IMPORTANT"];
        } else if (fluid.isLogLevel(enabled)) {
            logLevel = enabled;
        } else {
            fluid.fail("Unrecognised fluid logging level ", enabled);
        }
        fluid.logLevelStack.unshift(logLevel);
        fluid.defeatLogging = !fluid.isLogging();
    };

    fluid.setLogLevel = fluid.setLogging;

    /** Undo the effect of the most recent "setLogging", returning the logging system to its previous state
     * @return {LogLevel} The logLevel that was just popped
     */
    fluid.popLogging = function () {
        const togo = fluid.logLevelStack.length === 1 ? fluid.logLevelStack[0] : fluid.logLevelStack.shift();
        fluid.defeatLogging = !fluid.isLogging();
        return togo;
    };

    /** Actually do the work of logging <code>args</code> to the environment's console. If the standard "console"
     * stream is available, the message will be sent there.
     * @param {Array} args - The complete array of arguments to be logged
     */
    fluid.doBrowserLog = function (args) {
        /* eslint-disable no-console */
        if (typeof(console) !== "undefined") {
            if (console.debug) {
                console.debug.apply(console, args);
            } else if (typeof(console.log) === "function") {
                console.log.apply(console, args);
            }
            /* eslint-enable no-console */
        }
        /* eslint-enable no-console */
    };

    /* Log a message to a suitable environmental console. If the first argument to fluid.log is
     * one of the members of the <code>fluid.logLevel</code> structure, this will be taken as the priority
     * of the logged message - else if will default to <code>fluid.logLevel.INFO</code>. If the logged message
     * priority does not exceed that set by the most recent call to the <code>fluid.setLogging</code> function,
     * the message will not appear.
     */
    fluid.log = function (/* message /*, ... */) {
        const directArgs = fluid.makeArray(arguments);
        let userLogLevel = fluid.logLevel.INFO;
        if (fluid.isLogLevel(directArgs[0])) {
            userLogLevel = directArgs.shift();
        }
        if (fluid.passLogLevel(userLogLevel)) {
            fluid.loggingEvent.fire(directArgs);
        }
    };

    // Type checking functions

    /**
     * Check whether the argument is a primitive type
     *
     * @param {any} value - The value to be tested
     * @return {Boolean} `true` if the supplied value is a JavaScript (ES5) primitive
     */
    fluid.isPrimitive = function (value) {
        const valueType = typeof(value);
        return !value || valueType === "string" || valueType === "boolean" || valueType === "number" || valueType === "function";
    };

    /** Determines whether the supplied object can be treated as an array (primarily, by iterating over numeric keys bounded from 0 to length).
     * The strategy used is an optimised approach taken from an earlier version of jQuery - detecting whether the toString() version
     * of the object agrees with the textual form [object Array]
     *
     * @param {any} totest - The value to be tested
     * @return {Boolean} `true` if the supplied value is an array
     */
    fluid.isArrayable = function (totest) {
        return Boolean(totest) && (Object.prototype.toString.call(totest) === "[object Array]");
    };

    /**
     * Determines whether the supplied object is a plain JSON-forming container - that is, it is either a plain Object
     * or a plain Array. Note that this differs from jQuery's isPlainObject which does not pass Arrays.
     *
     * @param {any} totest - The object to be tested
     * @param {Boolean} [strict] - (optional) If `true`, plain Arrays will fail the test rather than passing.
     * @return {Boolean} - `true` if `totest` is a plain object, `false` otherwise.
     */
    fluid.isPlainObject = function (totest, strict) {
        const string = Object.prototype.toString.call(totest);
        if (string === "[object Array]") {
            return !strict;
        } else if (string !== "[object Object]") {
            return false;
        } // FLUID-5226: This inventive strategy taken from jQuery detects whether the object's prototype is directly Object.prototype by virtue of having an "isPrototypeOf" direct member
        return !totest.constructor || !totest.constructor.prototype || Object.prototype.hasOwnProperty.call(totest.constructor.prototype, "isPrototypeOf");
    };

    /**
     * Returns a string typeCode representing the type of the supplied value at a coarse level.
     * Returns <code>primitive</code>, <code>array</code> or <code>object</code> depending on whether the supplied object has
     * one of those types, by use of the <code>fluid.isPrimitive</code>, <code>fluid.isPlainObject</code> and <code>fluid.isArrayable</code> utilities
     *
     * @param {any} totest - The value to be tested
     * @return {String} Either `primitive`, `array` or `object` depending on the type of the supplied value
     */
    fluid.typeCode = function (totest) {
        return fluid.isPrimitive(totest) || !fluid.isPlainObject(totest) ? "primitive" :
            fluid.isArrayable(totest) ? "array" : "object";
    };

    /** Determine whether the supplied value is an IL reference. The test is passed if the value is a string whose
     * first character is "{" and has closing "}" character somewhere in the string
     * @param {any} ref - The value to be tested
     * @return {Boolean} `true` if the supplied value is an IL reference
     */
    fluid.isILReference = function (ref) {
        return typeof(ref) === "string" && ref.charAt(0) === "{";
    };

    /** Determine whether the supplied value is a reference or an expander. The test is passed if either fluid.isILReference passes
     * or the value has an "expander" member
     * @param {any} ref - The value to be tested
     * @return {Boolean} `true` if the supplied value is a reference or expander
     */
    fluid.isReferenceOrExpander = function (ref) {
        return ref && (fluid.isILReference(ref) || ref.expander);
    };

    fluid.isDOMNode = function (obj) {
        // This could be more sound, but messy:
        // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
        // The real problem is browsers like IE6, 7 and 8 which still do not feature a "constructor" property on DOM nodes
        return obj && typeof(obj.nodeType) === "number";
    };

    fluid.isUncopyable = function (totest) {
        return fluid.isPrimitive(totest) || !fluid.isPlainObject(totest);
    };

    // Functional programming utilities.

    /** A function which raises a failure if executed */
    fluid.notImplemented = function () {
        fluid.fail("This operation is not implemented");
    };

    /* A basic utility that returns its argument unchanged */
    fluid.identity = function (arg) {
        return arg;
    };

    /** Return an empty container as the same type as the argument (either an array or hash)
     * @param {Object|Array} tocopy - An exemplar for which a fresh container is required
     * @return {Object|Array} A fresh object of the same type as `tocopy`
     */
    fluid.freshContainer = function (tocopy) {
        return fluid.isArrayable(tocopy) ? [] : {};
    };

    /**
     * Determine whether the supplied object path exceeds the maximum strategy recursion depth of fluid.strategyRecursionBailout -
     * if it does, fluid.fail will be issued with a diagnostic
     *
     * @param {String} funcName - The name of the function to appear in the diagnostic if issued
     * @param {String[]} segs - The segments of the path that the strategy has reached
     */
    fluid.testStrategyRecursion = function (funcName, segs) {
        if (segs.length > fluid.strategyRecursionBailout) {
            fluid.fail("Runaway recursion encountered in " + funcName + " - reached path depth of " + fluid.strategyRecursionBailout + " via path of " + segs.join(".") +
                "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout");
        }
    };

    fluid.copyRecurse = function (tocopy, segs) {
        fluid.testStrategyRecursion("fluid.copy", segs);
        if (fluid.isUncopyable(tocopy)) {
            return tocopy;
        } else {
            return fluid.transform(tocopy, function (value, key) {
                segs.push(key);
                const togo = fluid.copyRecurse(value, segs);
                segs.pop();
                return togo;
            });
        }
    };

    /* Performs a deep copy (clone) of its argument. This will guard against cloning a circular object by terminating if it reaches a path depth
     * greater than <code>fluid.strategyRecursionBailout</code>
     */

    fluid.copy = function (tocopy) {
        return fluid.copyRecurse(tocopy, []);
    };


    /* Corrected version of jQuery makeArray that returns an empty array on undefined rather than crashing.
     * We don't deal with as many pathological cases as jQuery */
    fluid.makeArray = function (arg) {
        const togo = [];
        if (arg !== null && arg !== undefined) {
            if (fluid.isPrimitive(arg) || fluid.isPlainObject(arg, true) || typeof(arg.length) !== "number") {
                togo.push(arg);
            } else {
                for (let i = 0; i < arg.length; ++i) {
                    togo[i] = arg[i];
                }
            }
        }
        return togo;
    };

    /**
     * Pushes an element or elements onto an array, initialising the array as a member of a holding object if it is
     * not already allocated.
     * @param {Array|Object} holder - The holding object whose member is to receive the pushed element(s).
     * @param {String} member - The member of the <code>holder</code> onto which the element(s) are to be pushed
     * @param {Array|any} topush - If an array, these elements will be added to the end of the array using Array.push.apply.
     * If a non-array, it will be pushed to the end of the array using Array.push.
     */
    fluid.pushArray = function (holder, member, topush) {
        const array = holder[member] ? holder[member] : (holder[member] = []);
        if (Array.isArray(topush)) {
            array.push.apply(array, topush);
        } else {
            array.push(topush);
        }
    };

    /**
     * Transforms the properties of an object or elements of an array by applying a provided function to each item.
     *
     * @param {Object} source - The object to transform. If `null` or `undefined`, the function returns the input as-is.
     * @param {Function} func - The transformation function to apply to each item. It is called with two arguments:
     *   - `value` (any): The value of the current property or element.
     *   - `key` (String): The key of the current property .
     * @return {Object} A new object or array with transformed values. If `source` is `null` or `undefined`, it is returned unchanged.
     */
    fluid.transform = function (source, func) {
        if (source) {
            const togo = {};
            for (const key in source) {
                togo[key] = func(source[key], key);
            }
            return togo;
        } else {
            return source;
        }
    };

    /**
     * Iterates over the properties of an object, invoking a provided function for each item.
     *
     * @param {Object} source - The object or array to iterate over. If `null` or `undefined`, the function does nothing.
     * @param {Function} func - The function to be invoked for each item. It is called with two arguments:
     *   - `value` (any): The value of the current property or element.
     *   - `key` (String|Number): The key of the current property.
     */
    fluid.each = function (source, func) {
        if (source) {
            for (const key in source) {
                func(source[key], key);
            }
        }
    };

    /**
     * Return the last element of an array. If the array is of length 0, returns `undefined`.
     * @param {Array} array - The array to be peeked into - any "Arrayable" with a valid `length` property is supported
     * @return {any} start - The last element of the array
     */
    fluid.peek = function (array) {
        return array.length === 0 ? undefined : array[array.length - 1];
    };

    /** Scan through an array or hash of objects, removing those which match a predicate. Similar to
     * jQuery.grep, only acts on the list in-place by removal, rather than by creating
     * a new list by inclusion.
     * @param {Array|Object} source - The array or hash of objects to be scanned over. Note that in the case this is an array,
     * the iteration will proceed from the end of the array towards the front.
     * @param {Function} fn - A predicate function determining whether an element should be
     * removed. This accepts the standard signature (object, index) and returns a "truthy"
     * result in order to determine that the supplied object should be removed from the structure.
     * @param {Array|Object} [target] - (optional) A target object of the same type as <code>source</code>, which will
     * receive any objects removed from it.
     * @return {Array|Object} - <code>target</code>, containing the removed elements, if it was supplied, or else <code>source</code>
     * modified by the operation of removing the matched elements.
     */
    fluid.remove_if = function (source, fn, target) {
        if (fluid.isArrayable(source)) {
            for (let i = source.length - 1; i >= 0; --i) {
                if (fn(source[i], i)) {
                    if (target) {
                        target.unshift(source[i]);
                    }
                    source.splice(i, 1);
                }
            }
        } else {
            for (const key in source) {
                if (fn(source[key], key)) {
                    if (target) {
                        target[key] = source[key];
                    }
                    delete source[key];
                }
            }
        }
        return target || source;
    };

    /** Returns an array of size count, filled with increasing integers, starting at 0 or at the index specified by first.
     * @param {Number} count - Size of the filled array to be returned
     * @param {Number} [first] - (optional, defaults to 0) First element to appear in the array
     * @return {Array<Number>} A filled array of size `count`
     */
    fluid.iota = function (count, first) {
        first = first || 0;
        const togo = [];
        for (let i = 0; i < count; ++i) {
            togo[togo.length] = first++;
        }
        return togo;
    };

    /** Extracts a particular member from each top-level member of a container, returning a new container of the same type
     * @param {Array|Object} holder - The container to be filtered
     * @param {String|String[]} name - An EL path to be fetched from each top-level member
     * @return {Array|Object} - The desired structure of fetched members
     */
    fluid.getMembers = function (holder, name) {
        return fluid.transform(holder, function (member) {
            return fluid.get(member, name);
        });
    };

    /** Accepts an object to be filtered, and an array of keys. Either all keys not present in
     * the array are removed, or only keys present in the array are returned.
     * @param {Object} toFilter - The object to be filtered - this will be NOT modified by the operation (current implementation
     * passes through $.extend shallow algorithm)
     * @param {String[]} keys - The array of keys to operate with
     * @param {Boolean} exclude - If <code>true</code>, the keys listed are removed rather than included
     * @return {Object} the filtered object (the same object that was supplied as <code>toFilter</code>
     */
    fluid.filterKeys = function (toFilter, keys, exclude) {
        return fluid.remove_if($.extend({}, toFilter), function (value, key) {
            return exclude ^ (keys.indexOf(key) === -1);
        });
    };

    /* A convenience wrapper for <code>fluid.filterKeys</code> with the parameter <code>exclude</code> set to <code>true</code>
     *  Returns the supplied object with listed keys removed */
    fluid.censorKeys = function (toCensor, keys) {
        return fluid.filterKeys(toCensor, keys, true);
    };

    /**
     * Returns the converted integer if the input string can be converted to an integer. Otherwise, return NaN.
     *
     * @param {String|Number} string - A string to be returned in integer form.
     * @return {Number|NaN} - The numeric value if the string can be converted, otherwise, returns NaN.
     */
    fluid.parseInteger = function (string) {
        return isFinite(string) && ((string % 1) === 0) ? Number(string) : NaN;
    };

    /**
     * Derived from Sindre Sorhus's round-to node module ( https://github.com/sindresorhus/round-to ).
     * License: MIT
     *
     * Rounds the supplied number to at most the number of decimal places indicated by the scale, omitting any trailing 0s.
     * There are three possible rounding methods described below: "round", "ceil", "floor"
     * Round: Numbers are rounded away from 0 (i.e 0.5 -> 1, -0.5 -> -1).
     * Ceil: Numbers are rounded up
     * Floor: Numbers are rounded down
     * If the scale is invalid (i.e falsey, not a number, negative value), it is treated as 0.
     * If the scale is a floating point number, it is rounded to an integer.
     *
     * @param {Number} num - the number to be rounded
     * @param {Number} scale - the maximum number of decimal places to round to.
     * @param {String} [method] - (optional) Request a rounding method to use ("round", "ceil", "floor").
     *                          If nothing or an invalid method is provided, it will default to "round".
     * @return {Number} The num value rounded to the specified number of decimal places.
     */
    fluid.round = function (num, scale, method) {
        // treat invalid scales as 0
        scale = scale && scale >= 0 ? Math.round(scale) : 0;

        if (method === "ceil" || method === "floor") {
            // The following is derived from https://github.com/sindresorhus/round-to/blob/v2.0.0/index.js#L20
            return Number(Math[method](num + "e" + scale) + "e-" + scale);
        } else {
            // The following is derived from https://github.com/sindresorhus/round-to/blob/v2.0.0/index.js#L17
            const sign = Math.sign(num);
            return Number(sign * (Math.round(Number(Math.abs(num) + "e" + scale)) + "e-" + scale));
        }
    };

    /**
     * Calls Object.freeze at each level of containment of the supplied object.
     *
     * @param {any} tofreeze - The material to freeze.
     * @param {String[]} [segs] - Implementation-internal - path segments that recursion has reached.
     * @return {any} - The supplied argument, recursively frozen.
     */
    fluid.freezeRecursive = function (tofreeze, segs) {
        segs = segs || [];
        fluid.testStrategyRecursion("fluid.freezeRecursive", segs);
        if (fluid.isPlainObject(tofreeze)) {
            fluid.each(tofreeze, function (value, key) {
                segs.push(key);
                fluid.freezeRecursive(value, segs);
                segs.pop();
            });
            return Object.freeze(tofreeze);
        } else {
            return tofreeze;
        }
    };

    /*
     * A set of special "marker values" used in signalling in function arguments and return values,
     * to partially compensate for JavaScript's lack of distinguished types. These should never appear
     * in JSON structures or other kinds of static configuration. An API specifically documents if it
     * accepts or returns any of these values, and if so, what its semantic is  - most are of private
     * use internal to the framework
     */
    fluid.marker = function () {
    };
    /**
     * Create a marker object with a specific type and additional properties.
     * Markers are optionally mutable or immutable (frozen).
     *
     * @param {String} type - The type of the marker.
     * @param {Object} [extra={}] - Additional properties to include in the marker.
     * @param {Boolean} [mutable=false] - Whether the marker should be mutable or immutable.
     * @return {fluid.marker} The created marker object.
     */
    fluid.makeMarker = function (type, extra, mutable) {
        const togo = Object.create(fluid.marker.prototype);
        Object.assign(togo, {...extra || {}, ...{type}});
        return mutable ? togo : Object.freeze(togo);
    };

    /* A special "marker object" representing that no value is present (where
     * signalling using the value "undefined" is not possible - e.g. the return value from a "strategy"). This
     * is intended for "ephemeral use", i.e. returned directly from strategies and transforms and should not be
     * stored in data structures */
    // TODO: No longer currently consumed by fluid.transform but maybe we want it back
    fluid.NoValue = fluid.makeMarker("No Value");

    /**
     * Check if an object is a marker of a specific type or one of a set of types.
     *
     * @param {Object} totest - The object to test.
     * @param {String|String[]} [types] - The type or types to check against.
     *     If not provided, returns `true` for any marker.
     * @return {Boolean} `true` if the object is a marker of the specified type(s), otherwise `false`.
     */
    fluid.isMarker = function (totest, types) {
        if (!(totest instanceof fluid.marker)) {
            return false;
        }
        if (!types) {
            return true;
        } else if (typeof(types) === "string") {
            return totest.type === types;
        } else {
            return types.includes(totest.type);
        }
    };

    fluid.logLevelsSpec = {
        "FATAL": 0,
        "FAIL": 5,
        "WARN": 10,
        "IMPORTANT": 12, // The default logging "off" level - corresponds to the old "false"
        "INFO": 15, // The default logging "on" level - corresponds to the old "true"
        "TRACE": 20
    };

    /* A structure holding all supported log levels as supplied as a possible first argument to fluid.log
     * Members with a higher value of the "priority" field represent lower priority logging levels */
    fluid.logLevel = fluid.transform(fluid.logLevelsSpec, (key, value) => fluid.makeMarker(key, {priority: value}));

    fluid.logLevelStack = [fluid.logLevel.IMPORTANT]; // The stack of active logging levels, with the current level at index 0

    /**
     * Create a marker representing an "Unavailable" state with an associated waitset.
     * The marker is mutable.
     *
     * @param {Object|Array} [cause={}] - A list of dependencies or reasons for unavailability.
     * @return {fluid.marker} A marker of type "Unavailable".
     */
    fluid.unavailable = (cause = {}) => fluid.makeMarker("Unavailable", {
        causes: fluid.makeArray(cause).map(oneCause => {
            if (!oneCause.type) {
                oneCause.type = "Unavailable";
            }
            return oneCause;
        })
    }, true);

    /**
     * Create a marker representing an "Error" state with associated arguments.
     * The marker is mutable.
     *
     * @param {...*} args - The arguments providing details about the error.
     * @return {fluid.marker} A marker of type "Error".
     */
    fluid.error = (...args) => fluid.makeMarker("Unavailable", {causes: [{type: "Error", message: args}]}, true);

    /**
     * Check if an object is a marker of type "Unavailable" or "Error".
     *
     * @param {Object} totest - The object to test.
     * @return {Boolean} `true` if the object is a marker of type "Unavailable", otherwise `false`.
     */
    fluid.isUnavailable = totest => totest instanceof fluid.marker && totest.type === "Unavailable";

    /**
     * Merge two "unavailable" markers into a single marker, combining their causes.
     * If the existing marker is `null` or `undefined`, the fresh marker is returned as-is.
     *
     * @param {Object|null|undefined} existing - The existing "unavailable" marker, or `null`/`undefined` if none exists.
     * @param {Object} fresh - The new "unavailable" marker to merge with the existing one.
     * @return {Object} A combined "unavailable" marker with merged causes, or the fresh marker if no existing marker is provided.
     */
    fluid.mergeUnavailable = function (existing, fresh) {
        return !existing ? fresh : fluid.unavailable(existing.causes.concat(fresh.causes));
    };

    /*** SIGNAL PROCESSING ***/

    // Monkey-patch core framework to support wide range of primitives and JSON initial values
    fluid.coerceToPrimitive = function (string) {
        return /^(true|false|null)$/.test(string) || /^[\[{0-9]/.test(string) && !/^{\w/.test(string) ? JSON.parse(string) : string;
    };

    /**
     * Check whether a given value is an instance of a `preactSignalsCore.Signal`.
     * @param {any} value - The value to test.
     * @return {Boolean} `true` if the value is a `Signal`, otherwise `false`.
     */
    fluid.isSignal = value => value instanceof preactSignalsCore.Signal;

    /**
     * Resolve a value from a `Signal` (possibly recursively), or return the value as-is if it is not a `Signal`.
     *
     * @param {any} ref - The value to resolve. May be a `Signal` or a plain value.
     * @return {any} The resolved value if `ref` is a `Signal`, or the original value if it is not.
     */
    fluid.deSignal = ref => {
        while (fluid.isSignal(ref)) {
            ref = ref.value;
        }
        return ref;
    };

    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * Recursively traverse a data structure, resolving any `Signal` values to their underlying values.
     * @param {any} root - The root data structure to process.
     * @return {any} The processed data structure with all `Signal` values resolved and flattened into primitive values where applicable.
     */
    fluid.flattenSignals = function (root) {
        const value = fluid.deSignal(root);
        return fluid.isPrimitive(value) || !fluid.isPlainObject(value) ? value :
            fluid.isArrayable(value) ? value.map(fluid.flattenSignals) : fluid.transform(value, fluid.flattenSignals);
    };

    /**
     * Process an array of arguments, unwrapping values from `preactSignalsCore.Signal` objects
     * and identifying and coalescing "unavailable" values if present.
     *
     * @param {Array} args - The array of arguments to process.
     *     Arguments may include `preactSignalsCore.Signal` instances or plain values.
     * @param {Object} [options] - Additional specifications for processing arguments (optional).
     * @return {Object} An object with the following properties:
     *     - `designalArgs` (Array): The array of arguments with `Signal` values replaced by their unwrapped values.
     *     - `unavailable` (Object|undefined): The most "unavailable" value (if any) based on priority,
     *       or `undefined` if no unavailable values are found.
     */
    fluid.processSignalArgs = function (args, options) {
        let unavailable = undefined;
        const designalArgs = [];
        const flattenArg = options?.flattenArg;
        for (let i = 0; i < args.length; ++i) {
            const arg = args[i];
            if (arg instanceof preactSignalsCore.Signal) {
                const value = flattenArg ? flattenArg(arg, i) : arg.value;
                designalArgs.push(value);
                if (fluid.isUnavailable(value)) {
                    unavailable = fluid.mergeUnavailable(unavailable, value);
                }
            } else {
                designalArgs.push(arg);
            }
        }
        return {designalArgs, unavailable};
    };

    /**
     * Create a computed value based on a function and its arguments, resolving any signals and handling unavailability.
     *
     * @param {Function|Signal<Function>} func - The function to compute the value
     * @param {Array} args - The arguments to pass to the function. These may include signals, which will be resolved.
     * @param {Object} [options] - Additional specifications for processing arguments (optional).
     * @return {Object} A computed value that resolves the function's result, or an "unavailable" marker if any argument is unavailable.
     */
    fluid.computed = function (func, args, options) {
        return computed(() => {
            const {designalArgs, unavailable} = fluid.processSignalArgs(args, options);
            return unavailable ? unavailable : fluid.deSignal(func).apply(null, designalArgs);
        });
    };

    // TODO: Return needs to be wrapped in a special marker so that component destruction can dispose it
    /**
     * Create an effect that executes a function with resolved arguments, resolving any signals and handling unavailability.
     *
     * @param {Function} func - The function to execute
     * @param {Array} args - The arguments to pass to the function. These may include signals, which will be resolved.
     * @param {Array} [argSpecs] - Additional specifications for processing arguments (optional).
     * @return {Object} An effect that executes the function if all arguments are available, or does nothing if any argument is unavailable.
     */
    fluid.effect = function (func, args, argSpecs) {
        return effect(() => {
            const {designalArgs, unavailable} = fluid.processSignalArgs(args, argSpecs);
            if (!unavailable) {
                func.apply(null, designalArgs);
            }
        });
    };

    // Reproduce constructor at https://github.com/preactjs/signals/blob/main/packages/core/src/index.ts#L524-L531
    // via mangled names registry at https://github.com/preactjs/signals/blob/main/mangle.json

    fluid.rebindComputed = function (computed, func) {
        computed.x = func;       // this._fn = fn;
        computed.s = undefined;  // this._sources = undefined;
        // this._globalVersion = globalVersion - 1; // presumably don't need to reproduce this
        computed.f = 1 << 2;     // this._flags = OUTDATED;
    };

    // Path handling

    // See original comment fom old Fluid.js
    // Performance testing in early 2015 suggests that modern browsers now allow these to execute slightly faster
    // than the equivalent machinery written using complex regexps - therefore they will continue to be maintained
    // here. However, there is still a significant performance gap with respect to the performance of String.split(".")
    // especially on Chrome, so we will continue to insist that component member names do not contain a "." character
    // for the time being.
    // Retesting in 2024 shows that the advantage is still there
    fluid.getPathSegmentImpl = function (accept, path, i) {
        let segment = "";
        let escaped = false;
        const limit = path.length;
        for (; i < limit; ++i) {
            const c = path.charAt(i);
            if (!escaped) {
                if (c === ".") {
                    break;
                } else if (c === "\\") {
                    escaped = true;
                } else {
                    segment += c;
                }
            } else {
                escaped = false;
                segment += c;
            }
        }
        accept[0] = segment;
        return i;
    };

    /** Parse an IL path separated by periods (.) into its component segments.
     * @param {String} path - The path expression to be split
     * @return {String[]} Path parsed into segments.
     */
    fluid.parsePath = function (path) {
        const togo = [], accept = [null];
        let index = 0;
        const limit = path.length;
        while (index < limit) {
            const firstdot = fluid.getPathSegmentImpl(accept, path, index);
            togo.push(accept[0]);
            index = firstdot + 1;
        }
        return togo;
    };

    /**
     * Optionally parse a path expression into its component segments.
     * If the input is a primitive value (e.g., a string), it is parsed into segments using `fluid.parsePath`.
     * If the input is already an array of segments, it is returned unchanged.
     *
     * @param {String|String[]} path - The path expression to be split into segments,
     *     or an array of path segments.
     * @return {String[]} The path represented as an array of segments.
     */
    fluid.pathToSegs = function (path) {
        return fluid.isPrimitive(path) ? fluid.parsePath(path) : path;
    };

    /**
     * Compose a path by appending a segment to an existing prefix, escaping special characters as needed.
     * @param {String} prefix - The initial path prefix.
     * @param {String} toappend - The segment to append to the prefix.
     * @return {String} The composed and escaped path.
     */
    fluid.composePath = function (prefix, toappend) {
        toappend = toappend.toString();
        for (let i = 0; i < toappend.length; ++i) {
            const c = toappend.charAt(i);
            if (c === "." || c === "\\" || c === "}") {
                prefix += "\\";
            }
            prefix += c;
        }
        return prefix;
    };

    /**
     * Compose a single path segment by appending a suffix to a prefix, separated by a period (.) if the prefix is non-empty.
     * Escapes special characters in the suffix as needed.
     * @param {String} prefix - The initial path prefix.
     * @param {String} suffix - The segment to append to the prefix.
     * @return {String} The composed path segment.
     */
    fluid.composeSegment = function (prefix, suffix) {
        if (prefix.length !== 0) {
            prefix += ".";
        }
        return fluid.composePath(prefix, suffix);
    };

    /**
     * Compose a set of path segments supplied as arguments into a single escaped EL expression.
     * Each segment is concatenated with a period (.) separator and special characters are escaped as needed.
     * @param {...String} segments - The individual path segments to compose.
     * @return {String} The fully composed and escaped EL expression.
     */
    fluid.composeSegments = function (...segments) {
        let path = "";
        for (let i = 0; i < segments.length; ++i) {
            path = fluid.composeSegment(path, segments[i]);
        }
        return path;
    };

    /**
     * Retrieve the value at a specified path within a nested object structure.
     * Traverses the object hierarchy based on the path segments.
     *
     * @param {Object} root - The root object to begin traversal from.
     * @param {String|String[]} path - The path to the desired value, specified as a string or an array of path segments.
     * @return {any} The value at the specified path, or `undefined` if the path traverses beyond defined objects.
     */
    fluid.get = function (root, path) {
        const segs = fluid.pathToSegs(path);
        const limit = segs.length;
        for (let j = 0; j < limit; ++j) {
            root = root ? root[segs[j]] : undefined;
        }
        return root;
    };

    /**
     * Traverse a nested object structure, resolving `Signal` values as encountered,
     * and returning a computed or plain value representing the resolved path.
     *
     * @param {any} root - The root object to begin traversal from.
     * @param {String[]} segs - An array of segment names representing the path to traverse.
     * @return {Computed<any>} A computed value that resolves the path through any `Signal` encountered, a plain value if
     * no signals are encountered, or `undefined` if the traversal passes beyond defined objects.
     */
    fluid.getThroughSignals = function (root, segs) {
        const togo = computed(() => {
            let move = fluid.deSignal(root);
            for (let j = 0; j < segs.length; ++j) {
                const seg = segs[j];
                move = fluid.deSignal(move?.[seg]);
            }
            return move;
        });
        togo.$variety = "$ref";
        return togo;
    };

    /**
     * Set a value at a specified path within a nested object structure.
     * Creates intermediate objects as needed to ensure the path exists.
     *
     * @param {Object} root - The root object to begin traversal from.
     * @param {String|String[]} path - The path to the location where the value should be set, specified as a string or an array of path segments.
     * @param {any} newValue - The value to set at the specified path.
     */
    fluid.set = function (root, path, newValue) {
        const segs = fluid.pathToSegs(path);
        for (let i = 0; i < segs.length - 1; ++i) {
            const seg = segs[i];
            if (!root[seg]) {
                root[seg] = Object.create(null);
            }
            root = root[seg];
        }
        root[segs[segs.length - 1]] = newValue;
    };

    /**
     * Traverse a nested object structure and ensure that all segments of the given path exist.
     * If a segment does not exist, it is created as an empty object.
     * Returns a stack of objects traversed or created, starting with the deepest object.
     *
     * @param {Object} root - The root object to begin traversal from.
     * @param {String[]} segs - An array of path segments to traverse.
     * @return {Object[]} A stack of objects traversed or created, with the deepest object at the start of the array.
     */
    fluid.getRecInsist = function (root, segs) {
        const stack = [];
        segs.forEach(seg => {
            if (!root[seg]) {
                root[seg] = Object.create(null);
            }
            root = root[seg];
            stack.unshift(root);
        });
        return stack;
    };

    /** Returns any value held at a particular global path. This may be an object or a function, depending on what has been stored there.
     * @param {String|String[]} path - The global path from which the value is to be fetched
     * @return {any} The value that was stored at the path, or a fluid.unavailable value if there is none.
     */
    fluid.getGlobalValue = path => {
        const value = fluid.get(fluid.global, path);
        return value === undefined ? fluid.unavailable({message: "Global value " + path + " is not defined", path}) : value;
    };

    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * Allows for the calling of a function from an EL expression "functionPath", with the arguments "args"
     * @param {String} functionPath - An global path
     * @param {Object} args - An array of arguments to be applied to the function, specified in functionPath
     * @return {any} - The return value from the invoked function.
     */
    fluid.invokeGlobalFunction = function (functionPath, args) {
        const func = fluid.getGlobalValue(functionPath);
        if (fluid.isUnavailable(func)) {
            return fluid.mergeUnavailable(fluid.unavailable({message: "Error invoking global function: " + functionPath + " could not be located"}), func);
        } else {
            const argsArray = fluid.isArrayable(args) ? args : fluid.makeArray(args);
            return func.apply(null, argsArray);
        }
    };

    /**
     * Set a value in the global namespace at a specified path.
     * This uses `fluid.set` to traverse and create the necessary structure within `fluid.global`.
     * @param {String|String[]} path - The path in the global namespace where the value should be set, specified as a string or an array of path segments.
     * @param {any} value - The value to set at the specified global path.
     */
    fluid.setGlobalValue = (path, value) => {
        fluid.set(fluid.global, path, value);
    };

    /** Ensures that the supplied path has an object allocated in the global Infusion namespace, and retrieves the current value.
     * If no value is stored, a fresh {} will be assigned at the path, and to all currently empty paths leading to the global namespace root.
     * In a browser environment, the global Infusion namespace is rooted in the global `window`.
     * @param {String|String[]} path - The global path at which the namespace is to be allocated.
     * @return {any} Any current value held at the supplied path - or a freshly allocated {} to be held at that path if it was previously empty
     */
    fluid.registerNamespace = function (path) {
        let existing = fluid.getGlobalValue(path);
        if (fluid.isUnavailable(existing)) {
            existing = {};
            fluid.setGlobalValue(path, existing);
        }
        return existing;
    };

    // stubs for two functions in FluidDebugging.js
    fluid.dumpEl = x => x;
    fluid.renderTimestamp = x => x;

    /*** The Fluid instance id ***/

    // unsupported, NON-API function
    fluid.generateUniquePrefix = function () {
        return (Math.floor(Math.random() * 1e12)).toString(36) + "-";
    };

    const fluid_prefix = fluid.generateUniquePrefix();

    fluid.fluidInstance = fluid_prefix;

    let fluid_guid = 1;

    /** Allocate a string value that will be unique within this Infusion instance (frame or process), and
     * globally unique with high probability (50% chance of collision after a million trials)
     * @return {String} A fresh unique id
     */

    fluid.allocateGuid = function () {
        return fluid_prefix + (fluid_guid++);
    };

    /*** The Fluid Priority system. ***/

    // Fluid priority system for encoding relative positions of, e.g. listeners, transforms, options, in lists

    fluid.extremePriority = 4e9; // around 2^32 - allows headroom of 21 fractional bits for sub-priorities
    fluid.priorityTypes = {
        first: -1,
        last: 1,
        before: 0,
        after: 0
    };
    // TODO: This should be properly done with defaults blocks and a much more performant fluid.indexDefaults
    fluid.extremalPriorities = {
        // a built-in definition to allow test infrastructure "last" listeners to sort after all impl listeners, and authoring/debugging listeners to sort after those
        // these are "priority intensities", and will be flipped for "first" listeners
        none: 0,
        transaction: 10,
        testing: 20,
        authoring: 30
    };

    // unsupported, NON-API function
    // TODO: Note - no "fixedOnly = true" sites remain in the framework
    fluid.parsePriorityConstraint = function (constraint, fixedOnly, site) {
        const segs = constraint.split(":");
        const type = segs[0];
        const lookup = fluid.priorityTypes[type];
        if (lookup === undefined) {
            fluid.fail("Invalid constraint type in priority field " + constraint + ": the only supported values are " + fluid.keys(fluid.priorityTypes).join(", ") + " or numeric");
        }
        if (fixedOnly && lookup === 0) {
            fluid.fail("Constraint type in priority field " + constraint + " is not supported in a " + site + " record - you must use either a numeric value or first, last");
        }
        return {
            type: segs[0],
            target: segs[1]
        };
    };

    // unsupported, NON-API function
    fluid.parsePriority = function (priority, count, fixedOnly, site) {
        priority = priority || 0;
        const togo = {
            count: count || 0,
            fixed: null,
            constraint: null,
            site: site
        };
        if (typeof(priority) === "number") {
            togo.fixed = -priority;
        } else {
            togo.constraint = fluid.parsePriorityConstraint(priority, fixedOnly, site);
        }
        const multiplier = togo.constraint ? fluid.priorityTypes[togo.constraint.type] : 0;
        if (multiplier !== 0) {
            const target = togo.constraint.target || "none";
            const extremal = fluid.extremalPriorities[target];
            if (extremal === undefined) {
                fluid.fail("Unrecognised extremal priority target " + target + ": the currently supported values are " + fluid.keys(fluid.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities");
            }
            togo.fixed = multiplier * (fluid.extremePriority + extremal);
        }
        if (togo.fixed !== null) {
            togo.fixed += togo.count / 1024; // use some fractional bits to encode count bias
        }

        return togo;
    };

    fluid.renderPriority = function (parsed) {
        return parsed.constraint ? (parsed.constraint.target ? parsed.constraint.type + ":" + parsed.constraint.target : parsed.constraint.type) : Math.floor(parsed.fixed);
    };

    // unsupported, NON-API function
    fluid.compareByPriority = function (recA, recB) {
        if (recA.priority.fixed !== null && recB.priority.fixed !== null) {
            return recA.priority.fixed - recB.priority.fixed;
        } else { // sort constraint records to the end
            // relies on JavaScript boolean coercion rules (ECMA 9.3 toNumber)
            return (recA.priority.fixed === null) - (recB.priority.fixed === null);
        }
    };

    fluid.honourConstraint = function (array, firstConstraint, c) {
        const constraint = array[c].priority.constraint;
        const matchIndex = array.findIndex(element => element.namespace === constraint.target);

        if (matchIndex === -1) { // TODO: We should report an error during firing if this condition persists until then
            return true;
        } else if (matchIndex >= firstConstraint) {
            return false;
        } else {
            const offset = constraint.type === "after" ? 1 : 0;
            const target = matchIndex + offset;
            const temp = array[c];
            for (let shift = c; shift >= target; --shift) {
                array[shift] = array[shift - 1];
            }
            array[target] = temp;
            return true;
        }
    };

    // unsupported, NON-API function
    // Priorities accepted from users have higher numbers representing high priority (sort first) -
    // Note weird subtlety that because things arrive dynamically constraints may not see their targets for a while.
    fluid.sortByPriority = function (array) {
        array.sort(fluid.compareByPriority);

        let firstConstraint = array.findIndex(element => element.priority.constraint && fluid.priorityTypes[element.priority.constraint.type] === 0);
        if (firstConstraint === -1) {
            firstConstraint = array.length;
        }

        while (true) {
            if (firstConstraint === array.length) {
                return array;
            }
            const oldFirstConstraint = firstConstraint;
            for (let c = firstConstraint; c < array.length; ++c) {
                const applied = fluid.honourConstraint(array, firstConstraint, c);
                if (applied) {
                    ++firstConstraint;
                }
            }
            if (firstConstraint === oldFirstConstraint) {
                const holders = array.slice(firstConstraint);
                fluid.fail("Could not find targets for any constraints in " + holders[0].priority.site + " ", holders,
                    ": none of the targets (" + holders.map(holder => holder.priority.constraint.target).join(", ") +
                    ") matched any namespaces of the elements in (", array.slice(0, firstConstraint), ") - this is caused by either an invalid or circular reference");
            }
        }
    };

    /**
     * Parse a hash containing prioritised records (for example, as found in a ContextAwareness record) and return a sorted array of these records in priority order.
     *
     * @param {Object} records - A hash of key names to prioritised records. Each record may contain an member `namespace` - if it does not, the namespace will be taken from the
     * record's key. It may also contain a `String` member `priority` encoding a priority with respect to these namespaces as document at http://docs.fluidproject.org/infusion/development/Priorities.html .
     * @param {String} name - A human-readable name describing the supplied records, which will be incorporated into the message of any error encountered when resolving the priorities
     * @return {Array} An array of the same elements supplied to `records`, sorted into priority order. The supplied argument `records` will not be modified.
     */
    fluid.parsePriorityRecords = function (records, name) {
        const array = fluid.hashToArray(records, "namespace", function (newElement, oldElement) {
            $.extend(newElement, oldElement);
            newElement.priority = fluid.parsePriority(oldElement.priority, 0, false, name);
        });
        fluid.sortByPriority(array);
        return array;
    };

    /*** The Fluid Event system. ***/

    fluid.registerNamespace("fluid.event");

    fluid.event.identifyListener = function (listener, soft) {
        if (typeof(listener) !== "string" && !listener.$$fluid_guid && !soft) {
            listener.$$fluid_guid = fluid.allocateGuid();
        }
        return listener.$$fluid_guid;
    };

    fluid.event.impersonateListener = function (origListener, newListener) {
        fluid.event.identifyListener(origListener);
        newListener.$$fluid_guid = origListener.$$fluid_guid;
    };

    fluid.event.sortListeners = function (listeners) {
        let togo = [];
        Object.values(listeners).forEach(oneNamespace => {
            let headHard; // notify only the first listener with hard namespace - or else all if all are soft
            for (let i = 0; i < oneNamespace.length; ++i) {
                const thisListener = oneNamespace[i];
                if (!thisListener.softNamespace && !headHard) {
                    headHard = thisListener;
                }
            }
            if (headHard) {
                togo.push(headHard);
            } else {
                togo = togo.concat(oneNamespace);
            }
        });
        return fluid.sortByPriority(togo);
    };

    fluid.event.resolveListener = function (listener) {
        const listenerName = listener.globalName || (typeof(listener) === "string" ? listener : null);
        if (listenerName) {
            const listenerFunc = fluid.getGlobalValue(listenerName);
            if (!listenerFunc) {
                fluid.fail("Unable to look up name " + listenerName + " as a global function");
            } else {
                listener = listenerFunc;
            }
        }
        return listener;
    };

    /* Generate a name for a component for debugging purposes */
    fluid.nameComponent = function (that) {
        return that ? fluid.dumpComponentAndPath(that) : "[unknown component]";
    };

    fluid.event.nameEvent = function (that, eventName) {
        return eventName + " of " + fluid.nameComponent(that);
    };

    // A function to tag the type of a Fluid event firer (primarily to mark it uncopyable)
    fluid.event.firer = function () {};

    /** Construct an "event firer" object which can be used to register and deregister
     * listeners, to which "events" can be fired. These events consist of an arbitrary
     * function signature. General documentation on the Fluid events system is at
     * http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html .
     *
     * @param {Object} options - A structure to configure this event firer. Supported fields:
     *     {String} name - a readable name for this firer to be used in diagnostics and debugging
     *     {Boolean} preventable - If <code>true</code> the return value of each handler will
     * be checked for <code>false</code> in which case further listeners will be shortcircuited, and this
     * will be the return value of fire()
     *     {Boolean} promise - If `true`, the event firer will receive a "thenable" signature allowing
     * it to function as a promise. In this case the event should be fired with only one argument, and
     * not more than once.
     * @return {Object} - The newly-created event firer.
     */
    fluid.makeEventFirer = function (options) {
        options = options || {};
        const name = options.name || "<anonymous>";
        let that;

        const lazyInit = function () { // Lazy init function to economise on object references for events which are never listened to
            // The authoritative list of all listeners, a hash indexed by namespace, looking up to a stack (array) of
            // listener records in "burial order"
            that.listeners = {};
            // An index of all listeners by "id" - we should consider removing this since it is only used during removal
            // and because that.listeners is a hash of stacks we can't really accelerate removal by much
            that.byId = {};
            // The "live" list of listeners which will be notified in order on any firing. Recomputed on any use of
            // addListener/removeListener
            that.sortedListeners = [];
            // Very low-level destruction notification scheme primarily intended for FLUID-6445. Will be an array of nullary functions
            that.onDestroy = null;
            // arguments after 3rd are not part of public API
            // listener as Object is used only by ChangeApplier to tunnel path, segs, etc as part of its "spec"
            /** Adds a listener to this event.
             * @param {Function|String} listener - The listener function to be added, or a global name resolving to a function. The signature of the function is arbitrary and matches that sent to event.fire()
             * @param {String} [namespace] - (Optional) A namespace for this listener. At most one listener with a particular namespace can be active on an event at one time. Removing successively added listeners with a particular
             * namespace will expose previously added ones in a stack idiom
             * @param {String|Number} [priority] - A priority for the listener relative to others, perhaps expressed with a constraint relative to the namespace of another - see
             * http://docs.fluidproject.org/infusion/development/Priorities.html
             * @param {String} [softNamespace] - An unsupported internal option that is not part of the public API.
             * @param {String} [listenerId] - An unsupported internal option that is not part of the public API.
             */
            that.addListener = function (listener, namespace, priority, softNamespace, listenerId) {
                let record;
                if (that.destroyed) {
                    fluid.fail("Cannot add listener to destroyed event firer " + that.name);
                }
                if (!listener) {
                    return;
                }
                if (fluid.isPlainObject(listener, true) && !fluid.isApplicable(listener)) {
                    record = listener;
                    listener = record.listener;
                    namespace = record.namespace;
                    priority = record.priority;
                    softNamespace = record.softNamespace;
                    listenerId = record.listenerId;
                }
                if (typeof(listener) === "string") {
                    listener = {globalName: listener};
                }
                const id = listenerId || fluid.event.identifyListener(listener);
                namespace = namespace || id;
                record = Object.assign(record || {}, {
                    namespace: namespace,
                    listener: listener,
                    softNamespace: softNamespace,
                    listenerId: listenerId,
                    priority: fluid.parsePriority(priority, that.sortedListeners.length, false, "listeners")
                });
                that.byId[id] = record;

                const thisListeners = (that.listeners[namespace] = fluid.makeArray(that.listeners[namespace]));
                thisListeners[softNamespace ? "push" : "unshift"](record);

                that.sortedListeners = fluid.event.sortListeners(that.listeners);
            };
            that.addListener.apply(null, arguments);
        };
        that = Object.create(fluid.event.firer.prototype);
        Object.assign(that, {
            eventId: fluid.allocateGuid(),
            name: name,
            ownerId: options.ownerId,
            typeName: "fluid.event.firer",
            destroy: function () {
                that.destroyed = true;
                fluid.each(that.onDestroy, function (func) {
                    func();
                });
            },
            addListener: function () {
                lazyInit.apply(null, arguments);
            },
            /**
             * Removes a listener previously registered with this event.
             *
             * @param {Function|String} listener - Either the listener function, the namespace of a listener
             * (in which case a previous listener with that namespace may be uncovered) or an id sent to the
             * undocumented `listenerId` argument of `addListener
             */
            // Can be supplied either listener, namespace, or id (which may match either listener function's guid or original listenerId argument)
            removeListener: function (listener) {
                if (!that.listeners) {
                    return;
                }
                let namespace, id, record;
                if (typeof(listener) === "string") {
                    namespace = listener;
                    record = that.listeners[namespace];
                    if (!record) { // it was an id and not a namespace - take the namespace from its record later
                        id = namespace;
                        namespace = null;
                    }
                } else if (typeof(listener) === "function") {
                    id = fluid.event.identifyListener(listener, true);
                    if (!id) {
                        fluid.fail("Cannot remove unregistered listener function ", listener, " from event " + that.name);
                    }
                }
                const rec = that.byId[id];
                const softNamespace = rec && rec.softNamespace;
                namespace = namespace || (rec && rec.namespace) || id;
                delete that.byId[id];
                record = that.listeners[namespace];
                if (record) {
                    if (softNamespace) {
                        fluid.remove_if(record, function (thisLis) {
                            return thisLis.listener.$$fluid_guid === id || thisLis.listenerId === id;
                        });
                    } else {
                        record.shift();
                    }
                    if (record.length === 0) {
                        delete that.listeners[namespace];
                    }
                }
                that.sortedListeners = fluid.event.sortListeners(that.listeners);
            },
            /* Fires this event to all listeners which are active. They will be notified in order of priority. The signature of this method is free. */
            fire: function () {
                const listeners = that.sortedListeners;
                if (options.promise) {
                    that.promisePayload = arguments[0];
                }
                if (!listeners || that.destroyed) {
                    return;
                }
                for (let i = 0; i < listeners.length; ++i) {
                    const lisrec = listeners[i];
                    if (typeof(lisrec.listener) !== "function") {
                        lisrec.listener = fluid.event.resolveListener(lisrec.listener);
                    }
                    const listener = lisrec.listener;
                    const ret = listener.apply(null, arguments);
                    let value;
                    if (options.preventable && ret === false || that.destroyed) {
                        value = false;
                    }
                    if (value !== undefined) {
                        return value;
                    }
                }
            }
        });
        if (options.promise) {
            that.then = function (func) {
                if ("promisePayload" in that) {
                    func(that.promisePayload);
                } else {
                    that.addListener(func);
                }
            };
        }
        return that;
    };

    // Fires to an event which may not be instantiated (in which case no-op) - primary modern usage is to resolve FLUID-5904
    fluid.fireEvent = function (component, eventName, args) {
        const firer = component.events && component.events[eventName];
        if (firer) {
            firer.fire.apply(null, fluid.makeArray(args));
        }
    };

    // unsupported, NON-API function
    fluid.event.addListenerToFirer = function (firer, value, namespace, wrapper) {
        wrapper = wrapper || (x => x);
        if (fluid.isArrayable(value)) {
            for (let i = 0; i < value.length; ++i) {
                fluid.event.addListenerToFirer(firer, value[i], namespace, wrapper);
            }
        } else if (typeof(value) === "function" || typeof(value) === "string") {
            wrapper(firer).addListener(value, namespace);
        } else if (value && typeof(value) === "object") {
            wrapper(firer).addListener(value.listener, namespace || value.namespace, value.priority, value.softNamespace, value.listenerId);
        }
    };

    // unsupported, NON-API function - non-IOC passthrough
    fluid.event.resolveListenerRecord = function (records) {
        return {records: records};
    };

    fluid.expandImmediate = function (material) {
        fluid.fail("fluid.expandImmediate could not be loaded - please include FluidIL.js in order to operate IL event with descriptor " + material);
    };

    fluid.mergeListeners = function (that, events, listeners) {
        fluid.each(listeners, function (value, key) {
            let firer, namespace;
            if (fluid.isILReference(key)) {
                firer = fluid.expandImmediate(key, that);
                if (!firer) {
                    fluid.fail("Error in listener record: key " + key + " could not be looked up to an event firer - did you miss out \"events.\" when referring to an event firer?");
                }
            } else {
                const keydot = key.indexOf(".");

                if (keydot !== -1) {
                    namespace = key.substring(keydot + 1);
                    key = key.substring(0, keydot);
                }
                if (!events[key]) {
                    fluid.fail("Listener registered for event " + key + " which is not defined for this component");
                }
                firer = events[key];
            }
            const record = fluid.event.resolveListenerRecord(value, that, key, namespace, true);
            fluid.event.addListenerToFirer(firer, record.records, namespace, record.adderWrapper);
        });
    };

    fluid.eventFromRecord = function (eventSpec, eventKey, that) {
        const isILEvent = eventSpec && (typeof(eventSpec) !== "string" || fluid.isILReference(eventSpec));
        let event;
        if (isILEvent) {
            if (!fluid.event.resolveEvent) {
                fluid.fail("fluid.event.resolveEvent could not be loaded - please include FluidIL.js in order to operate IL driven event with descriptor ",
                    eventSpec);
            } else {
                event = fluid.event.resolveEvent(that, eventKey, eventSpec);
            }
        } else {
            event = fluid.makeEventFirer({
                name: fluid.event.nameEvent(that, eventKey),
                preventable: eventSpec === "preventable",
                promise: eventSpec === "promise",
                ownerId: that.id
            });
        }
        return event;
    };

    fluid.mergeListenerPolicy = function (target, source, key) {
        if (typeof(key) !== "string") {
            fluid.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + key + " from ", source);
        }
        // cf. triage in mergeListeners
        const hasNamespace = !fluid.isILReference(key) && key.indexOf(".") !== -1;
        return hasNamespace ? (source || target) : fluid.arrayConcatPolicy(target, source);
    };

    fluid.makeMergeListenersPolicy = function (merger, modelRelay) {
        return function (target, source) {
            target = target || {};
            if (modelRelay && (fluid.isArrayable(source) || "target" in source && (typeof(source.target) === "string" || source.target.segs))) { // This form allowed for modelRelay
                target[""] = merger(target[""], source, "");
            } else {
                fluid.each(source, function (listeners, key) {
                    target[key] = merger(target[key], listeners, key);
                });
            }
            return target;
        };
    };

    fluid.validateListenersImplemented = function (that) {
        const errors = [];
        fluid.each(that.events, function (event, name) {
            fluid.each(event.sortedListeners, function (lisrec) {
                if (lisrec.listener === fluid.notImplemented || lisrec.listener.globalName === "fluid.notImplemented") {
                    errors.push({
                        name: name,
                        namespace: lisrec.namespace,
                        componentSource: fluid.model.getSimple(that.options.listeners, [name + "." + lisrec.namespace, 0, "componentSource"])
                    });
                }
            });
        });
        return errors;
    };

    fluid.arrayConcatPolicy = function (target, source) {
        return fluid.makeArray(target).concat(fluid.makeArray(source));
    };

    /*** FLUID LOGGING SYSTEM ***/

    // This event represents the process of resolving the action of a request to fluid.log. Each listener shares
    // access to an array, shallow-copied from the original arguments list to fluid.log, which is assumed writeable
    // and which they may splice, transform, etc. before it is dispatched to the listener with namespace "log" which
    // actually performs the logging action
    fluid.loggingEvent = fluid.makeEventFirer({name: "logging event"});

    fluid.addTimestampArg = function (args) {
        const arg0 = fluid.renderTimestamp(new Date()) + ":  ";
        args.unshift(arg0);
    };

    fluid.loggingEvent.addListener(fluid.doBrowserLog, "log");
    // Not intended to be overridden - just a positional placeholder so that the priority of
    // actions filtering the log arguments before dispatching may be referred to it
    fluid.loggingEvent.addListener(x => x, "filterArgs", "before:log");
    fluid.loggingEvent.addListener(fluid.addTimestampArg, "addTimestampArg", "after:filterArgs");

    /*** FLUID ERROR SYSTEM ***/

    /** Upgrades a promise rejection payload (or Error) by suffixing an additional "while" reason into its "message" field
     * @param {Object|Error} originError - A rejection payload. This should (at least) have the member `isError: true` set, as well as a String `message` holding a rejection reason.
     * @param {String} whileMsg - A message describing the activity which led to this error
     * @return {Object} The rejected payload formed by shallow cloning the supplied argument (if it is not an `Error`) and suffixing its `message` member
     */
    fluid.upgradeError = function (originError, whileMsg) {
        const error = originError instanceof Error ? originError :
            fluid.isPrimitive(originError) ? {message: originError} : fluid.extend({}, originError);
        error.message = error.message + whileMsg;
        return error;
    };

    fluid.failureEvent = fluid.makeEventFirer({name: "failure event"});

    fluid.failureEvent.addListener(fluid.builtinFail, "fail");
    fluid.failureEvent.addListener(fluid.logFailure, "log", "before:fail");

    // Algorithm taken from Python 2.3's implementation from manual: https://www.python.org/download/releases/2.3/mro/#the-end
    // Deals with FLUID-5800
    // eslint-disable-next-line jsdoc/require-returns-check -- return is at head of loop body
    /**
     * Merges multiple sequences of layer names into a single sequence using the C3 linearization method.
     * @param {String[][]} seqs - An array of sequences to be merged. **NOTE** The nested sequences will be modified by
     * this function.
     * @return {String[]} - The merged sequence.
     * @throws {Error} - Throws an error if the hierarchy is inconsistent.
     */
    fluid.C3_merge = function (seqs) {
        fluid.log(`\n\nCPL[${seqs[0][0]}]=${JSON.stringify(seqs)}`);
        let res = [];
        let i = 0;

        while (true) {
            let nonemptyseqs = seqs.filter(seq => seq.length > 0);
            if (nonemptyseqs.length === 0) {
                return res;
            }

            i++;
            fluid.log(`\n${i} round: candidates...`);

            let cand = null;
            for (let seq of nonemptyseqs) {
                cand = seq[0];
                fluid.log(` ${cand}`);
                // eslint-disable-next-line no-loop-func
                let nothead = nonemptyseqs.filter(s => s.indexOf(cand) > 0);
                if (nothead.length > 0) {
                    cand = null; // reject candidate
                } else {
                    break;
                }
            }

            if (!cand) {
                fluid.fail(`Inconsistent hierarchy for layer ${res[0]}: conflict between parent orders ${nonemptyseqs.map(ns => ns.toString()).join(", ")}`);
            }

            res.push(cand);
            for (let seq of nonemptyseqs) {
                if (seq[0] === cand) {
                    seq.shift(); // remove cand
                }
            }
        }
    };

    /**
     * Computes C3 precedence of the parent layers of the supplied layer
     * @param {String} C - The name of the layer whose parent precedence is required
     * @param {Object<String, Object>} defs - A layer definition registry
     * @param {Set<String>} [visited=new Set()] - A set to keep track of visited classes to detect circular hierarchy.
     * @return {String[]} - The parent precedence list
     * @throws {Error} - Throws an error if the hierarchy is inconsistent, circular, or a layer is missing
     */
    fluid.C3_precedence = function (C, defs, visited = new Set()) {
        if (visited.has(C)) {
            fluid.fail(`Circular hierarchy detected - layer ${C} has already been visited`);
        }

        visited.add(C);
        const def = defs[C];
        if (!def) {
            // This error should not be received since the driver in fluid.hierarchyResolver will ensure that all parents have definitions
            fluid.fail(`Parent layer ${C} referenced which is not defined`);
        }
        const parents = Array.from(defs[C].$layers);
        const precLists = parents.map(parent => fluid.C3_precedence(parent, defs, visited));
        const merged = fluid.C3_merge([[C]].concat(precLists).concat([parents]));

        visited.delete(C);
        return merged;
    };


    /*** DEFAULTS AND OPTIONS MERGING SYSTEM ***/

    fluid.proxySymbol = Symbol("fluid.proxyTarget");
    const $t = fluid.proxySymbol;

    fluid.unProxy = target => target?.[$t] ? target[$t] : target;

    // A special symbol used to store nested metadata at any level of the mat - see diagram for use via "$m"
    fluid.metadataSymbol = Symbol("fluid.metadata");
    const $m = fluid.metadataSymbol;

    // Lookup of layer names to signal<{raw: layer}>
    // where "raw" has not yet been readerExpanded
    fluid.layerStore = {};

    /**
     * Retrieve a layer by its name from the layer store.
     * If the layer does not exist, returns an "unavailable" marker with an appropriate message and path.
     *
     * @param {String} layerName - The name of the layer to retrieve.
     * @return {signal<RawLayer>} The layer signal if it exists, or an "unavailable" marker if the layer is not defined.
     */
    fluid.readLayer = function (layerName) {
        const layerSig = fluid.layerStore[layerName];
        if (layerSig) {
            return layerSig;
        } else {
            // TODO: These unavailable signals perhaps could be stored in a WeakMap so they could be GCed if no pending instances
            // are relying on them
            return fluid.layerStore[layerName] = signal(fluid.unavailable({
                message: "Layer " + layerName + " is not defined",
                path: ["layer", layerName]
            }));
        }
    };

    /**
     * Write or update a layer in the layer store.
     * If the layer already exists, updates its value. If it does not exist, creates a new signal for it.
     *
     * @param {String} layerName - The name of the layer to write or update.
     * @param {Object} layer - The layer data to store.
     */
    fluid.writeLayer = function (layerName, layer) {
        const layerSig = fluid.layerStore[layerName];
        if (layerSig) {
            layerSig.value = {raw: layer};
        } else {
            fluid.layerStore[layerName] = signal({
                raw: layer
            });
        }
    };

    fluid.deleteLayer = function (layerName) {
        delete fluid.layerStore[layerName];
    };

    // Like a "reader macro" - currently just ensures that "$layers" is an array
    // Do we actually need this in this role?
    fluid.readerExpandLayer = function (layer) {
        // TODO: Create links between old and new data so that we can route errors back
        return {...layer, $layers: fluid.makeArray(layer.$layers)};
    };

    // The types of merge record the system supports, with the weakest records first
    fluid.mergeRecordTypes = {
        def: 1000, // and above
        defParents: 900,
        subcomponent: 700, // and above - wrt. nesting depth
        user: 600, // supplied as constructor arguments
        distribution: 100, // and above
        live: 0
    };

    /**
     * Recursively merge multiple layers into a target object, resolving conflicts and maintaining a mapping of values to their originating layers.
     *
     * @param {Object} target - The target object where merged results will be stored.
     * @param {String[]} segs - The current path segments being traversed during the merge.
     * @param {Object} layerMap - A map of paths to the names of the layers contributing values at those paths.
     * @param {Object[]} layers - An array of layer objects to be merged.
     * @param {MergeRecord[]} mergeRecords - An array of `MergeRecord` objects providing metadata for the layers.
     */
    fluid.mergeLayers = function (target, segs, layerMap, layers, mergeRecords) {
        const clayers = layers.length;

        const allKeysRec = {};
        layers.forEach(layer => {
            if (fluid.isPlainObject(layer, true)) {
                Object.keys(layer).forEach(key => allKeysRec[key] = true);
            }
        });
        const allKeys = Object.keys(allKeysRec);

        allKeys.forEach(key => {
            let count = 0;
            let last, newTarget;
            let lastIndex = -1;
            for (let i = 0; i < clayers; ++i) {
                const value = layers?.[i]?.[key];
                if (value !== undefined) {
                    ++count;
                    last = value;
                    lastIndex = i;
                }
            }
            if (count > 1 && fluid.isPlainObject(last, true)) {
                newTarget = {};
                const newLayers = layers.map(layer => layer?.[key]);
                segs.push(key);
                fluid.mergeLayers(newTarget, segs, layerMap, newLayers, mergeRecords);
                segs.pop();
            } else {
                newTarget = last;
            }
            target[key] = newTarget;
            fluid.set(layerMap, [...segs, key, $m], mergeRecords[lastIndex].layerName);
        });
    };

    /**
     * Merge a set of layer records into a root object, producing a merged result and a mapping of values to their originating layers.
     *
     * @param {Object} root - The root object to which layers will be merged.
     * @param {MergeRecord[]} mergeRecords - An array of `MergeRecord` objects describing the layers to be merged.
     * @return {Object} An object containing:
     *   - `root` (Object): The merged root object.
     *   - `layerMap` (Object): A mapping of paths to the names of the layers contributing values at those paths.
     */
    fluid.mergeLayerRecords = function (root, mergeRecords) {
        const layerMap = {}, segs = [];
        const layers = mergeRecords.map(mergeRecord => mergeRecord.layer);

        fluid.mergeLayers(root, segs, layerMap, layers, mergeRecords);

        return {root, layerMap};
    };

    /**
     * @typedef {Object} MergeRecord
     * @property {String} layerType - The type of the layer (e.g., "def", "defParents").
     * @property {String} layerName - Name of the layer, expected to be unique
     * @property {Number} priority - The priority of the layer, used for determining merge order.
     * @property {Object} layer - The layer definition object to be merged.
     */

    // Consumes rawLayer values as signals by issuing reads to fluid.readLayer
    // produces mergeRecords and merged as plain outputs
    fluid.hierarchyResolver = function (flatDefsIn = {}) {
        const flatDefs = Object.assign({}, flatDefsIn);
        const readerExpand = layer => fluid.readerExpandLayer(layer);
        const that = {
            // A local store, so that we can use C3_precedence with direct lookups
            flatDefs,
            storeParents: layer => {
                return layer.$layers.map(layerName => that.storeLayer(layerName));
            },
            storeLayer: (layerName) => {
                let layerComputer = flatDefs[layerName];
                if (!layerComputer) {
                    // Guard the cache for recursive encounters to same layer along different routes by writing in a value first
                    flatDefs[layerName] = "in progress";
                    flatDefs[layerName] = layerComputer = computed(() => {
                        const layer = fluid.readLayer(layerName).value;
                        if (fluid.isUnavailable(layer)) {
                            return layer;
                        } else {
                            const readerExpanded = readerExpand(layer.raw);
                            const parentComputers = that.storeParents(readerExpanded);
                            // Ensure layer computers for all parent layers get evaluated right now
                            parentComputers.map(computer => computer.value);
                            return readerExpanded;
                        }
                    });
                }
                return layerComputer;
            },
            // Given a layerName, resolves a signal of {mergeRecords, merged} structure or unavailable if parents are not defined
            resolve: (layerName) => {
                const resolveLayers = function () {
                    // First prime the cache by evalauting all signals at tip
                    fluid.each(flatDefs, def => def.value);
                    // Second check if any layers are unavailable
                    const {unavailable} = fluid.processSignalArgs(Object.values(flatDefs));
                    if (unavailable) {
                        return unavailable;
                    } else {
                        // Finally flatten cache into pure values ready for resolution
                        const veryFlatDefs = fluid.transform(flatDefs, def => def.value);
                        const order = fluid.C3_precedence(layerName, veryFlatDefs).reverse();
                        const mergeRecords = order.map((oneLayerName, i) => ({
                            layerType: "def",
                            layerName: oneLayerName,
                            priority: fluid.mergeRecordTypes.def + i,
                            layer: veryFlatDefs[oneLayerName]
                        })).concat({
                            layerType: "defParents",
                            layerName: `defParents:${layerName}`,
                            priority: fluid.mergeRecordTypes.defParents,
                            layer: {$layers: order}
                        });
                        return {
                            // Note merged is currently only read by fluid.readDef
                            mergeRecords, merged: fluid.mergeLayerRecords({}, mergeRecords)
                        };
                    }
                };
                return computed(() => resolveLayers());
            }
        };
        return that;
    };

    /**
     * Checks whether a given layer contains a specified layer name in its `$layers` property.
     *
     * @param {Object} layer - The layer object to check. It should contain a `$layers` property, which is an array of layer names.
     * @param {String} layerName - The name of the layer to check for.
     * @return {Boolean} `true` if the layer contains the specified layer name, otherwise `false`.
     */
    fluid.hasLayer = function (layer, layerName) {
        return layer.$layers && layer.$layers.includes(layerName);
    };

    /**
     * Retrieves a layer's merged configuration
     * @param {String} layerName - The name of the grade whose options are to be read or written
     * @return {signal<resolve>} - Signal for layers (which is mergeRecords and merged)
     */
    fluid.readMergedDef = function (layerName) {
        // TODO: economise on these in the "giant mat"
        const resolver = fluid.hierarchyResolver();
        resolver.storeLayer(layerName);
        return resolver.resolve(layerName);
    };

    // Must be defined before we construct any components
    fluid.makeComponentCreator = function (componentName) {
        const creator = function () {
            return fluid.initFreeComponent(componentName, arguments);
        };
        // Allow use of creator functions as namespaces - assign any existing members onto the freshly created function
        const existing = fluid.getGlobalValue(componentName);
        if (existing) {
            Object.assign(creator, existing);
        }
        fluid.setGlobalValue(componentName, creator);
    };

    fluid.writeDef = function (layerName, layer) {
        fluid.writeLayer(layerName, layer);
        fluid.makeComponentCreator(layerName);
    };

    /**
     * Retrieves and stores a layer's configuration centrally.
     *
     * @param {String} layerName - The name of the grade whose options are to be read or written
     * @param {Object} [layer] - An (optional) object containing the options to be set
     * @return {Object|undefined} - If `options` is omitted, returns the merged layer definition for `componentName`. Otherwise,
     * creates an instance of the named component with the supplied options.
     */
    fluid.def = function (layerName, layer) {
        if (layer === undefined) {
            return fluid.getThroughSignals(fluid.readMergedDef(layerName), ["merged", "root"]);
        } else {
            fluid.writeDef(layerName, layer);
        }
    };

    // A special marker object which will be placed at a current evaluation point in the tree in order
    // to protect against circular evaluation
    fluid.inEvaluationMarker = Object.freeze({"__CURRENTLY_IN_EVALUATION__": true});

    // The Fluid Component System proper

    // The base system grade definitions

    fluid.def("fluid.function", {});

    /**
     * Invoke a global function by name and named arguments. A courtesy to allow declaratively encoded function calls
     * to use named arguments rather than bare arrays.
     *
     * @param {String} name - A global name which can be resolved to a Function. The defaults for this name must
     * resolve onto a grade including "fluid.function". The defaults record should also contain an entry
     * <code>argumentMap</code>, a hash of argument names onto indexes.
     * @param {Object} [spec] - A named hash holding the argument values to be sent to the function. These will be looked
     * up in the <code>argumentMap</code> and resolved into a flat list of arguments.
     * @return {any} The return value from the function
     */
    fluid.invokeGradedFunction = function (name, spec) {
        const defaults = fluid.def(name).value;
        if (!defaults || !defaults.argumentMap || !fluid.hasGrade(defaults, "fluid.function")) {
            fluid.fail("Cannot look up name " + name +
                " to a function with registered argumentMap - got defaults ", defaults);
        }
        const args = [];
        fluid.each(defaults.argumentMap, function (value, key) {
            args[value] = spec[key];
        });
        return fluid.invokeGlobalFunction(name, args);
    };

    // ******* SELECTOR ENGINE *********

    // selector regexps copied from jQuery - recent versions correct the range to start C0
    // The initial portion of the main character selector: "just add water" to add on extra
    // accepted characters, as well as the "\\\\." -> "\." portion necessary for matching
    // period characters escaped in selectors
    const charStart = "(?:[\\w\\u00c0-\\uFFFF*_-";

    fluid.simpleCSSMatcher = {
        regexp: new RegExp("([#.]?)(" + charStart + "]|\\\\.)+)", "g"),
        charToTag: {
            "": "tag",
            "#": "id",
            ".": "clazz"
        }
    };

    fluid.ILSSMatcher = {
        regexp: new RegExp("([&#]?)(" + charStart + "]|\\.|\\/)+)", "g"),
        charToTag: {
            "": "context",
            "&": "context",
            "#": "id"
        }
    };

    const childSeg = new RegExp("\\s*(>)?\\s*", "g");
    // var whiteSpace = new RegExp("^\\w*$");

    // Parses a selector expression into a data structure holding a list of predicates
    // 2nd argument is a "strategy" structure, e.g.  fluid.simpleCSSMatcher or fluid.IoCSSMatcher
    // unsupported, non-API function
    fluid.parseSelector = function (selstring, strategy) {
        const togo = [];
        selstring = selstring.trim();
        //ws-(ss*)[ws/>]
        const regexp = strategy.regexp;
        regexp.lastIndex = 0;
        let lastIndex = 0;
        while (true) {
            const atNode = []; // a list of predicates at a particular node
            let first = true;
            while (true) {
                const segMatch = regexp.exec(selstring);
                if (!segMatch) {
                    break;
                }
                if (segMatch.index !== lastIndex) {
                    if (first) {
                        fluid.fail("Error in selector string - cannot match child selector expression starting at " + selstring.substring(lastIndex));
                    } else {
                        break;
                    }
                }
                const thisNode = {};
                const text = segMatch[2];
                const targetTag = strategy.charToTag[segMatch[1]];
                if (targetTag) {
                    thisNode[targetTag] = text;
                }
                atNode[atNode.length] = thisNode;
                lastIndex = regexp.lastIndex;
                first = false;
            }
            childSeg.lastIndex = lastIndex;
            const fullAtNode = {predList: atNode};
            const childMatch = childSeg.exec(selstring);
            if (!childMatch || childMatch.index !== lastIndex) {
                fluid.fail("Error in selector string - can not match child selector expression at " + selstring.substring(lastIndex));
            }
            if (childMatch[1] === ">") {
                fullAtNode.child = true;
            }
            togo[togo.length] = fullAtNode;
            // >= test here to compensate for IE bug http://blog.stevenlevithan.com/archives/exec-bugs
            if (childSeg.lastIndex >= selstring.length) {
                break;
            }
            lastIndex = childSeg.lastIndex;
            regexp.lastIndex = childSeg.lastIndex;
        }
        return togo;
    };

    // Message resolution and templating

    /**
     *
     * Simple string template system.  Takes a template string containing tokens in the form of "%value" or
     * "%deep.path.to.value".  Returns a new string with the tokens replaced by the specified values.  Keys and values
     * can be of any data type that can be coerced into a string.
     *
     * @param {String} template - A string that contains placeholders for tokens of the form `%token` embedded into it.
     * @param {Object.<String.String>} values - A map of token names to the values which should be interpolated.
     * @return {String} The text of `template` whose tokens have been interpolated with values.
     */
    fluid.stringTemplate = function (template, values) {
        let keys = Object.keys(values);
        keys = keys.sort((keya, keyb) => keyb.length - keya.length);
        for (let i = 0; i < keys.length; ++i) {
            const key = keys[i];
            const templatePlaceholder = "%" + key;
            const replacementValue = values[key];

            let indexOfPlaceHolder = -1;
            while ((indexOfPlaceHolder = template.indexOf(templatePlaceholder)) !== -1) {
                template = template.slice(0, indexOfPlaceHolder) + replacementValue + template.slice(indexOfPlaceHolder + templatePlaceholder.length);
            }
        }
        return template;
    };
};

// noinspection ES6ConvertVarToLetConst // otherwise this is a duplicate on minifying
var fluid = fluid || {}; // eslint-disable-line no-redeclare
fluidJSScope(fluid);

// noinspection ES6ConvertVarToLetConst -- Hint for future module munger
var exports = {fluidJSScope}; // eslint-disable-line no-unused-vars
