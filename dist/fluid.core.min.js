"use strict";const $fluidCoreJSScope=function(fluid){fluid.version="Infusion 6.0.0";fluid.Error=Error;fluid.global=fluid.global||typeof window!=="undefined"?window:typeof self!=="undefined"?self:{};fluid.isPrimitive=function(value){const valueType=typeof value;return!value||valueType==="string"||valueType==="boolean"||valueType==="number"||valueType==="function"};fluid.makeArray=function(arg){return arg===null||arg===undefined?[]:fluid.isPrimitive(arg)||typeof arg[Symbol.iterator]!=="function"?[arg]:[...arg]};fluid.isArrayable=function(totest){return Boolean(totest)&&Object.prototype.toString.call(totest)==="[object Array]"};fluid.unavailablePriority={"I/O":1,config:2,error:3};fluid.upgradeCause=function(cause,defaultVariety){const upCause=typeof cause==="string"?{message:cause}:cause;if(!upCause.variety){upCause.variety=defaultVariety}return upCause};fluid.formatCauses=function(causes){return"Value is unavailable: causes are "+causes.map((cause=>cause.message)).join("\n")};fluid.unavailable=function(cause={},variety="error"){const togo=Object.create(fluid.unavailable.prototype);if(fluid.isArrayable(cause)){togo.causes=fluid.makeArray(cause).map((oneCause=>fluid.upgradeCause(oneCause,variety)));togo.variety=togo.causes.reduce(((acc,{variety:variety})=>{const priority=fluid.unavailablePriority[variety];return priority>acc.priority?{variety:variety,priority:priority}:acc}),{priority:-1}).variety;togo.message=fluid.formatCauses(togo.causes)}else{const upCause=fluid.upgradeCause(cause,variety);Object.assign(togo,upCause)}return togo};fluid.pending=function(staleValue,site){const togo=Object.create(fluid.unavailable.prototype);togo.variety="I/O";togo.message="Value is unavailable due to pending I/O";togo.site=site;togo.staleValue=staleValue;return togo};fluid.isUnavailable=totest=>totest instanceof fluid.unavailable;fluid.isErrorUnavailable=totest=>fluid.isUnavailable(totest)&&totest.variety==="error";fluid.deproxyUnavailable=target=>target;fluid.unavailableToCauses=function(unavailable){const unwrapped=fluid.deproxyUnavailable(unavailable);return unwrapped.causes?unwrapped.causes:[unwrapped]};fluid.mergeUnavailable=function(existing,fresh){return!existing?fresh:fluid.unavailable(fluid.unavailableToCauses(existing).concat(fluid.unavailableToCauses(fresh)))};fluid.missingPolicies={unavailable:(root,path)=>fluid.unavailable({message:`Path ${path} was not found`,site:root}),error:(root,path)=>fluid.fail("Path ",path," was not found in model ",root)};fluid.getPathSegmentImpl=function(accept,path,i){let segment="";let escaped=false;const limit=path.length;for(;i<limit;++i){const c=path.charAt(i);if(!escaped){if(c==="."){break}else if(c==="\\"){escaped=true}else{segment+=c}}else{escaped=false;segment+=c}}accept[0]=segment;return i};fluid.parsePath=function(path){const togo=[],accept=[null];let index=0;const limit=path.length;while(index<limit){const firstdot=fluid.getPathSegmentImpl(accept,path,index);togo.push(accept[0]);index=firstdot+1}return togo};fluid.pathToSegs=function(path){return fluid.isPrimitive(path)?fluid.parsePath(path):path};fluid.get=function(root,path,missingPolicy){const segs=fluid.pathToSegs(path);const limit=segs.length;for(let j=0;j<limit;++j){root=root?root[segs[j]]:undefined}if(root===undefined&&missingPolicy){return fluid.missingPolicies[missingPolicy](root,path)}else{return root}};fluid.set=function(root,path,newValue){const segs=fluid.pathToSegs(path);for(let i=0;i<segs.length-1;++i){const seg=segs[i];if(!root[seg]){root[seg]=Object.create(null)}root=root[seg]}root[segs[segs.length-1]]=newValue};fluid.getGlobalValue=path=>{const value=fluid.get(fluid.global,path);return value===undefined?fluid.unavailable({message:"Global value "+path+" is not defined",path:path}):value};fluid.setGlobalValue=(path,value)=>{fluid.set(fluid.global,path,value)};fluid.registerNamespace=function(path){let existing=fluid.getGlobalValue(path);if(fluid.isUnavailable(existing)){existing=Object.create(null);fluid.setGlobalValue(path,existing)}return existing}};if(typeof fluid==="undefined"&&typeof window!=="undefined"){window.fluid={}}if(typeof fluid!=="undefined"){$fluidCoreJSScope(fluid)}"use strict";const $fluidSignalsScope=function(fluid){fluid.CurrentReaction=null;fluid.CurrentGets=null;fluid.CurrentGetsIndex=0;fluid.EffectQueue=[];fluid.CacheClean=0;fluid.CacheCheck=1;fluid.CacheDirty=2;const CacheClean=fluid.CacheClean,CacheCheck=fluid.CacheCheck,CacheDirty=fluid.CacheDirty;fluid.defaultEquality=function(a,b){if(typeof a!=="number"||typeof b!=="number"){return a===b}else{if(a===b||a!==a&&b!==b){return true}else{const relError=Math.abs((a-b)/b);return relError<1e-12}}};fluid.isPromise=function(totest){return totest&&typeof totest.then==="function"};fluid.CurrentFit={targetsConsumed:[]};fluid.endFit=function(){fluid.CurrentFit.targetsConsumed.forEach((target=>target._consumedSources=null));fluid.CurrentFit.targetsConsumed.length=0};fluid.findCause=function(inTarget){const currentEdge=fluid.CurrentReaction;const useTarget=inTarget||currentEdge?.target;if(useTarget){const cause=[];let target=useTarget;do{cause.push(target);target=target._dirtyFrom}while(target);return cause}else{return null}};fluid.consumeSources=function(target,inSources){const sources=target._consumedSources||[];Array.prototype.push.apply(sources,inSources);target._consumedSources=sources;fluid.CurrentFit.targetsConsumed.push(target)};fluid.removeAtIndex=function(array,index){array[index]=array[array.length-1];array.pop()};fluid.cell=function(initialValue,props){const cell=Object.create(fluid.cellPrototype);Object.assign(cell,props);cell._value=initialValue===undefined?fluid.cell.initialUnavailable:initialValue;cell._dirtyFrom=null;cell._observers=null;cell._inEdges=null;cell._consumedSources=null;cell._consumedEdge=null;cell._error=null;cell._state=CacheClean;cell._updateRecord=null;return cell};fluid.cell.initialUnavailable=Object.freeze(fluid.unavailable({staleValue:undefined},"config"));fluid.cellPrototype=fluid.cell.prototype;fluid.cell.equals=fluid.defaultEquality;fluid.cell.prototype.get=function(){if(fluid.CurrentReaction){if(!fluid.CurrentGets&&fluid.CurrentReaction.sources&&fluid.CurrentReaction.sources[fluid.CurrentGetsIndex]===this){fluid.CurrentGetsIndex++}else{if(!fluid.CurrentGets){fluid.CurrentGets=[this]}else{fluid.CurrentGets.push(this)}}}if(this._inEdges){fluid.cell.updateIfNecessary(this)}return this._value};fluid.cell.prototype.set=function(value){if(!fluid.cell.equals(this._value,value)){this._value=value;if(this._observers){const markedSources=[this];for(let i=0;i<this._observers.length;i++){const observer=this._observers[i];fluid.cell.markStale(observer,CacheDirty,markedSources,this)}}if(!fluid.isUnavailable(value)){fluid.cell.stabilize()}}};fluid.cell.prototype.computed=function(fn,staticSources,props){const key=staticSources&&staticSources[0]||null;if(!this._inEdges){this._inEdges=[]}const inEdgeIndex=this._inEdges.findIndex((edge=>edge.key===key));let inEdge=inEdgeIndex===-1?null:this._inEdges[inEdgeIndex];if(!fn){if(inEdge){fluid.cell.removeParentObservers(this,inEdge,0);fluid.removeAtIndex(this._inEdges,inEdgeIndex)}return this}else{const oldFn=inEdge?._fn;if(!inEdge){inEdge=Object.create(null);inEdge.key=key}inEdge.fn=fn;inEdge.staticSources=staticSources?[...staticSources]:null;inEdge.sources=staticSources?[...staticSources]:null;inEdge.target=this;inEdge.isAsync=props?.isAsync;inEdge.isFree=props?.isFree;this._inEdges.push(inEdge);if(staticSources){for(let i=0;i<staticSources.length;i++){const source=staticSources[i];if(!source._observers){source._observers=[this]}else{source._observers.push(this)}}}if(oldFn&&fn!==oldFn||fluid.isUnavailable(this._value)){fluid.cell.markStale(this,CacheDirty,[])}fluid.cell.stabilize();return this}};fluid.cell.prototype.asyncComputed=function(fn,staticSources,props){return this.computed(fn,staticSources,{...props,isAsync:true})};fluid.cell.prototype.refresh=function(staticSources){if(this._inEdges){const key=staticSources&&staticSources[0]||null;const inEdge=this._inEdges.find((edge=>edge.key===key));if(inEdge){fluid.cell.update(this,inEdge)}}};fluid.cell.markStale=function(cell,state,markedSources,dirtyFrom,availChange){console.log("markStale for "+cell.name," state ",state);if(cell._isEffect&&!cell._isQueued){console.log("Pushing effect "+cell.name);cell._isQueued=true;fluid.EffectQueue.push(cell)}if(cell._state<state||availChange){cell._state=state;cell._dirtyFrom=dirtyFrom;markedSources.push(cell);if(cell._observers){const consumedSources=cell._consumedSources;for(let i=0;i<cell._observers.length;i++){const observer=cell._observers[i];if(!consumedSources?.includes(observer)&&!markedSources.includes(observer)){fluid.cell.markStale(observer,CacheCheck,markedSources,cell,availChange)}}}}};fluid.cell.beginTracking=function(cell,inEdge){const updateRecord={oldValue:cell._value,prevReaction:fluid.CurrentReaction,prevGets:fluid.CurrentGets,prevIndex:fluid.CurrentGetsIndex,inEdge:inEdge};cell._updateRecord=updateRecord;fluid.CurrentReaction=inEdge;fluid.CurrentGets=null;fluid.CurrentGetsIndex=0};fluid.cell.updateDependencies=function(cell,inEdge){if(fluid.CurrentGets){fluid.cell.removeParentObservers(cell,inEdge,fluid.CurrentGetsIndex);if(inEdge.sources&&fluid.CurrentGetsIndex>0){inEdge.sources.length=fluid.CurrentGetsIndex+fluid.CurrentGets.length;for(let i=0;i<fluid.CurrentGets.length;i++){inEdge.sources[fluid.CurrentGetsIndex+i]=fluid.CurrentGets[i]}}else{inEdge.sources=fluid.CurrentGets}for(let i=fluid.CurrentGetsIndex;i<inEdge.sources.length;i++){const source=inEdge.sources[i];if(!source._observers){source._observers=[cell]}else{source._observers.push(cell)}}}else if(inEdge.sources&&fluid.CurrentGetsIndex<inEdge.sources.length){fluid.cell.removeParentObservers(cell,inEdge,fluid.CurrentGetsIndex);inEdge.sources.length=fluid.CurrentGetsIndex}};fluid.cell.endTracking=function(cell,syncUpdate){const updateRecord=cell._updateRecord;if(syncUpdate){cell._updateRecord=null}fluid.CurrentGets=updateRecord.prevGets;fluid.CurrentReaction=updateRecord.prevReaction;fluid.CurrentGetsIndex=updateRecord.prevIndex;cell._state=CacheClean;if(fluid.CurrentReaction===null){fluid.endFit()}};fluid.cell.untracked=function(fn){const stateCell={};fluid.cell.beginTracking(stateCell,null);try{fn()}finally{fluid.cell.endTracking(stateCell,true)}};fluid.cell.updateComplete=function(newValue,cell,syncUpdate){const availChange=!fluid.isUnavailable(newValue)&&fluid.isUnavailable(cell._value);cell._value=newValue;const updateRecord=cell._updateRecord;if(!syncUpdate){cell._updateRecord=null}if(!fluid.isUnavailable(newValue)){console.log("Update complete for "+cell.name+", marking clean");cell._state=CacheClean}if(!fluid.cell.equals(updateRecord.oldValue,cell._value)&&cell._observers){const consumedSources=cell._consumedSources;for(let i=0;i<cell._observers.length;i++){const observer=cell._observers[i];if(!consumedSources?.includes(observer)){fluid.cell.markStale(observer,CacheDirty,[],cell,availChange)}}if(!fluid.isUnavailable(newValue)){fluid.cell.stabilize()}}};fluid.cell.bindIterable=function(cell,inEdge,iterable){const bindIterable=nextIt=>{nextIt.then((res=>{fluid.cell.updateComplete(res.value,cell,!res.done);if(!res.done){cell._updateRecord.oldValue=res.value;const nextIt=iterable.next();bindIterable(nextIt)}}),(e=>{cell._error=e}))};const nextIt=iterable.next();bindIterable(nextIt)};fluid.cell.update=function(cell,inEdge){if(cell._updateRecord||!cell._inEdges){return}fluid.cell.beginTracking(cell,inEdge);let syncUpdate=!inEdge.isAsync;if(!syncUpdate){cell.set(fluid.pending(cell._value,cell.name))}try{const args=inEdge.staticSources?inEdge.staticSources.map((s=>s.get())):[];fluid.consumeSources(cell,inEdge.sources);const result=inEdge.fn.apply(null,args);if(!syncUpdate){if(fluid.isPromise(result)){result.then((newValue=>{console.log("Async update for value of cell ",cell.name);fluid.cell.updateComplete(newValue,cell,false)}),(e=>cell._error=e))}else if(result[Symbol.asyncIterator]){fluid.cell.bindIterable(cell,inEdge,result)}else{syncUpdate=true}}if(syncUpdate){fluid.cell.updateComplete(result,cell,true)}}catch(e){cell._error=e}finally{fluid.cell.updateDependencies(cell,inEdge);fluid.cell.endTracking(cell,syncUpdate)}};fluid.cell.findDirtyEdge=function(cell){let bestCandidate;for(let i=0;i<cell._inEdges.length;++i){const edge=cell._inEdges[i];if(edge.isFree||!edge.sources?.some((source=>fluid.isUnavailable(source._value)||source._state!==CacheClean))){bestCandidate=edge;break}}return bestCandidate};fluid.cell.updateIfNecessary=function(cell,visited){let dirtyEdge=null;visited=visited||[];visited.push(cell);if(cell._state!==CacheClean){if(cell._inEdges){for(const edge of cell._inEdges){if(edge.sources){for(const source of edge.sources){if(!visited.includes(source)){fluid.cell.updateIfNecessary(source,visited)}}if(cell._state===CacheDirty){dirtyEdge=fluid.cell.findDirtyEdge(cell);if(dirtyEdge){break}}}}}}if(!dirtyEdge&&cell._state===CacheDirty){dirtyEdge=fluid.cell.findDirtyEdge(cell)}if(dirtyEdge){fluid.cell.update(cell,dirtyEdge)}};fluid.cell.removeParentObservers=function(cell,edge,index){if(!edge.sources){return}for(let i=index;i<edge.sources.length;i++){const source=edge.sources[i];if(!source._observers){continue}const ourIndex=source._observers.findIndex((v=>v===cell));if(ourIndex!==-1){fluid.removeAtIndex(source._observers,ourIndex)}}};fluid.cell.disposableEffect=function(config){const effect=fluid.cell();effect._isEffect=true;effect._isQueued=false;effect._isDisposed=false;effect.name=config?.name;effect.dispose=function(){if(config?.unbind?.fn){config.unbind.fn()}effect.computed(null,staticSources,config);effect._isDisposed=true;if(effect._inEdges){effect._inEdges.forEach((edge=>fluid.cell.removeParentObservers(effect,edge,0)));effect._inEdges=null}};const{fn:fn,staticSources:staticSources}=config.bind;const computeFn=config.isFree?fn:function(){if(effect._isDisposed){return}const args=staticSources.map((s=>s.get()));fn.apply(effect,args)};effect.computed(computeFn,staticSources,config);fluid.cell.updateIfNecessary(effect);return effect};fluid.cell.effect=function(fn,staticSources,props){return fluid.cell.disposableEffect({bind:{fn:fn,staticSources:staticSources},unbind:{fn:props?.onDispose},isFree:props?.isFree,name:props?.name})};fluid.cell.stabilize=function(){while(fluid.EffectQueue.length>0){const queue=fluid.EffectQueue.slice();fluid.EffectQueue.length=0;for(let i=0;i<queue.length;i++){const effect=queue[i];effect.get();effect._isQueued=false;console.log("Effect "+effect.name+" unqueued")}}};fluid.cell.signalToPromise=function(valSignal){return new Promise((resolve=>{fluid.cell.effect((function(value){resolve(value);this.dispose()}),[valSignal],{name:"Resolution effect for cell "+valSignal.name})}))}};$fluidSignalsScope.$fluidScopePath="fluid";if(typeof fluid!=="undefined"){$fluidSignalsScope(fluid)}"use strict";var{signal:signal,effect:effect,computed:computed,untracked:untracked}=preactSignalsCore;const $fluidScope=function(fluid){fluid.Error=Error;fluid.environment={fluid:fluid};fluid.global=fluid.global||typeof window!=="undefined"?window:typeof self!=="undefined"?self:{};fluid.isBrowser=function(){return typeof window!=="undefined"&&!!window.document};fluid.invokeLater=function(func){return queueMicrotask(func)};fluid.defeatLogging=true;fluid.activityTracing=false;fluid.activityTrace=[];const activityParser=/(%\w+)/g;fluid.isComponent=()=>false;fluid.renderActivityArgument=function(arg){if(fluid.isComponent(arg)){return fluid.dumpComponentAndPath(arg)}else{return arg}};fluid.renderOneActivity=function(activity,nowhile){const togo=nowhile===true?[]:["    while "];const message=activity.message;let index=activityParser.lastIndex=0;while(true){const match=activityParser.exec(message);if(match){const key=match[1].substring(1);togo.push(message.substring(index,match.index));togo.push(fluid.renderActivityArgument(activity.args[key]));index=activityParser.lastIndex}else{break}}if(index<message.length){togo.push(message.substring(index))}return togo};fluid.renderActivity=function(activityStack,renderer){renderer=renderer||fluid.renderOneActivity;return activityStack.map(renderer)};fluid.activityStack=[];fluid.getActivityStack=function(){return fluid.activityStack};fluid.logActivity=function(activity){activity=activity||fluid.getActivityStack();const rendered=fluid.renderActivity(activity).reverse();if(rendered.length>0){fluid.log("Current activity: ");fluid.each(rendered,(function(args){fluid.log.apply(null,args)}))}};fluid.pushActivity=function(type,message,args){const record={type:type,message:message,args:args,time:(new Date).getTime()};if(fluid.activityTracing){fluid.activityTrace.push(record)}if(fluid.passLogLevel(fluid.logLevel.TRACE)){fluid.log.apply(null,fluid.renderOneActivity(record,true))}const activityStack=fluid.getActivityStack();activityStack.push(record)};fluid.popActivity=function(popframes){popframes=popframes||1;if(fluid.activityTracing){fluid.activityTrace.push({pop:popframes})}const activityStack=fluid.getActivityStack();const popped=activityStack.length-popframes;activityStack.length=popped<0?0:popped};fluid.FluidError=function(){const togo=Error.apply(this,arguments);this.message=togo.message;this.stack=togo.stack;return this};fluid.FluidError.prototype=Object.create(Error.prototype);fluid.logFailure=function(args,activity){fluid.log.apply(null,[fluid.logLevel.FAIL,"ASSERTION FAILED: "].concat(args));fluid.logActivity(activity)};fluid.renderCause=function(cause){let message=cause.message;if(cause.path){message+=" at path "+cause.path}if(cause.site){message+=fluid.dumpComponentAndPath(cause.site.that)}return message};fluid.renderUnavailable=function(unavailable){return["Causes:",...unavailable.causes.map((cause=>fluid.renderCause(cause)))].join("\n")};fluid.renderLoggingArg=function(arg){return arg===undefined?"undefined":fluid.isUnavailable(arg)?arg.message:fluid.isPrimitive(arg)||!fluid.isPlainObject(arg)?arg:JSON.stringify(arg)};fluid.builtinFail=function(args){const message=args.map(fluid.renderLoggingArg).join(" ");throw new fluid.FluidError("Assertion failure - check console for more details:\n"+message)};fluid.fail=function(...messages){const activity=fluid.makeArray(fluid.getActivityStack());fluid.popActivity(activity.length);if(fluid.failureEvent){fluid.failureEvent.fire(messages,activity)}else{fluid.logFailure(messages,activity);fluid.builtinFail(messages,activity)}};fluid.isLogging=function(){return fluid.logLevelStack[0].priority>fluid.logLevel.IMPORTANT.priority};fluid.isLogLevel=function(arg){return fluid.isMarker(arg)&&arg.priority!==undefined};fluid.passLogLevel=function(testLogLevel){return testLogLevel.priority<=fluid.logLevelStack[0].priority};fluid.setLogging=function(enabled){let logLevel;if(typeof enabled==="boolean"){logLevel=fluid.logLevel[enabled?"INFO":"IMPORTANT"]}else if(fluid.isLogLevel(enabled)){logLevel=enabled}else{fluid.fail("Unrecognised fluid logging level ",enabled)}fluid.logLevelStack.unshift(logLevel);fluid.defeatLogging=!fluid.isLogging()};fluid.setLogLevel=fluid.setLogging;fluid.popLogging=function(){const togo=fluid.logLevelStack.length===1?fluid.logLevelStack[0]:fluid.logLevelStack.shift();fluid.defeatLogging=!fluid.isLogging();return togo};fluid.doBrowserLog=function(args){if(typeof console!=="undefined"){if(console.debug){console.debug.apply(console,args)}else if(typeof console.log==="function"){console.log.apply(console,args)}}};fluid.log=function(){const directArgs=fluid.makeArray(arguments);let userLogLevel=fluid.logLevel.INFO;if(fluid.isLogLevel(directArgs[0])){userLogLevel=directArgs.shift()}if(fluid.passLogLevel(userLogLevel)){fluid.loggingEvent.fire(directArgs)}};fluid.isPrimitive=function(value){const valueType=typeof value;return!value||valueType==="string"||valueType==="boolean"||valueType==="number"||valueType==="function"};fluid.isArrayable=function(totest){return Boolean(totest)&&Object.prototype.toString.call(totest)==="[object Array]"};fluid.isPlainObject=function(totest,strict){const string=Object.prototype.toString.call(totest);if(string==="[object Array]"){return!strict}else if(string!=="[object Object]"){return false}const prototype=Object.getPrototypeOf(totest);return prototype===null||prototype===Object.prototype||Object.getPrototypeOf(prototype)===null};fluid.typeCode=function(totest){return fluid.isPrimitive(totest)||!fluid.isPlainObject(totest)?"primitive":fluid.isArrayable(totest)?"array":"object"};fluid.isILReference=function(ref){return typeof ref==="string"&&ref.charAt(0)==="{"};fluid.isReferenceOrExpander=function(ref){return ref&&(fluid.isILReference(ref)||ref.expander)};fluid.isDOMNode=function(obj){return obj&&typeof obj.nodeType==="number"};fluid.isUncopyable=function(totest){return fluid.isPrimitive(totest)||!fluid.isPlainObject(totest)};fluid.notImplemented=function(){fluid.fail("This operation is not implemented")};fluid.identity=function(arg){return arg};fluid.freshContainer=function(tocopy){return fluid.isArrayable(tocopy)?[]:{}};fluid.strategyRecursionBailout=128;fluid.testStrategyRecursion=function(funcName,segs){if(segs.length>fluid.strategyRecursionBailout){fluid.fail("Runaway recursion encountered in "+funcName+" - reached path depth of "+fluid.strategyRecursionBailout+" via path of "+segs.join(".")+"this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout")}};fluid.copy=function(tocopy,segs=[]){fluid.testStrategyRecursion("fluid.copy",segs);const copyMember=function(value,key){segs.push(key);const togo=fluid.copy(value,segs);segs.pop();return togo};if(fluid.isUncopyable(tocopy)){return tocopy}else if(Array.isArray(tocopy)){return tocopy.map(((value,key)=>copyMember(value,key)))}else{return fluid.transform(tocopy,copyMember)}};fluid.makeArray=function(arg){return arg===null||arg===undefined?[]:fluid.isPrimitive(arg)||typeof arg[Symbol.iterator]!=="function"?[arg]:[...arg]};fluid.arrayEqual=function(array1,array2){return array1.length===array2.length&&array1.every(((element,index)=>element===array2[index]))};fluid.pushArray=function(holder,member,topush){const array=holder[member]?holder[member]:holder[member]=[];if(Array.isArray(topush)){array.push.apply(array,topush)}else{array.push(topush)}};fluid.transform=function(source,func){if(source){const togo={};for(const key in source){const ret=func(source[key],key);if(ret!==fluid.NoValue){togo[key]=ret}}return togo}else{return source}};fluid.map=function(source,func){if(Array.isArray(source)){const togo=[];source.forEach(((value,index)=>{const ret=func(value,index);if(ret!==fluid.NoValue){togo.push(ret)}}));return togo}else{return source}};fluid.each=function(source,func){if(source){for(const key in source){func(source[key],key)}}};fluid.peek=function(array){return array.length===0?undefined:array[array.length-1]};fluid.make_find=function(find_if){const target=find_if?false:undefined;return function(source,func,deffolt){let disp;if(fluid.isArrayable(source)){for(let i=0;i<source.length;++i){disp=func(source[i],i);if(disp!==target){return find_if?source[i]:disp}}}else{for(const key in source){disp=func(source[key],key);if(disp!==target){return find_if?source[key]:disp}}}return deffolt}};fluid.find=fluid.make_find(false);fluid.find_if=fluid.make_find(true);fluid.remove_if=function(source,fn,target){if(fluid.isArrayable(source)){for(let i=source.length-1;i>=0;--i){if(fn(source[i],i)){if(target){target.unshift(source[i])}source.splice(i,1)}}}else{for(const key in source){if(fn(source[key],key)){if(target){target[key]=source[key]}delete source[key]}}}return target||source};fluid.iota=function(count,first){first=first||0;const togo=[];for(let i=0;i<count;++i){togo[togo.length]=first++}return togo};fluid.getMembers=function(holder,name){return fluid.transform(holder,(function(member){return fluid.get(member,name)}))};fluid.filterKeys=function(toFilter,keys,exclude){return fluid.remove_if($.extend({},toFilter),(function(value,key){return exclude^keys.indexOf(key)===-1}))};fluid.censorKeys=function(toCensor,keys){return fluid.filterKeys(toCensor,keys,true)};fluid.partition=function(array,filter){let pass=[],fail=[];array.forEach(((e,idx,arr)=>(filter(e,idx,arr)?pass:fail).push(e)));return[pass,fail]};fluid.parseInteger=function(string){return isFinite(string)&&string%1===0?Number(string):NaN};fluid.clear=function(target){for(let i in target){delete target[i]}};fluid.freezeRecursive=function(tofreeze,segs){segs=segs||[];fluid.testStrategyRecursion("fluid.freezeRecursive",segs);if(fluid.isPlainObject(tofreeze)){fluid.each(tofreeze,(function(value,key){segs.push(key);fluid.freezeRecursive(value,segs);segs.pop()}));return Object.freeze(tofreeze)}else{return tofreeze}};fluid.marker=function(){};fluid.makeMarker=function(type,extra,mutable){const togo=Object.create(fluid.marker.prototype);Object.assign(togo,{...extra||{},...{type:type}});return mutable?togo:Object.freeze(togo)};fluid.NoValue=fluid.makeMarker("No Value");fluid.isMarker=function(totest,types){if(!(totest instanceof fluid.marker)){return false}if(!types){return true}else if(typeof types==="string"){return totest.type===types}else{return types.includes(totest.type)}};fluid.logLevelsSpec={FATAL:0,FAIL:5,WARN:10,IMPORTANT:12,INFO:15,TRACE:20};fluid.logLevel=fluid.transform(fluid.logLevelsSpec,((key,value)=>fluid.makeMarker(key,{priority:value})));fluid.logLevelStack=[fluid.logLevel.IMPORTANT];fluid.unavailablePriority={"I/O":1,config:2,error:3};fluid.unavailableProxy=function(target){const proxy=new Proxy(target,{get:function(target,prop){if(prop===$t){return target}else if(prop===Symbol.toPrimitive){return target}else if(prop==="toString"){return()=>fluid.formatUnavailable(target)}else{return proxy}},getOwnPropertyDescriptor:function(target,key){return{value:this.get(target,key),enumerable:true,configurable:true}},getPrototypeOf:()=>Object.getPrototypeOf(target)});return proxy};fluid.deproxyUnavailable=function(target){return Object.getOwnPropertyDescriptor(target,$u)?fluid.deSignal(target[$u]):target};fluid.mergeUnavailables=function(unavailables){return unavailables.reduce((function(acc,entry){return entry?fluid.mergeUnavailable(acc,entry):acc}),null)};fluid.coerceToPrimitive=function(string){return/^(true|false|null)$/.test(string)||/^[\[{0-9]/.test(string)&&!/^{[\w|\${]/.test(string)?JSON.parse(string):string};fluid.isSignal=value=>value instanceof preactSignalsCore.Signal;fluid.deSignal=ref=>{let deref=0;while(fluid.isSignal(ref)){ref=ref.value;deref++;if(deref>fluid.strategyRecursionBailout){fluid.fail("Cyclic reference structure found in fluid.deSignal of ",ref)}}return ref};fluid.defaultSignalOptions={flattenArg:fluid.deSignal};fluid.OldValue=fluid.makeMarker("Old Computed Value");fluid.processSignalArgs=function(args,options,oldValue){let unavailable=undefined;const designalArgs=[];if(!Array.isArray(args)){args=[args]}const flattenArg=options?.flattenArg;for(let i=0;i<args.length;++i){let arg=args[i];if(arg instanceof preactSignalsCore.Signal){arg=flattenArg?flattenArg(arg,i):arg.value}if(arg===fluid.OldValue){arg=fluid.isUnavailable(oldValue)?null:oldValue}if(fluid.isUnavailable(arg)){unavailable=fluid.mergeUnavailable(unavailable,arg)}designalArgs.push(arg)}return{designalArgs:designalArgs,unavailable:unavailable}};fluid.signalsToAvailable=function(sigs){return computed((()=>{const sigRec=fluid.processSignalArgs(sigs);return sigRec.unavailable||sigRec.designalArgs}))};fluid.signalToPromise=function(valSignal){return new Promise((resolve=>{fluid.effect((function(value){resolve(value);this.dispose()}),[valSignal])}))};fluid.accumulateUnavailableSite=function(unavailable,site){if(site){const unwrapped=fluid.deproxyUnavailable(unavailable);const lastCause=unwrapped.causes?unwrapped.causes[0]:unwrapped;if(!Array.isArray(lastCause.site)){lastCause.site=fluid.makeArray(lastCause.site)}if(!lastCause.site.includes(site)){lastCause.site.push(site)}}return unavailable};fluid.notEvaluated=fluid.unavailable("Computed not yet evaluated","config");fluid.computed=function(funcSignal,argSignals,options){return computed((function fluidComputed(oldValue){const acc=u=>fluid.accumulateUnavailableSite(u,this.site);const{designalArgs:designalArgs,unavailable:unavailable}=fluid.processSignalArgs(argSignals,options||fluid.defaultSignalOptions,oldValue);const func=fluid.deSignal(funcSignal);const anyUnavailable=unavailable||(fluid.isUnavailable(func)?func:false);if(options?.dispatcher){return options.dispatcher(func,designalArgs,anyUnavailable,oldValue)}else{return anyUnavailable?acc(anyUnavailable):func.apply(null,designalArgs)}}),fluid.notEvaluated)};let effectId=1;fluid.effect=function(func,args,options){const togo=effect((function fluidEffect(){const{designalArgs:designalArgs,unavailable:unavailable}=fluid.processSignalArgs(args,options||fluid.defaultSignalOptions);if(!unavailable||options?.free){return untracked((()=>func.apply(this,designalArgs)))}}),options);togo.$func=func;togo.$args=args;togo.effectId=effectId++;return togo};fluid.catch=function(source,func){return effect((()=>{const result=source.value;if(fluid.isErrorUnavailable(result)){func(result)}}))};fluid.disposeEffects=function(effectStructure){if(effectStructure instanceof preactSignalsCore.Effect){effectStructure.dispose()}else if(Array.isArray(effectStructure)){effectStructure.forEach((effect=>effect.dispose()));effectStructure.length=0}else{Object.values(effectStructure).forEach((value=>fluid.disposeEffects(value)))}};fluid.singleSourceEffect=function(aComputed,fn){let oldValue=aComputed.value;return effect((()=>{const newValue=aComputed.value;if(oldValue!==newValue){fn(oldValue,newValue);oldValue=newValue}}))};fluid.sampleComputed=computed((()=>{}));const computedPrototype=Object.getPrototypeOf(fluid.sampleComputed);const computedPrototypeDescriptor=Object.getOwnPropertyDescriptor(computedPrototype,"value");fluid.delegateUnavailable=fluid.unavailable({message:"No written value for delegated signal"});fluid.DelegatedSignal=function(outerSignal,onWrite,onReset){const computer=computed((()=>{const targetValue=computer._target.value;return fluid.isUnavailable(targetValue)?computer._outerSignal.value:targetValue}));Object.setPrototypeOf(computer,fluid.DelegatedSignal.prototype);computer._outerSignal=outerSignal;computer._onWrite=onWrite;computer._onReset=onReset;computer._target=signal(fluid.delegateUnavailable);return computer};fluid.DelegatedSignal.prototype=fluid.sampleComputed;fluid.DelegatedSignal.prototype.reset=function(){if(this._onReset){this.onReset(this._target,this)}this._target.value=fluid.delegateUnavailable};Object.defineProperty(fluid.DelegatedSignal.prototype,"value",{get:computedPrototypeDescriptor.get,set:function(newValue){if(this._target){this._target.value=newValue}else{this._target=signal(newValue);if(this._onWrite){this._onWrite(this._target,this)}}}});fluid.delegatedSignal=function(outerSignal,onWrite,onReset){return new fluid.DelegatedSignal(outerSignal,onWrite,onReset)};fluid.getPathSegmentImpl=function(accept,path,i){let segment="";let escaped=false;const limit=path.length;for(;i<limit;++i){const c=path.charAt(i);if(!escaped){if(c==="."){break}else if(c==="\\"){escaped=true}else{segment+=c}}else{escaped=false;segment+=c}}accept[0]=segment;return i};fluid.parsePath=function(path){const togo=[],accept=[null];let index=0;const limit=path.length;while(index<limit){const firstdot=fluid.getPathSegmentImpl(accept,path,index);togo.push(accept[0]);index=firstdot+1}return togo};fluid.pathToSegs=function(path){return fluid.isPrimitive(path)?fluid.parsePath(path):path};fluid.composePath=function(prefix,toappend){toappend=toappend.toString();for(let i=0;i<toappend.length;++i){const c=toappend.charAt(i);if(c==="."||c==="\\"||c==="}"){prefix+="\\"}prefix+=c}return prefix};fluid.composeSegment=function(prefix,suffix){if(prefix.length!==0){prefix+="."}return fluid.composePath(prefix,suffix)};fluid.composeSegments=function(segments){let path="";for(let i=0;i<segments.length;++i){path=fluid.composeSegment(path,segments[i])}return path};fluid.missingPolicies={unavailable:(root,path)=>fluid.unavailable({message:`Path ${path} was not found`,site:root}),error:(root,path)=>fluid.fail("Path ",path," was not found in model ",root)};fluid.get=function(root,path,missingPolicy){const segs=fluid.pathToSegs(path);const limit=segs.length;for(let j=0;j<limit;++j){root=root?root[segs[j]]:undefined}if(root===undefined&&missingPolicy){return fluid.missingPolicies[missingPolicy](root,path)}else{return root}};fluid.getThroughSignals=function(root,segs,extra){const togo=computed((function getThroughSignals(){if(window.cycleImminent){debugger}let move=fluid.deSignal(root);for(let j=0;j<segs.length;++j){if(!move||fluid.isUnavailable(move)){break}const seg=segs[j];if(!(seg in move)&&move[$m]){const shadow=move[$m];move=fluid.unavailable({message:`Component at path ${shadow.path} has no member ${seg}`,site:{shadow:shadow,segs:segs}});break}move=fluid.deSignal(move[seg])}return move}));Object.assign(togo,extra);return togo};fluid.set=function(root,path,newValue){const segs=fluid.pathToSegs(path);for(let i=0;i<segs.length-1;++i){const seg=segs[i];if(!root[seg]){root[seg]=Object.create(null)}root=root[seg]}root[segs[segs.length-1]]=newValue};fluid.shallowCopy=function(source){return Array.isArray(source)?source.slice():{...source}};fluid.setImmutable=function(root,path,newValue){const segs=fluid.pathToSegs(path);if(segs.length===0){return newValue}else{let newRoot=fluid.shallowCopy(root);let current=newRoot;for(let i=0;i<segs.length-1;++i){const seg=segs[i];let next=current[seg];if(next===undefined||next===null){next={}}const copied=fluid.shallowCopy(next);current[seg]=copied;current=copied}current[segs[segs.length-1]]=newValue;return newRoot}};fluid.getRecInsist=function(root,segs){segs.forEach((seg=>{if(!root[seg]){root[seg]=Object.create(null)}root=root[seg]}));return root};fluid.forEachDeep=function(root,visitor,segs=[]){if(fluid.isPlainObject(root,true)){if(root[$m]){visitor(root[$m],segs)}fluid.each(root,((value,key)=>{segs.push(key);fluid.forEachDeep(value,visitor,segs);segs.pop()}))}};fluid.getGlobalValue=path=>{const value=fluid.get(fluid.global,path);return value===undefined?fluid.unavailable({message:"Global value "+path+" is not defined",path:path}):value};fluid.invokeGlobalFunction=function(functionPath,args){const func=fluid.getGlobalValue(functionPath);if(fluid.isUnavailable(func)){return fluid.mergeUnavailable(fluid.unavailable({message:"Error invoking global function: "+functionPath+" could not be located"}),func)}else{const argsArray=fluid.isArrayable(args)?args:fluid.makeArray(args);return func.apply(null,argsArray)}};fluid.setGlobalValue=(path,value)=>{fluid.set(fluid.global,path,value)};fluid.registerNamespace=function(path){let existing=fluid.getGlobalValue(path);if(fluid.isUnavailable(existing)){existing={};fluid.setGlobalValue(path,existing)}return existing};fluid.dumpEl=x=>x;fluid.renderTimestamp=x=>x;fluid.generateUniquePrefix=function(){return Math.floor(Math.random()*1e12).toString(36)+"-"};const fluid_prefix=fluid.generateUniquePrefix();fluid.fluidInstance=fluid_prefix;let fluid_id=1;fluid.allocateGuid=function(){return fluid_prefix+fluid_id++};fluid.allocateId=function(){return fluid_id++};fluid.extremePriority=4e9;fluid.priorityTypes={first:-1,last:1,before:0,after:0};fluid.extremalPriorities={none:0,transaction:10,testing:20,authoring:30};fluid.parsePriorityConstraint=function(constraint,fixedOnly,site){const segs=constraint.split(":");const type=segs[0];const lookup=fluid.priorityTypes[type];if(lookup===undefined){fluid.fail("Invalid constraint type in priority field "+constraint+": the only supported values are "+fluid.keys(fluid.priorityTypes).join(", ")+" or numeric")}if(fixedOnly&&lookup===0){fluid.fail("Constraint type in priority field "+constraint+" is not supported in a "+site+" record - you must use either a numeric value or first, last")}return{type:segs[0],target:segs[1]}};fluid.parsePriority=function(priority,count,fixedOnly,site){priority=priority||0;const togo={count:count||0,fixed:null,constraint:null,site:site};if(typeof priority==="number"){togo.fixed=-priority}else{togo.constraint=fluid.parsePriorityConstraint(priority,fixedOnly,site)}const multiplier=togo.constraint?fluid.priorityTypes[togo.constraint.type]:0;if(multiplier!==0){const target=togo.constraint.target||"none";const extremal=fluid.extremalPriorities[target];if(extremal===undefined){fluid.fail("Unrecognised extremal priority target "+target+": the currently supported values are "+fluid.keys(fluid.extremalPriorities).join(", ")+": register your value in fluid.extremalPriorities")}togo.fixed=multiplier*(fluid.extremePriority+extremal)}if(togo.fixed!==null){togo.fixed+=togo.count/1024}return togo};fluid.renderPriority=function(parsed){return parsed.constraint?parsed.constraint.target?parsed.constraint.type+":"+parsed.constraint.target:parsed.constraint.type:Math.floor(parsed.fixed)};fluid.compareByPriority=function(recA,recB){if(recA.priority.fixed!==null&&recB.priority.fixed!==null){return recA.priority.fixed-recB.priority.fixed}else{return(recA.priority.fixed===null)-(recB.priority.fixed===null)}};fluid.honourConstraint=function(array,firstConstraint,c){const constraint=array[c].priority.constraint;const matchIndex=array.findIndex((element=>element.namespace===constraint.target));if(matchIndex===-1){return true}else if(matchIndex>=firstConstraint){return false}else{const offset=constraint.type==="after"?1:0;const target=matchIndex+offset;const temp=array[c];for(let shift=c;shift>=target;--shift){array[shift]=array[shift-1]}array[target]=temp;return true}};fluid.sortByPriority=function(array){array.sort(fluid.compareByPriority);let firstConstraint=array.findIndex((element=>element.priority.constraint&&fluid.priorityTypes[element.priority.constraint.type]===0));if(firstConstraint===-1){firstConstraint=array.length}while(true){if(firstConstraint===array.length){return array}const oldFirstConstraint=firstConstraint;for(let c=firstConstraint;c<array.length;++c){const applied=fluid.honourConstraint(array,firstConstraint,c);if(applied){++firstConstraint}}if(firstConstraint===oldFirstConstraint){const holders=array.slice(firstConstraint);fluid.fail("Could not find targets for any constraints in "+holders[0].priority.site+" ",holders,": none of the targets ("+holders.map((holder=>holder.priority.constraint.target)).join(", ")+") matched any namespaces of the elements in (",array.slice(0,firstConstraint),") - this is caused by either an invalid or circular reference")}}};fluid.parsePriorityRecords=function(records,name){const array=fluid.hashToArray(records,"namespace",(function(newElement,oldElement){$.extend(newElement,oldElement);newElement.priority=fluid.parsePriority(oldElement.priority,0,false,name)}));fluid.sortByPriority(array);return array};fluid.registerNamespace("fluid.event");fluid.event.identifyListener=function(listener,soft){if(typeof listener!=="string"&&!listener.$$fluid_guid&&!soft){listener.$$fluid_guid=fluid.allocateGuid()}return listener.$$fluid_guid};fluid.event.impersonateListener=function(origListener,newListener){fluid.event.identifyListener(origListener);newListener.$$fluid_guid=origListener.$$fluid_guid};fluid.event.sortListeners=function(listeners){let togo=[];Object.values(listeners).forEach((oneNamespace=>{let headHard;for(let i=0;i<oneNamespace.length;++i){const thisListener=oneNamespace[i];if(!thisListener.softNamespace&&!headHard){headHard=thisListener}}if(headHard){togo.push(headHard)}else{togo=togo.concat(oneNamespace)}}));return fluid.sortByPriority(togo)};fluid.event.resolveListener=function(listener){const listenerName=listener.globalName||(typeof listener==="string"?listener:null);if(listenerName){const listenerFunc=fluid.getGlobalValue(listenerName);if(!listenerFunc){fluid.fail("Unable to look up name "+listenerName+" as a global function")}else{listener=listenerFunc}}return listener};fluid.nameComponent=function(that){return that?fluid.dumpComponentAndPath(that):"[unknown component]"};fluid.event.nameEvent=function(that,eventName){return eventName+" of "+fluid.nameComponent(that)};fluid.event.firer=function(){};fluid.makeEventFirer=function(options){options=options||{};const name=options.name||"<anonymous>";let that;const lazyInit=function(){that.listeners={};that.byId={};that.sortedListeners=[];that.onDestroy=null;that.addListener=function(listener,namespace,priority,softNamespace,listenerId){let record;if(that.destroyed){fluid.fail("Cannot add listener to destroyed event firer "+that.name)}if(!listener){return}if(fluid.isPlainObject(listener,true)&&!fluid.isApplicable(listener)){record=listener;listener=record.listener;namespace=record.namespace;priority=record.priority;softNamespace=record.softNamespace;listenerId=record.listenerId}if(typeof listener==="string"){listener={globalName:listener}}const id=listenerId||fluid.event.identifyListener(listener);namespace=namespace||id;record=Object.assign(record||{},{namespace:namespace,listener:listener,softNamespace:softNamespace,listenerId:listenerId,priority:fluid.parsePriority(priority,that.sortedListeners.length,false,"listeners")});that.byId[id]=record;const thisListeners=that.listeners[namespace]=fluid.makeArray(that.listeners[namespace]);thisListeners[softNamespace?"push":"unshift"](record);that.sortedListeners=fluid.event.sortListeners(that.listeners)};that.addListener.apply(null,arguments)};that=Object.create(fluid.event.firer.prototype);Object.assign(that,{eventId:fluid.allocateGuid(),name:name,ownerId:options.ownerId,typeName:"fluid.event.firer",destroy:function(){that.destroyed=true;fluid.each(that.onDestroy,(function(func){func()}))},addListener:function(){lazyInit.apply(null,arguments)},removeListener:function(listener){if(!that.listeners){return}let namespace,id,record;if(typeof listener==="string"){namespace=listener;record=that.listeners[namespace];if(!record){id=namespace;namespace=null}}else if(typeof listener==="function"){id=fluid.event.identifyListener(listener,true);if(!id){fluid.fail("Cannot remove unregistered listener function ",listener," from event "+that.name)}}const rec=that.byId[id];const softNamespace=rec&&rec.softNamespace;namespace=namespace||rec&&rec.namespace||id;delete that.byId[id];record=that.listeners[namespace];if(record){if(softNamespace){fluid.remove_if(record,(function(thisLis){return thisLis.listener.$$fluid_guid===id||thisLis.listenerId===id}))}else{record.shift()}if(record.length===0){delete that.listeners[namespace]}}that.sortedListeners=fluid.event.sortListeners(that.listeners)},fire:function(){const listeners=that.sortedListeners;if(options.promise){that.promisePayload=arguments[0]}if(!listeners||that.destroyed){return}for(let i=0;i<listeners.length;++i){const lisrec=listeners[i];if(typeof lisrec.listener!=="function"){lisrec.listener=fluid.event.resolveListener(lisrec.listener)}const listener=lisrec.listener;const ret=listener.apply(null,arguments);let value;if(options.preventable&&ret===false||that.destroyed){value=false}if(value!==undefined){return value}}}});if(options.promise){that.then=function(func){if("promisePayload"in that){func(that.promisePayload)}else{that.addListener(func)}}}return that};fluid.fireEvent=function(component,eventName,args){const firer=component.events&&component.events[eventName];if(firer){firer.fire.apply(null,fluid.makeArray(args))}};fluid.event.addListenerToFirer=function(firer,value,namespace,wrapper){wrapper=wrapper||(x=>x);if(fluid.isArrayable(value)){for(let i=0;i<value.length;++i){fluid.event.addListenerToFirer(firer,value[i],namespace,wrapper)}}else if(typeof value==="function"||typeof value==="string"){wrapper(firer).addListener(value,namespace)}else if(value&&typeof value==="object"){wrapper(firer).addListener(value.listener,namespace||value.namespace,value.priority,value.softNamespace,value.listenerId)}};fluid.event.resolveListenerRecord=function(records){return{records:records}};fluid.expandImmediate=function(material){fluid.fail("fluid.expandImmediate could not be loaded - please include FluidIL.js in order to operate IL event with descriptor "+material)};fluid.mergeListeners=function(that,events,listeners){fluid.each(listeners,(function(value,key){let firer,namespace;if(fluid.isILReference(key)){firer=fluid.expandImmediate(key,that);if(!firer){fluid.fail("Error in listener record: key "+key+' could not be looked up to an event firer - did you miss out "events." when referring to an event firer?')}}else{const keydot=key.indexOf(".");if(keydot!==-1){namespace=key.substring(keydot+1);key=key.substring(0,keydot)}if(!events[key]){fluid.fail("Listener registered for event "+key+" which is not defined for this component")}firer=events[key]}const record=fluid.event.resolveListenerRecord(value,that,key,namespace,true);fluid.event.addListenerToFirer(firer,record.records,namespace,record.adderWrapper)}))};fluid.eventFromRecord=function(eventSpec,eventKey,that){const isILEvent=eventSpec&&(typeof eventSpec!=="string"||fluid.isILReference(eventSpec));let event;if(isILEvent){if(!fluid.event.resolveEvent){fluid.fail("fluid.event.resolveEvent could not be loaded - please include FluidIL.js in order to operate IL driven event with descriptor ",eventSpec)}else{event=fluid.event.resolveEvent(that,eventKey,eventSpec)}}else{event=fluid.makeEventFirer({name:fluid.event.nameEvent(that,eventKey),preventable:eventSpec==="preventable",promise:eventSpec==="promise",ownerId:that.id})}return event};fluid.mergeListenerPolicy=function(target,source,key){if(typeof key!=="string"){fluid.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got "+key+" from ",source)}const hasNamespace=!fluid.isILReference(key)&&key.indexOf(".")!==-1;return hasNamespace?source||target:fluid.arrayConcatPolicy(target,source)};fluid.makeMergeListenersPolicy=function(merger,modelRelay){return function(target,source){target=target||{};if(modelRelay&&(fluid.isArrayable(source)||"target"in source&&(typeof source.target==="string"||source.target.segs))){target[""]=merger(target[""],source,"")}else{fluid.each(source,(function(listeners,key){target[key]=merger(target[key],listeners,key)}))}return target}};fluid.validateListenersImplemented=function(that){const errors=[];fluid.each(that.events,(function(event,name){fluid.each(event.sortedListeners,(function(lisrec){if(lisrec.listener===fluid.notImplemented||lisrec.listener.globalName==="fluid.notImplemented"){errors.push({name:name,namespace:lisrec.namespace,componentSource:fluid.model.getSimple(that.options.listeners,[name+"."+lisrec.namespace,0,"componentSource"])})}}))}));return errors};fluid.arrayConcatPolicy=function(target,source){return fluid.makeArray(target).concat(fluid.makeArray(source))};fluid.loggingEvent=fluid.makeEventFirer({name:"logging event"});fluid.addTimestampArg=function(args){const arg0=fluid.renderTimestamp(new Date)+":  ";args.unshift(arg0)};fluid.loggingEvent.addListener(fluid.doBrowserLog,"log");fluid.loggingEvent.addListener((x=>x),"filterArgs","before:log");fluid.loggingEvent.addListener(fluid.addTimestampArg,"addTimestampArg","after:filterArgs");fluid.upgradeError=function(originError,whileMsg){const error=originError instanceof Error?originError:fluid.isPrimitive(originError)?{message:originError}:fluid.extend({},originError);error.message=error.message+whileMsg;return error};fluid.failureEvent=fluid.makeEventFirer({name:"failure event"});fluid.failureEvent.addListener(fluid.builtinFail,"fail");fluid.failureEvent.addListener(fluid.logFailure,"log","before:fail");fluid.proxySymbol=Symbol("fluid.proxyTarget");const $t=fluid.proxySymbol;fluid.unavailableSymbol=Symbol("fluid.unavailableTarget");const $u=fluid.unavailableSymbol;fluid.unProxy=target=>target?.[$t]?target[$t]:target;fluid.metadataSymbol=Symbol("fluid.metadata");const $m=fluid.metadataSymbol;fluid.makeLayer=function(memberName,parent){const togo=Object.create(null);togo[$m]={type:"layer",memberName:memberName,parent:parent};return togo};fluid.layerStore=signal({});fluid.layerHistory=signal([]);fluid.layerHistoryIndex=signal(0);fluid.pushHistory=function(record){if((record.layerName.startsWith("{")||fluid.isUserLayer(record.layerName))&&!fluid.historyPush){const index=fluid.layerHistoryIndex.value;fluid.layerHistory.value=[...fluid.layerHistory.peek().slice(0,index),record];fluid.layerHistoryIndex.value=index+1}};fluid.applyLiveHistory=function(rec,key){const site=fluid.parseSite(rec.layerName);fluid.historyPush=true;fluid.setForComponent(site.shadow.that,site.path,rec[key]);fluid.historyPush=false};fluid.historyBack=function(){const index=fluid.layerHistoryIndex.value;if(index>0){const newIndex=index-1;const backRec=fluid.layerHistory.value[newIndex];if(backRec.type==="updateLayer"){if(backRec.layerName.startsWith("{")){fluid.applyLiveHistory(backRec,"oldValue")}else{}}fluid.layerHistoryIndex.value=newIndex}};fluid.historyForward=function(){const index=fluid.layerHistoryIndex.value;if(index<fluid.layerHistory.value.length){const newIndex=index+1;const foreRec=fluid.layerHistory.value[index];if(foreRec.type==="updateLayer"){if(foreRec.layerName.startsWith("{")){fluid.applyLiveHistory(foreRec,"newValue")}else{}}fluid.layerHistoryIndex.value=newIndex}};fluid.newLayer=function(layerName,layerValue){const store=fluid.layerStore.value;const newStore={...store,[layerName]:signal(layerValue)};fluid.layerStore.value=newStore;fluid.pushHistory({type:"newLayer",newStore:newStore,oldStore:store,layerName:layerName})};fluid.readLayer=function(layerName,demand=false){const store=fluid.layerStore.peek();const layerSig=store[layerName];if(layerSig){const layer=layerSig.peek();if(fluid.isUnavailable(layer)){if(demand){layerSig.demanded=true}}else if((demand||layerSig.demanded)&&!layer.demanded){layerSig.value={...layer,demanded:true}}return layerSig}else{const togo=store[layerName]=signal(fluid.unavailable({message:"Layer "+layerName+" is not defined",path:["layer",layerName]},"config"));if(demand){togo.demanded=true}return togo}};fluid.writeLayer=function(layerName,layer){const store=fluid.layerStore.peek();const layerSig=store[layerName];const layerValue={raw:layer,demanded:layerSig?.demanded,tick:0};if(layerSig){const oldValue=layerSig.peek();layerSig.value=layerValue;fluid.pushHistory({type:"updateLayer",oldValue:oldValue,newValue:layerValue,layerName:layerName})}else{fluid.newLayer(layerName,layerValue)}};fluid.invalidateLayer=function(layerName){const store=fluid.layerStore.peek();const layerSig=store[layerName];if(layerSig){const oldValue=layerSig.peek();if(!fluid.isUnavailable(oldValue)){layerSig.value={...oldValue,tick:oldValue.tick+1}}}};fluid.deleteLayer=function(layerName){const currentStore=fluid.layerStore.value;const newStore={...currentStore};delete newStore[layerName];fluid.layerStore.value=newStore;fluid.pushHistory({type:"deleteLayer",newStore:newStore,oldStore:currentStore,layerName:layerName})};fluid.readerExpandLayer=function(layer){return{...layer,$layers:fluid.makeArray(layer.$layers)}};fluid.layerFrameworkStatus=function(layerDef){const variety=layerDef.$variety;return!variety?0:variety==="frameworkAux"?1:variety==="framework"?2:-1};fluid.isUserLayer=function(layerName){const layerDef=fluid.readLayer(layerName).peek().raw;return layerDef&&!fluid.isUnavailable(layerDef)&&fluid.layerFrameworkStatus(layerDef)===0};fluid.mergeRecordTypes={def:1e3,subcomponent:700,user:600,distribution:300,template:200,dynamicLayers:150,live:100,defParents:0};fluid.mergeLayers=function(target,segs,layerMap,layers,mergeRecords){const clayers=layers.length;const allKeysRec={};layers.forEach((layer=>{if(fluid.isPlainObject(layer,true)){Object.keys(layer).forEach((key=>allKeysRec[key]=true))}}));delete allKeysRec["$variety"];const allKeys=Object.keys(allKeysRec);allKeys.forEach((key=>{let count=0;let last,newTarget;let lastIndex=-1;for(let i=0;i<clayers;++i){const layer=layers[i];if(fluid.isPlainObject(layer)&&key in layer){++count;last=layer[key];lastIndex=i}}if(count>1&&fluid.isPlainObject(last,true)){newTarget=fluid.makeLayer(key,target);const newLayers=layers.map((layer=>layer?.[key]));segs.push(key);fluid.mergeLayers(newTarget,segs,layerMap,newLayers,mergeRecords);segs.pop()}else{newTarget=last}target[key]=newTarget;fluid.set(layerMap,[...segs,key,$m,"source"],mergeRecords[lastIndex].mergeRecordName)}))};fluid.extractPolicy=function(layer,layerMap,segs=[]){const recurse=function(value,key){segs.push(key);fluid.extractPolicy(value,layerMap,segs);segs.pop()};if(fluid.isPlainObject(layer,true)){const allKeys=Object.keys(layer);if("$reactiveRoot"in layer){fluid.set(layerMap,[...segs,$m,"reactiveRoot"],true);if(allKeys.length!==1){fluid.fail("Unexpected extra keys together with $reactiveRoot: "+allKeys.join(", "))}}else{fluid.transform(layer,recurse)}}else if(Array.isArray(layer)){layer.forEach(recurse)}};fluid.mergeLayerRecords=function(root,mergeRecords){const layerMap={},segs=[];mergeRecords.forEach((mergeRecord=>{if(!mergeRecord.priority){mergeRecord.priority=fluid.mergeRecordTypes[mergeRecord.mergeRecordType]}}));mergeRecords.sort(((a,b)=>b.priority-a.priority));const layers=mergeRecords.map((mergeRecord=>mergeRecord.layer));layers.forEach((layer=>fluid.extractPolicy(layer,layerMap)));fluid.mergeLayers(root,segs,layerMap,layers,mergeRecords);return layerMap};fluid.coOccurrenceRegistry={};fluid.registerCoOccurrence=function(coOcName,record){fluid.coOccurrenceRegistry[coOcName]=record;record.inputLayers.forEach(fluid.invalidateLayer)};fluid.deregisterCoOccurrence=function(coOcName){const record=fluid.coOccurrenceRegistry[coOcName];delete fluid.coOccurrenceRegistry[coOcName];record.inputLayers.forEach(fluid.invalidateLayer)};fluid.resolveCoOccurrences=function(layerNames){const togo=[];const existing=new Set(layerNames);Object.values(fluid.coOccurrenceRegistry).forEach((record=>{const{inputLayers:inputLayers,outputLayers:outputLayers}=record;const allPresent=inputLayers.every((name=>existing.has(name)));if(allPresent){for(const outputLayer of outputLayers){if(!existing.has(outputLayer)){togo.push(outputLayer)}}}}));return togo};fluid.C3_merge=function(seqs){let res=[];while(true){let nonemptyseqs=seqs.filter((seq=>seq.length>0));if(nonemptyseqs.length===0){return res}let cand=null;for(let seq of nonemptyseqs){cand=seq[0];let nothead=nonemptyseqs.filter((s=>s.indexOf(cand)>0));if(nothead.length>0){cand=null}else{break}}if(!cand){fluid.fail(`Inconsistent hierarchy for layer ${res[0]}: conflict between parent orders ${nonemptyseqs.map((ns=>ns.toString())).join(", ")}`)}res.push(cand);for(let seq of nonemptyseqs){while(seq[0]===cand){seq.shift()}}}};fluid.C3_precedence=function(C,defs,visited){if(visited.has(C)){fluid.fail(`Circular hierarchy detected - layer ${C} has already been visited`)}visited.add(C);const def=defs[C];if(!def){fluid.fail(`Parent layer ${C} referenced which is not defined`)}const parents=Array.from(defs[C].$layers);const precLists=parents.map((parent=>fluid.C3_precedence(parent,defs,visited)));const merged=fluid.C3_merge([[C]].concat(precLists).concat([parents]));visited.delete(C);return merged};fluid.C3_precedence_parents=function(parents,defs){const visited=new Set;const precLists=parents.map((parent=>fluid.C3_precedence(parent,defs,visited)));const merged=fluid.C3_merge(precLists);return merged};class HierarchyResolver{constructor(layerFetcher){this.layerFetcher=layerFetcher||(()=>{});this.flatDefs=Object.create(null);this.unavailableLayers=Object.create(null)}storeParents(layer,rootLayer){return layer.$layers.map((layerName=>{if(layerName===rootLayer){this.unavailableLayers[layerName]=fluid.unavailable(`Layer name ${layerName} circularly refers to layer ${rootLayer}`);return{$layers:[]}}else{return this.storeLayer(layerName,rootLayer)}}))}storeLayer(layerName,rootLayer){let layerDef=this.flatDefs[layerName];if(!layerDef){this.flatDefs[layerName]="in progress";const layer=fluid.readLayer(layerName,true).value;if(fluid.isUnavailable(layer)){this.unavailableLayers[layerName]=layer;this.layerFetcher(layerName);layerDef={$layers:[]}}else{const readerExpanded=fluid.readerExpandLayer(layer.raw);this.storeParents(readerExpanded,rootLayer||layerName);layerDef=readerExpanded}}this.flatDefs[layerName]=layerDef;return layerDef}resolveHierarchyRound=function(layerHierarchy,layerNames){const newCoOccurrences=fluid.resolveCoOccurrences(layerHierarchy);newCoOccurrences.map((layerName=>this.storeLayer(layerName)));layerNames.unshift(...newCoOccurrences);return newCoOccurrences.length>0};resolve(layerNames){const useLayerNames=layerNames.filter((layerName=>!this.unavailableLayers[layerName]));while(true){const order=fluid.C3_precedence_parents(useLayerNames,this.flatDefs).reverse();if(this.resolveHierarchyRound(order,useLayerNames)){continue}const mergeRecords=order.map(((oneLayerName,i)=>({mergeRecordType:"def",mergeRecordName:oneLayerName,priority:fluid.mergeRecordTypes.def-i,layer:this.flatDefs[oneLayerName]}))).concat({mergeRecordType:"defParents",mergeRecordName:"defParents",priority:fluid.mergeRecordTypes.defParents,layer:{$layers:order}});const merged={};return{mergeRecords:mergeRecords,merged:merged,layerMap:fluid.mergeLayerRecords(merged,mergeRecords)}}}}fluid.HierarchyResolver=HierarchyResolver;fluid.hasLayer=function(layer,layerName){return layer.$layers&&layer.$layers.includes(layerName)};fluid.layerLoaders={vue:"fluid.loadSFC",js:"fluid.loadLayer"};fluid.importMap={};fluid.loadImportMap=function(importMap){fluid.transform(importMap,(({path:path},layerName)=>{const url=fluid.module.resolvePath(path);fluid.importMap[layerName]={loadStyle:"sfc",url:url};const extension=url.split(".").pop();const loader=fluid.layerLoaders[extension];if(!loader){fluid.fail("Can't find loader for file ",url)}else{fluid.invokeGlobalFunction(loader,[layerName,url])}}))};fluid.acquireImports=function(importMap){const useImportMap=fluid.transform(importMap,(path=>({path:path})));fluid.loadImportMap(useImportMap)};fluid.makeComponentCreator=function(componentName){const creator=function(){return fluid.initFreeComponent(componentName,...arguments)};const existing=fluid.getGlobalValue(componentName);if(existing){Object.assign(creator,existing)}fluid.setGlobalValue(componentName,creator)};fluid.defBuffer=null;fluid.writeDef=function(layerName,layer){console.log("**** writeDef for layer ",layerName);fluid.acquireImports(layer.$importMap);fluid.writeLayer(layerName,layer);fluid.makeComponentCreator(layerName)};fluid.def=function(layerName,layer){if(layer===undefined){return fluid.readLayer(layerName).value.raw}else{if(fluid.defBuffer){fluid.makeComponentCreator(layerName);fluid.defBuffer[layerName]=layer}else{fluid.writeDef(layerName,layer)}}};fluid.startCaptureBufferDefs=function(defBuffer){fluid.defBuffer=defBuffer};fluid.endCaptureBufferDefs=function(){fluid.defBuffer=null};fluid.writeBufferDefs=function(defBuffer){fluid.each(defBuffer,((layer,layerName)=>fluid.writeDef(layerName,layer)))};fluid.inEvaluationMarker=Object.freeze({__CURRENTLY_IN_EVALUATION__:true});fluid.def("fluid.function",{$variety:"framework"});fluid.invokeGradedFunction=function(name,spec){const defaults=fluid.readLayer(name).value;if(!defaults||fluid.isUnavailable(name)||!defaults.argumentMap||!fluid.hasGrade(defaults,"fluid.function")){fluid.fail("Cannot look up name "+name+" to a function with registered argumentMap - got defaults ",defaults)}const args=[];fluid.each(defaults.argumentMap,(function(value,key){args[value]=spec[key]}));return fluid.invokeGlobalFunction(name,args)};const charStart="(?:[\\w\\u00c0-\\uFFFF*_-";fluid.simpleCSSMatcher={regexp:new RegExp("([#.]?)("+charStart+"]|\\\\.)+)","g"),charToTag:{"":"tag","#":"id",".":"clazz"}};fluid.ILSSMatcher={regexp:new RegExp("([&#]?)("+charStart+"]|\\.|\\/)+)","g"),charToTag:{"":"context","&":"context","#":"id"}};const childSeg=new RegExp("\\s*(>)?\\s*","g");fluid.parseSelector=function(selstring,strategy){const togo=[];selstring=selstring.trim();const regexp=strategy.regexp;regexp.lastIndex=0;let lastIndex=0;while(true){const atNode=[];let first=true;while(true){const segMatch=regexp.exec(selstring);if(!segMatch){break}if(segMatch.index!==lastIndex){if(first){fluid.fail("Error in selector string - cannot match child selector expression starting at "+selstring.substring(lastIndex))}else{break}}const thisNode={};const text=segMatch[2];const targetTag=strategy.charToTag[segMatch[1]];if(targetTag){thisNode[targetTag]=text}atNode[atNode.length]=thisNode;lastIndex=regexp.lastIndex;first=false}childSeg.lastIndex=lastIndex;const fullAtNode={predList:atNode};const childMatch=childSeg.exec(selstring);if(!childMatch||childMatch.index!==lastIndex){fluid.fail("Error in selector string - can not match child selector expression at "+selstring.substring(lastIndex))}if(childMatch[1]===">"){fullAtNode.child=true}togo[togo.length]=fullAtNode;if(childSeg.lastIndex>=selstring.length){break}lastIndex=childSeg.lastIndex;regexp.lastIndex=childSeg.lastIndex}return togo};fluid.percStringTemplate=function(template,values){let keys=Object.keys(values);keys=keys.sort(((keya,keyb)=>keyb.length-keya.length));for(let i=0;i<keys.length;++i){const key=keys[i];const templatePlaceholder="%"+key;const replacementValue=values[key];let indexOfPlaceHolder=-1;while((indexOfPlaceHolder=template.indexOf(templatePlaceholder))!==-1){template=template.slice(0,indexOfPlaceHolder)+replacementValue+template.slice(indexOfPlaceHolder+templatePlaceholder.length)}}return template};fluid.parseContextReference=function(reference,index){index=index||0;const endcpos=reference.indexOf("}",index+1);let context=reference.substring(index+1,endcpos);const colpos=reference.indexOf(":");let name;if(colpos!==-1){name=reference.substring(colpos+1);reference=reference.substring(0,colpos)}let path=reference.substring(endcpos+1,reference.length);if(path.charAt(0)==="."){path=path.substring(1)}const cspace=context.indexOf(" ");let selector;if(cspace!==-1){selector=fluid.parseSelector(context.substring(cspace+1),fluid.ILSSMatcher);context=context.substring(0,cspace)}return{context:context,path:path,name:name,selector:selector}};const atTemplateRE=/@\{((?:.)+?)\}/g;fluid.parseAtStringTemplate=function(template){const tokens=[];let lastIndex=0;let match;const upgradeSimpleKey=key=>({context:"self",path:key});while(match=atTemplateRE.exec(template)){const index=match.index;if(index>lastIndex){tokens.push(template.slice(lastIndex,index))}const exp=match[1].trim();if(exp.startsWith("{")){const endIndex=template.indexOf("}",atTemplateRE.lastIndex);if(endIndex===-1){throw new Error("Unmatched '{' in template: "+template)}const fullBody=template.slice(index+2,endIndex);tokens.push({raw:fullBody,parsed:fluid.parseContextReference(fullBody)});atTemplateRE.lastIndex=endIndex+1}else{tokens.push({raw:exp,parsed:upgradeSimpleKey(exp)})}lastIndex=atTemplateRE.lastIndex}if(lastIndex<template.length){tokens.push(template.slice(lastIndex))}return tokens};fluid.atStringTemplate=function(template,model){const tokens=fluid.parseAtStringTemplate(template);const segs=tokens.map((token=>typeof token==="string"?token:fluid.get(model,token.parsed.path,"error")));return segs.join("")};fluid.cacheOptions={cache:"no-cache"};fluid.fetch=function(url,options,strategy){const togo=signal(fluid.unavailable({message:`Pending I/O for URL ${url}`,variety:"I/O"}));const assignResult=data=>{try{togo.value=data}catch(e){fluid.fail("Error assigning I/O result: ",e);throw e}};fetch(url,{...options,...fluid.cacheOptions}).then((response=>{if(!response.ok){togo.value=fluid.unavailable({message:`HTTP error ${response.status} for URL ${url}`,variety:"error"})}else{return strategy(response)}})).then((data=>{if(!fluid.isErrorUnavailable(togo.peek())){if(options?.delay){window.setTimeout((()=>assignResult(data)),options.delay)}else{assignResult(data)}}})).catch((err=>{togo.value=fluid.unavailable({message:`I/O failure for URL ${url} - ${err}`,variety:"error"})}));return togo};fluid.fetchText=function(url,options){return fluid.fetch(url,options,(async response=>response.text()))};fluid.fetchJSON=function(url,options){return fluid.fetch(url,options,(async response=>response.json()))};fluid.siteToPromise=function(component,path){const pathSignal=fluid.getForComponent(component[$m],path);return fluid.signalToPromise(pathSignal)}};var fluid=fluid||{};$fluidScope(fluid);"use strict";const $fluidILScope=function(fluid){var{signal:signal,computed:computed,effect:effect,untracked:untracked}=preactSignalsCore;const $m=fluid.metadataSymbol;const $t=fluid.proxySymbol;const $u=fluid.unavailableSymbol;fluid.componentConstructor=function(){};fluid.shadow=function(){};Object.defineProperty(fluid.componentConstructor,"name",{value:"fluid.componentConstructor"});fluid.isComponent=function(obj){return obj&&obj.constructor===fluid.componentConstructor};fluid.isShadow=function(obj){return obj&&obj.constructor===fluid.shadow};fluid.freshComponent=function(props,shadow){const instance=Object.create(fluid.componentConstructor.prototype);fluid.each(props,((value,key)=>{instance[key]=signal(value)}));if(!instance.$id){const id=fluid.allocateGuid();instance.$id=id}shadow=shadow||Object.create(fluid.shadow.prototype);shadow.unavailableLayers=shadow.unavailableLayers||signal(Object.create(null));shadow.that=instance;instance[$m]=shadow;return instance};fluid.dumpLayerNames=function(that){return" layerNames: "+JSON.stringify(that.$layers)};fluid.dumpThat=function(that){return`{ id: ${that.$id} ${fluid.dumpLayerNames(that)}`};fluid.dumpThatStack=function(thatStack){const togo=fluid.transform(thatStack,(function(that){const path=that[$m].path;return fluid.dumpThat(that)+(path?" - path: "+path:"")}));return togo.join("\n")};fluid.dumpComponentPath=function(that){const path=that[$m].path;return path||"** no path registered for component **"};fluid.dumpComponentAndPath=function(that){return"component "+fluid.dumpThat(that)+" at path "+fluid.dumpComponentPath(that)};fluid.visitComponentsForMatching=function(shadow,options,visitor){options=Object.assign({visited:{}},options);const shadowStack=[shadow];const scopeTick=shadow.scopeTick.value;const scopes=[shadow.ownScope];const visitorWrapper=function(thisShadow,xName,segs){shadowStack.length=1;scopes.length=1;for(let i=0;i<segs.length;++i){const childShadow=shadowStack[i].childComponents[segs[i]];shadowStack[i+1]=childShadow;const scopeTick=childShadow.scopeTick.value;scopes[i+1]=childShadow.ownScope}return visitor(thisShadow,shadowStack,scopes,segs,segs.length)};fluid.visitComponentChildren(shadow,visitorWrapper,options,[])};fluid.visitComponentChildren=function(shadow,visitor,options,segs=[]){for(const name in shadow.childComponents){const childShadow=shadow.childComponents[name];if(!childShadow.that){continue}if(options.visited[childShadow.that.$id]){continue}segs.push(name);options.visited[childShadow.that.$id]=true;visitor(childShadow,name,segs,segs.length-1);if(!options.flat){fluid.visitComponentChildren(childShadow,visitor,options,segs)}segs.pop()}};fluid.queryILSelector=function(root,selector,flat=false){const parsed=typeof selector==="string"?fluid.parseSelector(selector,fluid.ILSSMatcher):selector;const togo=[];let unavailableComponents=null;fluid.visitComponentsForMatching(root[$m],{flat:flat},(function(shadow,shadowStack,scopes){const thisUnavailable=fluid.checkUnavailableComponent(shadow);if(thisUnavailable){unavailableComponents=fluid.mergeUnavailable(unavailableComponents,thisUnavailable)}if(fluid.matchILSelector(parsed,shadowStack,scopes,1)){togo.push(fluid.proxyMat(shadow.computer,shadow,[]))}}));return unavailableComponents||togo};fluid.liveQueryILSelector=function(root,selector,flat=false){return computed((()=>fluid.queryILSelector(root,selector,flat)))};fluid.matchILSelector=function(selector,shadowStack,scopes,i){let thatpos=shadowStack.length-1;let selpos=selector.length-1;while(true){const isChild=selector[selpos].child;const mustMatchHere=thatpos===shadowStack.length-1||isChild;const that=shadowStack[thatpos];const selel=selector[selpos];let match=true;for(let j=0;j<selel.predList.length;++j){const pred=selel.predList[j];const context=pred.context;if(context&&context!=="*"&&!Object.prototype.hasOwnProperty.call(scopes[thatpos],context)){match=false;break}if(pred.id&&that.id!==pred.id){match=false;break}}if(selpos===0&&thatpos>i&&mustMatchHere&&isChild){match=false}if(match){if(selpos===0){return true}--thatpos;--selpos}else{if(mustMatchHere){return false}else{--thatpos}}if(thatpos<i){return false}}return false};fluid.contextName=1;fluid.memberName=2;fluid.layerNamesToScope=function(targetScope,layerNames,shadow){fluid.clear(targetScope);fluid.each(layerNames,(function(layerName){if(!fluid.isReferenceOrExpander(layerName)){const def=fluid.readLayer(layerName).peek().raw;if(def&&def.$variety!=="framework"){const rec={value:shadow,priority:fluid.contextName};targetScope[layerName]=rec;targetScope[fluid.computeNickName(layerName)]=rec}if(layerName==="fluid.resolveRoot"){shadow.resolveRoot=true}}}));return targetScope};fluid.applyToScope=function(scope,key,shadow,priority){const existing=scope[key];if(!existing||priority===fluid.memberName){scope[key]={value:shadow,priority:priority}}};fluid.cacheLayerScopes=function(parentShadow,shadow){const rootComponent=shadow.instantiator.rootComponent;shadow.childrenScope=Object.create(parentShadow?parentShadow.variableScope:null);shadow.childrenScope[$m]="childrenScope-"+shadow.path;shadow.ownScope=Object.create(shadow.childrenScope);shadow.ownScope[$m]="ownScope-"+shadow.path;shadow.variableScope=Object.create(shadow.ownScope);shadow.variableScope[$m]="variableScope-"+shadow.path;shadow.ownScopeTick=signal(0);shadow.scopeTick=parentShadow?computed((()=>shadow.ownScopeTick.value+parentShadow.ownScopeTick.value)):shadow.ownScopeTick;return effect((function scopeEffect(){const childOfRoot=!shadow.parentShadow||shadow.parentShadow.that===rootComponent;const layers=shadow.computer?.value?.$layers||[];fluid.layerNamesToScope(shadow.ownScope,layers,shadow);if(typeof shadow.memberName==="string"&&!childOfRoot){fluid.applyToScope(shadow.ownScope,shadow.memberName,shadow,fluid.memberName)}const ownScope=Object.getOwnPropertyNames(shadow.ownScope);ownScope.forEach((context=>{const rec=shadow.ownScope[context];if(shadow.parentShadow&&!childOfRoot){fluid.applyToScope(shadow.parentShadow.childrenScope,context,rec.value,rec.priority)}if(shadow.resolveRoot){fluid.applyToScope(rootComponent[$m].childrenScope,context,rec.value,rec.priority);rootComponent[$m].ownScopeTick.value=rootComponent[$m].ownScopeTick.peek()+1}}));shadow.ownScopeTick.value=shadow.ownScopeTick.peek()+1}))};fluid.clearScope=function(parentShadow,childShadow){const ownScope=Object.getOwnPropertyNames(childShadow.ownScope);ownScope.forEach((context=>{if(parentShadow.childrenScope[context].value===childShadow){delete parentShadow.childrenScope[context]}}));childShadow.ownScopeTick.value=childShadow.ownScopeTick.peek()+1};fluid.clearComponentIndexes=function(instantiator,destroyRec){const shadow=destroyRec.shadow;fluid.clearScope(shadow,destroyRec.childShadow,destroyRec.name);delete instantiator.pathToComponent[destroyRec.childPath];delete shadow.childComponents[destroyRec.name]};fluid.doDestroy=function(instantiator,destroyRec){const shadow=destroyRec.childShadow,that=destroyRec.child;fluid.each(shadow.injectedPaths,(function(troo,injectedPath){const segs=fluid.parsePath(injectedPath);const parentPath=segs.slice(0,-1);const otherShadow=instantiator.pathToComponent[parentPath];instantiator.clearComponent(otherShadow,fluid.peek(segs),that)}));fluid.clearComponentIndexes(instantiator,destroyRec);shadow.lifecycleStatus="destroyed";const child=destroyRec.childShadow.that;fluid.fireEvent(child,"afterDestroy",[child,destroyRec.name,destroyRec.shadow.that])};fluid.rapidDispose=function(shadow){shadow.oldShadowMap=shadow.shadowMap;shadow.shadowMap=Object.create(null);fluid.disposeLayerEffects(shadow)};fluid.instantiator=function(){const that={pathToComponent:{}};function recordComponent(parentShadow,shadow,name,created){shadow.instantiator=that;const path=parentShadow?fluid.composeSegment(parentShadow.path,name):name;if(created){shadow.path=path;shadow.memberName=name;shadow.parentShadow=parentShadow;shadow.childComponents={};shadow.frameworkEffects={};shadow.frameworkEffects.scopeEffect=fluid.cacheLayerScopes(parentShadow,shadow);shadow.frameworkEffects.availabilityTracker=fluid.trackComponentAvailability(shadow)}else{shadow.injectedPaths=shadow.injectedPaths||{};shadow.injectedPaths[path]=true;const contextHash=shadow.contextHash.value;const keys=fluid.keys(contextHash);fluid.remove_if(keys,(function(key){return contextHash&&contextHash[key]===fluid.memberName}));keys.push(name);keys.forEach((function(context){if(!parentShadow.scope.hasOwnProperty(context)){parentShadow.scope[context]=shadow}}))}if(that.pathToComponent[path]){fluid.fail("Error during instantiation - path "+path+" which has just created component "+fluid.dumpThat(shadow)+" has already been used for component "+fluid.dumpThat(that.pathToComponent[path])+" - this is a circular instantiation or other oversight."+" Please clear the component using instantiator.clearComponent() before reusing the path.")}that.pathToComponent[path]=shadow}that.recordKnownComponent=function(parentShadow,shadow,name,created){const existing=parentShadow.childComponents[name];if(existing){if(existing!==shadow){fluid.fail("Attempt to register component at path ",existing.path," which has already been used for component ",existing)}}else{parentShadow.childComponents[name]=shadow;recordComponent(parentShadow,shadow,name,created)}};that.allocateSimpleComponent=function(parentShadow,name,props){const fresh=fluid.freshComponent(props);if(parentShadow===null){recordComponent(null,fresh[$m],"",true)}else{that.recordKnownComponent(parentShadow,fresh[$m],name,true)}return fresh};that.clearComponent=function(shadow,name,childShadow,destroyRecs,nested,path){destroyRecs=destroyRecs||[];path=path||shadow.path;const childPath=fluid.composeSegment(path,name);childShadow=childShadow||shadow.childComponents[name];const created=childShadow.path===childPath;const destroyRec={childShadow:childShadow,name:name,shadow:shadow,childPath:childPath};if(created){if(fluid.isDestroyedShadow(childShadow)){fluid.fail('Cannot destroy component which is already in status "'+childShadow.lifecycleStatus+'"')}childShadow.lifecycleStatus="destroying";fluid.disposeEffects(childShadow.frameworkEffects);childShadow.effectScheduler.dispose();fluid.rapidDispose(childShadow);fluid.each(childShadow.childComponents,((gchildShadow,memberName)=>that.clearComponent(childShadow,memberName,gchildShadow,destroyRecs,true)));destroyRecs.push(destroyRec)}else{fluid.remove_if(childShadow.injectedPaths,(function(troo,path){return path===childPath}));fluid.clearComponentIndexes(that,destroyRec)}if(!nested){destroyRecs.forEach((function(destroyRec){fluid.doDestroy(that,destroyRec)}))}};return Object.assign(that,fluid.freshComponent())};fluid.globalInstantiator=fluid.instantiator();fluid.constructRootComponents=function(instantiator){instantiator.rootComponent=instantiator.allocateSimpleComponent(null,"",{$layers:["fluid.rootComponent"]});const rootShadow=instantiator.rootShadow=instantiator.rootComponent[$m];instantiator.resolveRootComponent=instantiator.allocateSimpleComponent(rootShadow,"resolveRootComponent",{$layers:["fluid.component"]});const resolveRootShadow=instantiator.resolveRootComponent[$m];resolveRootShadow.childrenScope=rootShadow.childrenScope};fluid.computeNickName=function(layerName){const segs=fluid.parsePath(layerName);return fluid.peek(segs)};fluid.isDestroyedShadow=function(shadow,strict){return shadow.lifecycleStatus==="destroyed"||!strict&&shadow.lifecycleStatus==="destroying"};fluid.isDestroyed=function(that,strict){const shadow=that?.[$t]?.shadow||that[$m];return fluid.isDestroyedShadow(shadow,strict)};fluid.computeGlobalMemberName=function(layerName,id){const nickName=fluid.computeNickName(layerName);return nickName+"-"+id};fluid.upgradePrimitiveFunc=function(rec,key){if(rec&&fluid.isPrimitive(rec)){const togo={};togo[key||"func"]=rec;togo.args=fluid.NO_ARGUMENTS;return togo}else{return rec}};fluid.compactStringToRec=function(string,type){const openPos=string.indexOf("(");const closePos=string.indexOf(")");if(openPos===-1^closePos===-1||openPos>closePos){fluid.fail("Badly-formed compact "+type+" record without matching parentheses: "+string)}if(openPos!==-1&&closePos!==-1){const trail=string.substring(closePos+1);if(trail.trim()!==""){fluid.fail("Badly-formed compact "+type+" record "+string+" - unexpected material following close parenthesis: "+trail)}const prefix=string.substring(0,openPos);const body=string.substring(openPos+1,closePos).trim();const args=body===""?[]:body.split(",").map((str=>str.trim())).map(fluid.coerceToPrimitive);const togo=fluid.upgradePrimitiveFunc(prefix,null);togo.args=args;return togo}else if(type==="$method"||type==="$compute"){return{func:string}}else{fluid.fail("Unrecognised compact record "+string+" with no arguments with type ",type)}return string};fluid.fetchContextReferenceSoft=function(context,segs,shadow){const togo=signal();effect((()=>{const scopeTick=shadow.scopeTick.value;const targetShadow=shadow.variableScope[context]?.value;const value=targetShadow&&fluid.deSignal(fluid.getForComponent(targetShadow,segs));if(!fluid.isUnavailable(value)&&value!==togo.peek()){togo.value=value;togo.$component=targetShadow.that}}));return togo};fluid.resolveContext=function(context,shadow,resolver){const contextUnavailable=()=>fluid.unavailable({message:"Cannot resolve context "+context,errorSite:{shadow:shadow}});return computed((()=>{if(context==="self"){return shadow.that}else if(context==="/"){return shadow.instantiator.rootComponent}else if(context==="global"){return fluid.global}else if(context==="$oldValue"){return fluid.OldValue}else{const local=resolver?resolver(context):fluid.NoValue;if(local===fluid.NoValue){const scopeTick=shadow.scopeTick.value;const resolvedRec=shadow.variableScope[context];if(resolvedRec){const resolved=resolvedRec.value;return resolved instanceof fluid.shadow?resolved.computer.value||contextUnavailable():resolved}else{return contextUnavailable()}}else{return local}}}))};fluid.getForComponent=function(shadow,path){const segs=fluid.pathToSegs(path);if(segs.length===0){return shadow.computer}else{return fluid.getThroughSignals(shadow.computer,segs,{site:{shadow:shadow,segs:segs},$variety:"$ref"})}};fluid.pathToLive=function(shadow,path){const segs=fluid.pathToSegs(path);let existing=fluid.get(shadow.liveLayer,segs);if(!existing){const oldValue=fluid.deSignal(fluid.getForComponent(shadow,path).value);const valueSignal=signal(oldValue);fluid.set(shadow.liveLayer,segs,valueSignal);console.log("Upgrading path ",path," to live");shadow.potentia.value=Object.assign({},shadow.potentia.value);return valueSignal}else{return existing}};fluid.setForComponent=function(component,path,value){const segs=fluid.pathToSegs(path),shadow=component[$m];const reactiveSegs=fluid.findReactiveRoot(shadow.shadowMap,segs);const existing=fluid.pathToLive(shadow,reactiveSegs||segs);const existingValue=existing.peek();const surplusSegs=reactiveSegs&&segs.slice(reactiveSegs.length,segs.length);const updated=reactiveSegs?fluid.setImmutable(existingValue,surplusSegs,value):value;if(updated!==existingValue){existing.value=updated;if(reactiveSegs&&fluid.isUserLayer(fluid.peek(component.$layers))){const layerName=fluid.renderSite({shadow:shadow,segs:reactiveSegs});fluid.pushHistory({type:"updateLayer",oldValue:existingValue,newValue:updated,layerName:layerName})}}return existing};fluid.fetchWriteableLiveSignal=function(ref){const site=fluid.parseSite(ref);const getter=fluid.getForComponent(site.shadow,site.path);const togo=signal(fluid.unavailable("Not initialised"));togo.write=value=>{const oldValue=getter.peek();if(value!==oldValue){fluid.setForComponent(site.shadow.that,site.path,value)}};togo.reader=effect((()=>togo.value=getter.value));togo.writer=fluid.effect(togo.write,[togo.value]);togo.dispose=()=>{togo.reader.dispose();togo.writer.dispose()};return togo};fluid.fetchContextReference=function(ref,shadow,segs,resolver){const parsed=fluid.isPrimitive(ref)?fluid.parseContextReference(ref):ref;const refComputer=computed((function fetchContextReference(){const target=fluid.resolveContext(parsed.context,shadow,resolver).value;if(fluid.isUnavailable(target)){return fluid.mergeUnavailable(fluid.unavailable({message:"Cannot fetch path "+parsed.path+" of context "+parsed.context+" which didn't resolve",path:shadow.path}),target)}else if(fluid.isComponent(target)){if(parsed.selector){const list=fluid.queryILSelector(target,parsed.selector);if(parsed.path){return list.map((listEl=>fluid.getForComponent(listEl,parsed.path)))}else{return list}}else{return fluid.getForComponent(target[$m],parsed.path)}}else{return fluid.get(target,parsed.path,"unavailable")}}));return Object.assign(refComputer,{parsed:parsed,site:{shadow:shadow,segs:segs},$variety:"$contextRef"})};fluid.renderComputedStringTemplate=function(tokens,shadow){if(tokens.length===0){return""}else if(tokens.length===1&&typeof tokens[0]==="string"){return tokens[0]}else{const liveTokens=tokens.map((token=>fluid.isPrimitive(token)?token:fluid.fetchContextReference(token.parsed,shadow)));const togo=fluid.computed((function(...tokens){return tokens.join("")}),liveTokens);togo.$tokens=liveTokens;return togo}};fluid.deSignalToSite=function(ref,shadowCursor){while(fluid.isSignal(ref)){if(ref.$variety==="$ref"){const shadowMap=ref.site.shadow.shadowMap;shadowCursor={ref:ref,shadow:ref.site.shadow,segs:ref.site.segs,shadowRec:fluid.get(shadowMap,ref.site.segs)}}else if(ref.$variety==="$component"&&!fluid.isUnavailable(ref.value)){shadowCursor={shadow:ref.shadow,segs:[],shadowRec:ref.shadow.shadowMap};break}else{shadowCursor={}}ref=ref.value}return{...shadowCursor,value:ref}};fluid.findReactiveRoot=function(shadowMap,segs){let current=shadowMap;for(let i=0;i<segs.length;++i){const seg=segs[i];const shadowRec=current?.[seg];if(shadowRec?.[$m]?.reactiveRoot){return segs.slice(0,i+1)}current=shadowRec}return null};fluid.transferShadowMap=function(shadowMap,layerMap){Object.entries(layerMap).forEach((([key,value])=>{if(key!==$m){const rec=shadowMap[key]={};fluid.transferShadowMap(rec,value)}}));if(layerMap?.[$m]?.reactiveRoot){const rec=fluid.getRecInsist(shadowMap,[$m]);rec.reactiveRoot=true}};fluid.flattenSignals=function(root,strategy,shadowRecIn){const{value:value,shadowRec:shadowRec,segs:segs,shadow:shadow,ref:ref}=fluid.deSignalToSite(root,shadowRecIn);if(fluid.isUnavailable(value)){return strategy==="methodStrategy"?undefined:value}else{if(fluid.isSignal(value)){if(value.$variety==="$component"){return fluid.proxyMat(value,value.shadow,[])}else{fluid.fail("Unexpected unresolved signal value from fluid.deSignalToSite",value)}}else if(fluid.isPrimitive(value)||!fluid.isPlainObject(value)){return value}}const inReactiveRoot=shadow&&fluid.findReactiveRoot(shadow.shadowMap,segs);if(inReactiveRoot&&(strategy==="methodStrategy"||strategy==="effectStrategy")){return fluid.proxyMat(ref,shadow,segs)}else{const mapper=(member,key)=>{const togo=fluid.flattenSignals(member,strategy,{shadow:shadow,segs:segs.concat([key]),shadowRec:shadowRec?.[key]});return togo};if(shadowRec?.[$m]?.hasSignalChild){if(fluid.isArrayable(value)){return value.map(mapper)}else{return fluid.transform(value,mapper)}}else{return value}}};fluid.resolveArgMaterial=function(material,shadow,segs,resolver){if(fluid.isPrimitive(material)){return fluid.isILReference(material)?fluid.fetchContextReference(material,shadow,segs,resolver):material}else if(Array.isArray(material)){return material.map(((member,key)=>fluid.resolveArgMaterial(member,shadow,[...segs,key],resolver)))}else if(fluid.isPlainObject(material,true)){return fluid.transform(material,((member,key)=>fluid.resolveArgMaterial(member,shadow,[...segs,key],resolver)))}else{return material}};fluid.makeArgResolver=function(){const that={backing:[],resolve:function(context){const argNum=+context;return Number.isInteger(+argNum)?argNum in that.backing?that.backing[argNum]:fluid.unavailable({message:"No argument at position "+context+" was supplied to this method call"}):fluid.NoValue}};return that};const methodFlattener=root=>fluid.flattenSignals(root,"methodStrategy");const effectFlattener=root=>fluid.flattenSignals(root,"effectStrategy");fluid.expandMethodRecord=function(record,shadow,segs){const funcSignal=fluid.resolveFuncReference(record,shadow,segs);const captureSegs=[...segs];const resolveFunc=()=>{const resolvedFunc=fluid.deSignal(funcSignal);if(fluid.isUnavailable(resolvedFunc)){fluid.fail("Couldn't invoke method at path ",captureSegs," of component ",shadow,resolvedFunc)}return resolvedFunc};let togo;if(record.args){const resolver=fluid.makeArgResolver();resolver.record=record;const argRecs=fluid.makeArray(record.args);togo=function invokeMethod(...args){resolver.backing=args;const resolvedArgs=fluid.resolveArgMaterial(argRecs,shadow,segs,resolver.resolve);const flatArgs=resolvedArgs.map(methodFlattener);return resolveFunc().apply(shadow,flatArgs)}}else{togo=function applyDirectMethod(...args){return resolveFunc().apply(shadow.that,[shadow.that,...args])}}return togo};fluid.resolveFuncReference=function(rec,shadow,segs){return fluid.isILReference(rec.func)?fluid.fetchContextReference(rec.func,shadow,segs):computed((()=>{let func=rec.func;if(typeof func==="string"){func=fluid.getGlobalValue(rec.func)}return func||fluid.unavailable(`Unable to resolve reference to function from ${rec.func||rec}`)}))};fluid.resolveFuncRecord=function(rec,shadow,segs){const func=fluid.resolveFuncReference(rec,shadow,segs);const args=fluid.makeArray(rec.args);const resolvedArgs=fluid.resolveArgMaterial(args,shadow,[...segs,"args"]);return{func:func,resolvedArgs:resolvedArgs}};fluid.expandComputeRecord=function(record,shadow,segs){const{func:func,resolvedArgs:resolvedArgs}=fluid.resolveFuncRecord(record,shadow,[...segs,"$compute"]);const togo=fluid.computed(func,resolvedArgs,{flattenArg:fluid.flattenSignals});togo.$variety="$compute";return togo};fluid.expandCompactSubelement=function(subel){return typeof subel==="string"?fluid.compactStringToRec(subel,"$method"):subel};fluid.expandBindableRecord=function(record,shadow,segs){const bindSegs=[...segs,"$bindable","bind"];const expBind=fluid.expandCompactSubelement(record.bind);const{func:func,resolvedArgs:resolvedArgs}=fluid.resolveFuncRecord(expBind,shadow,bindSegs);const unbindSegs=[...segs,"$bindable","unbind"];const expUnbind=fluid.expandCompactSubelement(record.unbind);const{func:unbindFuncSignal,resolvedArgs:unbindResolvedArgs}=expUnbind?fluid.resolveFuncRecord(expUnbind,shadow,unbindSegs):{};const unbindArgsResolver=context=>context==="boundValue"?togo.value:fluid.NoValue;let selfObserveEffect;const unbind=function(){const unbindArgs=unbindResolvedArgs?fluid.resolveArgMaterial(unbindResolvedArgs,shadow,[...unbindSegs,"args"],unbindArgsResolver):[togo.value];if(unbindFuncSignal&&!fluid.isUnavailable(unbindFuncSignal.value)){unbindFuncSignal.value(unbindArgs)}};const dispatcher=(func,designalArgs,unavailable,oldValue)=>{if(unavailable){if(!fluid.isUnavailable(oldValue)){unbind()}return unavailable}else{if(fluid.isUnavailable(oldValue)){return func.apply(null,designalArgs)}else{return oldValue;console.log("Ignoring attempt to rebind bindable value at ",shadow.path,bindSegs)}}};const togo=fluid.computed(func,resolvedArgs,{dispatcher:dispatcher,flattenArg:fluid.flattenSignals});togo.$variety="$bindable";togo.dispose=()=>{unbind();if(selfObserveEffect){selfObserveEffect.dispose()}};togo.selfObserve=()=>{if(!selfObserveEffect){selfObserveEffect=effect((()=>togo.value))}};return togo};fluid.expandEffectRecord=function(record,shadow,segs){const{func:funcSignal,resolvedArgs:resolvedArgs}=fluid.resolveFuncRecord(record,shadow,[...segs,"$effect"]);const func=fluid.deSignal(funcSignal);if(fluid.isUnavailable(func)){return func}else{const togo=fluid.effect(func,resolvedArgs,{flattenArg:effectFlattener});togo.$variety="$effect";console.log("Allocated effect "+togo.effectId+" at path "+segs.join(".")+" at component "+shadow.path);return togo}};fluid.expandLinkageRecord=function(record,shadow,segs){const site={shadow:shadow,segs:segs};const siteString=fluid.renderSite(site);const array=fluid.isArrayable(record);const togo=fluid.effect((()=>{if(array){record.forEach(((linkage,i)=>fluid.registerCoOccurrence(`${siteString}-${i}`,linkage)))}else{fluid.registerCoOccurrence(siteString,record)}}),null,{onDispose:()=>{if(array){record.forEach(((linkage,i)=>fluid.deregisterCoOccurrence(`${siteString}-${i}`)))}else{fluid.deregisterCoOccurrence(siteString,record)}}});togo.$variety="$linkage";return togo};fluid.expandReactiveRecord=function(record,shadow,segs){const togo=typeof record==="string"?fluid.fetchContextReference(record,shadow,segs):signal(record);togo.$variety="$reactiveRoot";return togo};fluid.pushSubcomponentPotentia=function(shadow,memberName,expanded,scope,source){const subLayerRecord={mergeRecordType:"subcomponent",mergeRecordName:`${source}`,layer:expanded};return fluid.pushPotentia(shadow,memberName,[subLayerRecord],expanded.$layers,scope)};fluid.expandComponentRecord=function(record,shadow,segs,key){const expanded=fluid.readerExpandLayer(record);const sourceLayer=fluid.get(shadow.layerMap,[...segs,$m,"source"]);const forRecord=expanded.$for;const ifRecord=expanded.$if;if(forRecord){const sourceSignal=fluid.fetchContextReference(forRecord.source,shadow);let listShadow;const componentList=fluid.computed((source=>{const allKeys=[];const pushSubcomponentPotentia=function(value,subKey){allKeys.push(""+subKey);const scope={};if(forRecord.value!==undefined){scope[forRecord.value]={value:value,source:sourceSignal,sourcePath:subKey}}if(forRecord.key!==undefined){scope[forRecord.key]={value:subKey,source:sourceSignal,sourcePath:subKey}}return fluid.pushSubcomponentPotentia(listShadow,subKey,expanded,scope,sourceLayer)};let togo;if(fluid.isArrayable(source)){togo=source.map(pushSubcomponentPotentia)}else if(fluid.isPlainObject(source)){togo=Object.entries(source).map((([key,value])=>pushSubcomponentPotentia(value,key)))}else if(fluid.isUnavailable(source)){return source}else{return fluid.unavailable({cause:"Unable to iterate over object ${source} to produce a ComponentList",errorSite:sourceSignal.site})}const goneKeys=Object.keys(listShadow.childComponents).filter((k=>!allKeys.includes(k)));const goneShadows=goneKeys.map((k=>listShadow.childComponents[k]));goneShadows.forEach((shadow=>shadow.potentia.value=fluid.emptyPotentia));return togo.map((computer=>fluid.proxyMat(computer,computer.shadow,[])))}),[sourceSignal]);componentList.$variety="$componentList";componentList.$source=sourceSignal;const listLayer={$layers:["fluid.componentList"],list:componentList};const listComputer=fluid.pushSubcomponentPotentia(shadow,key,listLayer);listShadow=listComputer.shadow;return listComputer}else if(ifRecord){const togo=signal();let computer;const sourceSignal=fluid.fetchContextReference(ifRecord,shadow);shadow.frameworkEffects["conditionalComponent-"+segs.join(".")]=effect((()=>{const value=fluid.deSignal(sourceSignal);if(value&&!fluid.isUnavailable(value)){computer=fluid.pushSubcomponentPotentia(shadow,key,expanded,null,sourceLayer);togo.value=computer}else{if(computer){computer.shadow.potentia.value=fluid.emptyPotentia;computer=togo.value=null}}}));return togo}else{return fluid.pushSubcomponentPotentia(shadow,key,expanded,null,sourceLayer)}};fluid.elementExpanderRecord=function(){};fluid.expandElementTypes=[{key:"$method",handler:fluid.expandMethodRecord},{key:"$compute",handler:fluid.expandComputeRecord},{key:"$bindable",handler:fluid.expandBindableRecord,isBindable:true},{key:"$effect",handler:fluid.expandEffectRecord,isEffect:true},{key:"$linkage",handler:fluid.expandLinkageRecord,isEffect:true},{key:"$reactiveRoot",handler:fluid.expandReactiveRecord},{key:"$component",handler:fluid.expandComponentRecord}].map((rec=>Object.assign(Object.create(fluid.elementExpanderRecord.prototype),rec)));fluid.layerForSite=site=>fluid.get(site.shadow.layerMap,site.segs)?.[$m]?.source;fluid.siteSignal=function(signal,shadow,segs){const site={shadow:shadow,segs:[...segs]};if(fluid.isUnavailable(signal)){signal.causes.forEach((cause=>cause.site=site))}else{signal.site=site}return signal};fluid.renderSite=function(site){const path=site.segs?"."+fluid.composeSegments(site.segs):"";return`{${site.shadow.path}}${path}`};fluid.renderLayerRef=function(layerName,segs){const path=segs?"."+fluid.composeSegments(segs):"";return`{${layerName}}${path}`};fluid.parseSite=function(id){const ref=fluid.parseContextReference(id);const shadow=fluid.globalInstantiator.pathToComponent[ref.context];return{shadow:shadow,path:ref.path}};fluid.mountSignalRecord=function(handlerRecord,record,shadow,segs){const allSegs=[...segs,$m];const oldRec=fluid.get(shadow.oldShadowMap,allSegs);const rec=fluid.getRecInsist(shadow.shadowMap,allSegs);rec.signalRecord=record;rec.handlerRecord=handlerRecord;if(oldRec){rec.proxy=oldRec.proxy}if(oldRec&&oldRec.signalRecord===record){return rec.signalProduct=oldRec.signalProduct}else if(!handlerRecord.isEffect){const product=rec.signalProduct=handlerRecord.handler(record,shadow,segs,fluid.peek(segs));fluid.siteSignal(product,shadow,segs);return product}};fluid.expandElement=function(shadow,element,segs){if(fluid.isPlainObject(element,true)){const handlerRecord=fluid.expandElementTypes.find((record=>element[record.key]));if(handlerRecord){return fluid.mountSignalRecord(handlerRecord,element[handlerRecord.key],shadow,segs)}else{return element}}else if(fluid.isILReference(element)){const togo=fluid.fetchContextReference(element,shadow,segs);return togo}else{return element}};fluid.expansionCache=Object.create(null);fluid.expandCompactElementImpl=function(element){const c=element.charAt(0);if(c==="$"){const colpos=element.indexOf(":");if(colpos===-1){fluid.fail("Badly-formed compact record ",element," without colon")}else{const type=element.substring(0,colpos);if(!fluid.expandElementTypes.find((record=>record.key===type))){fluid.fail("Unrecognised compact record type ",type)}const body=element.substring(colpos+1);const rec=fluid.compactStringToRec(body,type);return{[type]:rec}}}};fluid.expandCompactElement=function(element){if(typeof element==="string"){const existing=fluid.expansionCache[element];if(existing){return existing}else{const expanded=fluid.expandCompactElementImpl(element);if(expanded){fluid.expansionCache[element]=expanded;return expanded}}}};fluid.markSignalised=function(shadowMap,segs,uncess=1){for(let i=0;i<segs.length;++i){const seg=segs[i];const rec=fluid.getRecInsist(shadowMap,[seg,$m]);if(i<segs.length-uncess){rec.hasSignalChild=true}shadowMap=shadowMap[seg]}};fluid.isUnexpandablePath=function(segs){return segs[0]==="$for"};fluid.expandLayer=function(target,flatMerged,shadow,segs){fluid.each(flatMerged,(function expandOneLayer(value,key){segs.push(key);const uncompact=fluid.expandCompactElement(value);const expanded=fluid.expandElement(shadow,uncompact||value,segs);if(fluid.isPlainObject(expanded,true)&&!fluid.isUnexpandablePath(segs)){const expandedInner={};fluid.expandLayer(expandedInner,value,shadow,segs);target[key]=expandedInner}else{target[key]=expanded;if(fluid.isSignal(expanded)){const uncess=expanded.$variety==="$componentList"||expanded.$variety==="$list"?0:1;fluid.markSignalised(shadow.shadowMap,segs,uncess)}}segs.pop()}))};fluid.checkUnavailableComponent=function(shadow){const unavailableLayerVals=Object.values(shadow.unavailableLayers.peek());return unavailableLayerVals.length>0?fluid.mergeUnavailables(unavailableLayerVals):undefined};fluid.noteUnavailableLayer=function(shadow,layerName,value){const existing=shadow.unavailableLayers.peek();shadow.unavailableLayers.value={...existing,[layerName]:value}};fluid.flatMergedRound=function(shadow,hierarchyResolver,layerNames){if(layerNames.length===0){fluid.noteUnavailableLayer(shadow,"fluid.noLayers",fluid.unavailable({message:"Component has no layers",site:{shadow:shadow,segs:[]}},"config"))}layerNames.forEach((layerName=>hierarchyResolver.storeLayer(layerName)));return hierarchyResolver.resolve(layerNames)};fluid.upgradeDynamicLayers=function(resolvedMergeRecords,dynamicMergeRecord){const dynamicLayers=dynamicMergeRecord.layer.$layers;if(dynamicLayers){resolvedMergeRecords.forEach((mergeRecord=>{if(mergeRecord.mergeRecordType==="def"&&dynamicLayers.includes(mergeRecord.mergeRecordName)){mergeRecord.mergeRecordType="dynamicLayers";mergeRecord.priority=fluid.mergeRecordTypes.dynamicLayers}}))}};fluid.ensureImportsLoaded=()=>{};fluid.flatMergedComputer=function(shadow){return computed((function flatMergedComputer(){shadow.unavailableLayers.value=Object.create(null);const{layerNames:layerNames,mergeRecords:mergeRecords}=shadow.potentia.value;const dynamicMergeRecord=shadow.dynamicMergeRecord.value;const allMergeRecords=[...mergeRecords,dynamicMergeRecord];shadow.mergeRecords=allMergeRecords;const mergeRecordLayerNames=allMergeRecords.map((mergeRecord=>fluid.makeArray(mergeRecord.layer.$layers))).flat().filter((name=>name));const allLayerNames=[...layerNames,...mergeRecordLayerNames].reverse();const[dynamicNames,staticNames]=fluid.partition(allLayerNames,fluid.isILReference);const uniqueDynamicNames=[...new Set(dynamicNames)];if(!fluid.arrayEqual(uniqueDynamicNames,shadow.dynamicLayerNames.peek())){shadow.dynamicLayerNames.value=uniqueDynamicNames}const uniqueStaticNames=[...new Set(staticNames)];const hierarchyResolver=new fluid.HierarchyResolver((layerName=>{fluid.ensureImportsLoaded(shadow,layerName)}));const resolved=fluid.flatMergedRound(shadow,hierarchyResolver,uniqueStaticNames);fluid.each(hierarchyResolver.unavailableLayers,((value,layerName)=>fluid.noteUnavailableLayer(shadow,layerName,value)));const layers=resolved.mergeRecords.concat(mergeRecords).concat({mergeRecordType:"live",mergeRecordName:"live",layer:shadow.liveLayer});fluid.upgradeDynamicLayers(layers,dynamicMergeRecord);shadow.mergeRecords=layers;const flatMerged=fluid.makeLayer("flatMerged",shadow);shadow.layerMap=fluid.mergeLayerRecords(flatMerged,layers);return flatMerged}))};fluid.unavailableComponent=fluid.unavailable("Component is unavailable");fluid.computeInstance=function(potentia,parentShadow,memberName,variableScope){fluid.isIdle.value=fluid.busyUnavailable;const shadow=Object.create(fluid.shadow.prototype);shadow.potentia=signal(potentia);shadow.liveLayer=Object.create(null);shadow.shadowMap=Object.create(null);shadow.dynamicMergeRecord=signal({mergeRecordType:"dynamicLayers",layer:{}});shadow.dynamicLayerNames=signal([]);shadow.unavailableLayers=signal(Object.create(null));shadow.instanceId=0;shadow.flatMerged=fluid.flatMergedComputer(shadow);const computer=computed((function computeInstance(){shadow.oldShadowMap=shadow.shadowMap;shadow.shadowMap=Object.create(null);const flatMerged=shadow.flatMerged.value;const instance=fluid.freshComponent(potentia.props,shadow);fluid.transferShadowMap(shadow.shadowMap,shadow.layerMap);instance.instanceId=shadow.instanceId++;console.log("Allocated instanceId "+instance.instanceId+" at site "+shadow.path);try{++fluid.effectGuardDepth;fluid.expandLayer(instance,flatMerged,shadow,[])}finally{--fluid.effectGuardDepth}console.log("Disposing effects for path "+shadow.path);fluid.disposeLayerEffects(shadow);return instance}),fluid.unavailableComponent);computer.$variety="$component";shadow.computer=computer;computer.shadow=shadow;shadow.availableInstance=computed((()=>{const unavailableLayerVals=Object.values(shadow.unavailableLayers.value);return unavailableLayerVals.length>0?fluid.mergeUnavailables(unavailableLayerVals):computer.value}));try{++fluid.effectGuardDepth;const instantiator=parentShadow.instantiator;instantiator.recordKnownComponent(parentShadow,shadow,memberName,true);fluid.applyScope(shadow.variableScope,variableScope);fluid.queueScheduleEffects(shadow)}finally{--fluid.effectGuardDepth;fluid.queueScheduleEffects(shadow)}return computer};fluid.effectGuardDepth=0;fluid.scheduleEffectsQueue=[];fluid.queueScheduleEffects=function(shadow){fluid.scheduleEffectsQueue.push(shadow);if(fluid.effectGuardDepth<=1){const active=fluid.scheduleEffectsQueue.reverse();fluid.scheduleEffectsQueue=[];active.forEach((shadow=>{shadow.effectScheduler=effect((()=>{const instance=shadow.computer.value;if(!fluid.isUnavailable(instance)){untracked((()=>{console.log("scheduleEffects executing for instanceId ",instance.instanceId," path "+shadow.path);fluid.scheduleEffects(shadow)}))}}));shadow.effectScheduler.$variety="effectScheduler"}));fluid.isIdle.value=true}};fluid.possiblyRenderError=x=>x;fluid.scheduleEffects=function(shadow){if(shadow.dynamicLayerNames.peek().length>0&&!shadow.frameworkEffects.dynamicLayerEffect){let resolvedDynamicLayers=[];shadow.frameworkEffects.dynamicLayerEffect=effect((()=>{const newResolvedDynamicLayers=shadow.dynamicLayerNames.value.map((function resolveDynamicLayers(ref){const layers=fluid.deSignal(fluid.fetchContextReference(ref,shadow,["$layers"]));return fluid.isUnavailable(layers)?null:layers})).flat();if(!fluid.arrayEqual(newResolvedDynamicLayers,resolvedDynamicLayers)){resolvedDynamicLayers=newResolvedDynamicLayers;shadow.dynamicMergeRecord.value={mergeRecordType:"dynamicLayers",layer:{$layers:resolvedDynamicLayers}}}}))}fluid.possiblyRenderError(shadow);if(Object.keys(shadow.unavailableLayers.peek()).length===0){const expandEffect=(newRecord,segs)=>{newRecord.signalProduct=newRecord.handlerRecord.handler(newRecord.signalRecord,shadow,segs);fluid.siteSignal(newRecord.signalProduct,shadow,segs)};fluid.forEachDeep(shadow.shadowMap,(function allocateOneEffect(newRecord,segs){if(newRecord.handlerRecord?.isEffect){const oldRecord=fluid.get(shadow.oldShadowMap,segs)?.[$m];if((!oldRecord||newRecord.signalRecord!==oldRecord.signalRecord||!oldRecord.signalProduct)&&!newRecord.signalProduct){expandEffect(newRecord,segs)}}else if(newRecord.handlerRecord?.isBindable){newRecord.signalProduct.selfObserve()}}))}if(fluid.isEmptyPotentia(shadow.potentia.peek())){shadow.instantiator.clearComponent(shadow.parentShadow,shadow.memberName,shadow)}};fluid.disposeLayerEffects=function(shadow){fluid.forEachDeep(shadow.oldShadowMap,((oldRecord,segs)=>{const newRecord=fluid.get(shadow.shadowMap,segs)?.[$m];const handlerRecord=oldRecord.handlerRecord;if((handlerRecord?.isEffect||handlerRecord?.isBindable)&&(!newRecord||newRecord.signalRecord!==oldRecord.signalRecord)){oldRecord?.signalProduct?.dispose()}}))};fluid.applyScope=function(target,newScope){fluid.clear(target);Object.assign(target,newScope)};fluid.pushPotentia=function(parentShadow,memberName,mergeRecords,layerNames=[],variableScope){const existing=parentShadow.childComponents[memberName];if(existing){const shadow=existing;const oldPotentia=shadow.potentia.peek();const writtenLayers=new Set(mergeRecords.map((mergeRecord=>mergeRecord.mergeRecordType)));const filteredRecords=oldPotentia.mergeRecords.filter((mergeRecord=>!writtenLayers.has(mergeRecord.mergeRecordType)));const newMergeRecords=filteredRecords.concat(mergeRecords.filter((mergeRecord=>mergeRecord.layer)));const newLayerNames=oldPotentia.layerNames||layerNames;const potentia={mergeRecords:newMergeRecords,layerNames:newLayerNames};shadow.potentia.value=potentia;fluid.applyScope(shadow.variableScope,variableScope);return shadow.computer}else{return fluid.computeInstance({mergeRecords:mergeRecords,layerNames:layerNames},parentShadow,memberName,variableScope)}};fluid.busyUnavailable=fluid.unavailable("System is busy","I/O");fluid.isIdle=signal(true);fluid.unavailableComponentMap=signal(Object.create(null));fluid.unavailableComponents=fluid.computed((unavailableComponentMap=>{const keys=Object.keys(unavailableComponentMap);return keys.length===0?true:fluid.unavailable("Some components are unavailable")}),fluid.unavailableComponentMap);fluid.trackComponentAvailability=function(shadow){const updateAvailability=function(instance){const currentMap=fluid.unavailableComponentMap.peek();const currentEntry=currentMap[shadow.path];const isUnavailable=fluid.isUnavailable(instance);let newMap=currentMap;if(currentEntry&&!isUnavailable){const{[shadow.path]:_ignored,...rest}=currentMap;newMap=rest}else if(!currentEntry&&isUnavailable){newMap={...currentMap,...{[shadow.path]:true}}}fluid.unavailableComponentMap.value=newMap};return effect((()=>{const instance=fluid.checkUnavailableComponent(shadow)||shadow.computer?.value||shadow.that;updateAvailability(instance)}),{onDispose:()=>{updateAvailability(true)}})};fluid.expectLiveAccess=function(shadow,prop){if(shadow.lifecycleStatus==="destroyed"){throw Error(`Cannot access member ${prop} of component which has been destroyed`)}};fluid.getPenThroughSignals=function(target,segs){let it=fluid.deSignal(target);for(let i=0;i<segs.length-1;++i){const move=it[segs[i]];it=fluid.deSignal(move)}return it};fluid.mutatingArrayMethods=Object.fromEntries(["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"].map((key=>[key,true])));fluid.proxyMat=function(inTarget,shadow,segs){const target=segs.length===0?shadow.availableInstance:inTarget;const rec=fluid.getRecInsist(shadow.shadowMap,[...segs,$m]);const existing=rec.proxy;if(existing){return existing}else{const getHandler=function(target,prop){if(prop===$t){return inTarget}else if(prop===$u){return target}fluid.expectLiveAccess(shadow,prop);const deTarget=fluid.deSignal(target);if(prop===Symbol.toStringTag){return Object.prototype.toString.call(deTarget)}else{const nextSegs=[...segs,prop];const upSignals=fluid.get(shadow.shadowMap,nextSegs)?.[$m]?.hasSignalChild;const inReactive=fluid.findReactiveRoot(shadow.shadowMap,nextSegs);const next=fluid.isUnavailable(deTarget)&&segs.length>0?undefined:inReactive?fluid.getForComponent(shadow,nextSegs):deTarget[prop];const proxyNext=upSignals||inReactive;if(Array.isArray(deTarget)&&typeof deTarget[prop]==="function"){if(fluid.mutatingArrayMethods[prop]){const liveSignal=fluid.pathToLive(shadow,segs);const oldValue=liveSignal.value;const forked=[...oldValue];return function(){const togo=Array.prototype[prop].apply(forked,arguments);liveSignal.value=forked;fluid.invokeLater((()=>{const layerName=fluid.renderSite({shadow:shadow,segs:segs});fluid.pushHistory({type:"updateLayer",oldValue:oldValue,newValue:forked,layerName:layerName})}));return togo}}else{const unwrapped=deTarget.map(((element,key)=>getHandler(target,key)));return Array.prototype[prop].bind(unwrapped)}}else if(proxyNext||fluid.isSignal(next)){const upcoming=fluid.deSignal(next);return fluid.isUnavailable(upcoming)?fluid.unavailableProxy(upcoming):next.$variety==="$component"?fluid.proxyMat(next,next.shadow,[]):fluid.isPrimitive(upcoming)||!proxyNext?upcoming:fluid.proxyMat(next,shadow,nextSegs)}else{return next}}};const setHandler=function(target,prop,value){fluid.expectLiveAccess(shadow,prop);const nextSegs=[...segs,prop];if(fluid.isSignal(target)&&target.$variety==="$contextRef"){const resolvedRec=shadow.variableScope[target.parsed.context];let innerContext=target.parsed.context,innerPath=target.parsed.path;if(resolvedRec.source){const innerRef=resolvedRec.source;innerContext=innerRef.parsed.context;innerPath=fluid.composePath(innerRef.parsed.path,resolvedRec.sourcePath)}const resolved=fluid.resolveContext(shadow,innerContext);const innerNext=fluid.getPenThroughSignals(resolved,innerPath)}fluid.setForComponent(shadow.that,nextSegs,value);return true};const proxy=new Proxy(target,{get:getHandler,set:setHandler,ownKeys:()=>Reflect.ownKeys(fluid.deSignal(target)),getOwnPropertyDescriptor:function(target,key){return{value:this.get(target,key),enumerable:true,configurable:true}},getPrototypeOf:()=>Object.getPrototypeOf(fluid.deSignal(target))});return rec.proxy=proxy}};fluid.unwrapProxy=function(maybeProxy){const target=maybeProxy?.[$t];return target?fluid.deSignal(target):maybeProxy};fluid.initFreeComponent=function(componentName,...initArgs){const instantiator=fluid.globalInstantiator;const id=fluid.allocateId();const instanceName=fluid.computeGlobalMemberName(componentName,id);const argLayer=initArgs[0]||{};const ourLayerNames=[componentName].concat(fluid.makeArray(argLayer.$layers));const userLayerRecord={mergeRecordType:"user",layer:{...argLayer}};const potentia={props:{$id:id},layerNames:ourLayerNames,mergeRecords:[userLayerRecord]};const computer=fluid.computeInstance(potentia,instantiator.rootComponent[$m],instanceName);const proxy=fluid.proxyMat(computer,computer.shadow,[]);return proxy};fluid.destroy=function(path,instantiator){instantiator=instantiator||fluid.globalInstantiator;const segs=fluid.parsePath(path);if(segs.length===0){fluid.fail("Cannot destroy the root component")}const that=instantiator.pathToComponent[path];fluid.destroyComponent(that)};fluid.emptyPotentia=Object.freeze({layerNames:[],mergeRecords:[]});fluid.isEmptyPotentia=function(potentia){return potentia.layerNames.length===0&&potentia.mergeRecords.length===0};fluid.destroyComponent=function(proxy){proxy[$t].shadow.potentia.value=fluid.emptyPotentia};fluid.def("fluid.component",{events:{onCreate:0,onDestroy:0,afterDestroy:0},destroy:"$method:fluid.destroyComponent({self})",$variety:"framework"});fluid.def("fluid.componentList",{$layers:"fluid.component",$variety:"framework"});fluid.def("fluid.resolveRoot",{$layers:"fluid.component",$variety:"framework"});fluid.def("fluid.resolveRootSingle",{$layers:"fluid.resolveRoot",$variety:"framework"});fluid.constructRootComponents(fluid.globalInstantiator)};if(typeof fluid!=="undefined"){$fluidILScope(fluid)}"use strict";const fluidViewScope=function(fluid){const $m=fluid.metadataSymbol;const $t=fluid.proxySymbol;fluid.elementToVNode=function(element){const tag=element.tagName.toLowerCase();const attrs={};for(let i=0;i<element.attributes.length;i++){const attr=element.attributes[i];attrs[attr.name]=attr.value}return{tag:tag,attrs:attrs}};fluid.svgTags=new Set(["svg","circle","ellipse","line","path","polygon","polyline","rect","g","defs","marker","mask","pattern","symbol","use","view","text","tspan","textPath","filter","feGaussianBlur","feOffset","feBlend","feColorMatrix","feComponentTransfer","feComposite","feFlood","feImage","feMerge","feMorphology","feTile","feTurbulence","clipPath","foreignObject","linearGradient","radialGradient","stop"]);fluid.nodeFromVNode=function(dokkument,vnode){if(typeof vnode==="string"){return dokkument.createTextNode(vnode)}else if(vnode.text!==undefined){return dokkument.createTextNode(fluid.isSignal(vnode.text)?"":vnode.text)}else{return fluid.svgTags.has(vnode.tag)?dokkument.createElementNS("http://www.w3.org/2000/svg",vnode.tag):dokkument.createElement(vnode.tag)}};fluid.matchNodeToVNode=function(node,vnode){if(typeof vnode==="string"||vnode.text){return node.nodeType===3}else{return node.nodeType===1&&node.tagName.toLowerCase()===vnode.tag}};fluid.liveQuerySelectorAll=function(selector,root=null,dokkument=document){const togo=signal([]);const context=root||dokkument;const updateMatches=()=>{const upcoming=Array.from(context.querySelectorAll(selector));if(!fluid.arrayEqual(togo.value,upcoming)){togo.value=upcoming}};const window=dokkument.defaultView;const observer=new window.MutationObserver((()=>{updateMatches()}));const init=()=>{observer.observe(context,{childList:true,subtree:true});updateMatches()};fluid.applyOnLoad(init);togo.dispose=()=>observer.disconnect();return togo};fluid.liveQuerySelector=function(selector,root=null,dokkument=document){const noElement=fluid.unavailable({cause:"No element matches selector "+selector,variety:"I/O"});const query=fluid.liveQuerySelectorAll(selector,root,dokkument);const togo=computed((()=>query.value.length===0?noElement:query.value[0]));togo.dispose=query.dispose;return togo};fluid.querySelectorAll=function(node,selector){if(fluid.isDOMNode(node)){const nodes=[...node.querySelectorAll(selector)];return nodes.map((node=>fluid.domToVDom(node)))}else{const results=[];if(node.children){node.children.forEach((child=>{if(child.tag===selector){results.push(child)}results.push(...fluid.querySelectorAll(child,selector))}))}return results}};fluid.domToVDom=function(node){if(node.nodeType===3){const text=node.nodeValue;return text===""?null:{text:text}}if(node.nodeType===1){const togo=fluid.elementToVNode(node);const children=[];for(let i=0;i<node.childNodes.length;++i){const child=fluid.domToVDom(node.childNodes[i]);if(child!==null){children.push(child)}}togo.children=children;return togo}return null};fluid.importOneUrlResource=function(layerName,relPath){return{url:fluid.importMap[layerName].urlBase+relPath,variety:"importUrlResource"}};fluid.importUrlResource=function(layerName,relPath){return typeof relPath==="string"?fluid.importOneUrlResource(layerName,relPath):fluid.isArrayable(relPath)?relPath.map((oneRelPath=>fluid.importOneUrlResource(layerName,oneRelPath))):null};fluid.vNodeToDom=function(dokkument,vnode){const root=fluid.nodeFromVNode(dokkument,vnode);fluid.patchChildren(vnode,root);return root};fluid.trueSignal=signal(true);fluid.cssInjectionStyles={literal:{construct:()=>({tag:"style",attrs:{type:"text/css"},children:[{text:""}]}),update:(node,rec,dokkument,absUrl)=>{node.firstChild.nodeValue=rec.text+`\n/*# sourceURL=${absUrl}*/`;return fluid.trueSignal}},link:{construct:()=>({tag:"link",attrs:{rel:"stylesheet",type:"text/css"}}),update:(node,rec,dokkument)=>{const resolved=fluid.module.resolveRelativePath(dokkument.location,rec.url);node.setAttribute("href",resolved);return fluid.trueSignal}}};fluid.scriptInjectionStyles={literal:{construct:()=>({tag:"script",attrs:{type:"text/javascript"},children:[{text:""}]}),update:(node,rec,dokkument,absUrl)=>{node.firstChild.nodeValue=rec.text+`\n//# sourceURL=${absUrl}`;return fluid.trueSignal},defer:true},link:{construct:()=>({tag:"script",attrs:{async:"false",type:"text/javascript"}}),update:(node,rec,dokkument)=>{const resolved=fluid.module.resolveRelativePath(dokkument.location,rec.url);const togo=signal(fluid.unavailable(`Script at url ${resolved} is loading`,"I/O"));node.setAttribute("src",resolved);node.onload=()=>togo.value=true;node.async=false;return togo}}};fluid.diffFields=function(rec1,rec2,fields){return fields.every((field=>rec1[field]===rec2[field]))};fluid.clearInjRec=function(dokkument,nodeId){dokkument.getElementById(nodeId)?.remove()};fluid.doInjectSFCElement=function({dokkument:dokkument,injStyle:injStyle,injRec:injRec,url:url}){const absUrl=url;const fresh=fluid.vNodeToDom(dokkument,injStyle.construct());fresh.id=injRec.nodeId;const togo=injStyle.update(fresh,injRec,dokkument,absUrl);try{dokkument.head.appendChild(fresh)}catch(e){fluid.fail(`Syntax error in SFC injection at url ${url}: ${e.message}`,e)}return togo};fluid.toAbsoluteUrl=(dokkument,url)=>/^\w+:\/\//.test(url)?url:new URL(url,dokkument.location.href).href;fluid.decodeInjectSFCElement=function(dokkument,injRec,url,oldInjRecs,injStyles){const nodeId=injRec.nodeId;const diffFields=["url","text"];const existing=oldInjRecs[nodeId];const shouldInject=!existing||!fluid.diffFields(existing,injRec,diffFields);if(shouldInject){if(existing){fluid.clearInjRec(nodeId)}const injStyleKey=injRec.text?"literal":"link";const injStyle=injStyles[injStyleKey];return{dokkument:dokkument,injStyle:injStyle,injRec:injRec,url:url}}else{return null}};fluid.isAbsolutePath=function(path){return/^(?:\/|[a-z]+:\/\/)/.test(path)};fluid.deSlash=function(path){return path.endsWith("/")?path.slice(0,-1):path};fluid.acquireModules=function(dokkument,root){const moduleNodes=fluid.querySelectorAll(root,"fluid-module");const entries=moduleNodes.map((node=>{const id=node.attrs.id;const rawSrc=node.attrs.src;const origSrc=fluid.deSlash(rawSrc);const abs=fluid.isAbsolutePath(origSrc);const src=abs?origSrc:fluid.deSlash(new URL(origSrc,dokkument.location.href).href);fluid.module.register(id,src,origSrc,abs);return[id,{node:node,path:src}]}));return Object.fromEntries(entries)};fluid.pathToLayerName=function(path){const match=path.match(/\/([^/]+)\.[^/.]+$/);return match?match[1].replace(/-/g,"."):""};fluid.docToImportMap=function(dokkument,root){const importMap={};const importNodes=fluid.querySelectorAll(root,"fluid-import");importNodes.forEach((node=>{const path=node.attrs.src;const layerName=node.attrs.layer||fluid.pathToLayerName(path);if(!layerName){fluid.log(fluid.logLevel.FAIL,"Error in document structure: couldn't determine layer name from import ",node)}else{importMap[layerName]={path:path,node:node}}}));fluid.loadImportMap(importMap);Object.keys(importMap).forEach((layerName=>fluid.subscribeDocToInjections(layerName,dokkument)));return importMap};fluid.removeArrayElement=function(array,element){if(array){const index=array.indexOf(element);if(index!==-1){array.splice(index,1)}}};fluid.acquireLoadDirectives=function(dokkument,root){const removeAll=recs=>fluid.each(recs,(rec=>fluid.removeArrayElement(rec.node.parentNode,rec.node)));removeAll(fluid.acquireModules(dokkument,root));removeAll(fluid.docToImportMap(dokkument,root))};fluid.parseSFCScripts=function(scriptNodes){const defMapList=scriptNodes.map((scriptNode=>{const src=scriptNode.attrs?.src;if(src){return{url:src}}else{const text=scriptNode.children[0]?.text;const defMaps=fluid.parseDefMaps(text,0);return{defMaps:defMaps,text:text}}}));return defMapList};fluid.indexLayerDefs=function(defMapList){const layerDefIndex={};defMapList.forEach(((rec,index)=>{if(typeof rec!=="string"){const{defMaps:defMaps}=rec;fluid.each(defMaps,((range,layerName)=>{layerDefIndex[layerName]={scriptIndex:index,...range}}))}}));return layerDefIndex};fluid.sfcToInjRecs=function(vTree,layerName){const reject=message=>{const unavailable=fluid.unavailable(message);fluid.def(layerName,unavailable)};const injRecs={};const scriptNodes=fluid.querySelectorAll(vTree,"script");if(scriptNodes.length===0){reject(`Error in SFC: Expected definition for layer ${layerName} but no script node was found`)}else{const defMapList=fluid.parseSFCScripts(scriptNodes);const layerDefIndex=fluid.indexLayerDefs(defMapList);if(!layerDefIndex[layerName]){reject(`Error in SFC: Expected definition for layer ${layerName} but found ${Object.keys(layerDefIndex).join(", ")} instead`)}else{const ourDef=layerDefIndex[layerName];const ourSNI=defMapList[ourDef.scriptIndex];const oldLayers=fluid.defFromMap(ourSNI.text,ourSNI.defMaps,layerName,"$layers");const partial=oldLayers&&oldLayers.includes("fluid.partialViewComponent");let patchedText=ourSNI.text;const docTemplate=fluid.querySelectorAll(vTree,"template")[0];let addLayers=["fluid.templateViewComponent"];if(docTemplate){addLayers=["fluid.sfcTemplateViewComponent"];if(partial){const relativeContainer=fluid.defFromMap(ourSNI.text,ourSNI.defMaps,layerName,"relativeContainer");if(!relativeContainer){reject(`Error in SFC for ${layerName}: Didn't find relativeContainer property for partial component`)}const ptl={[layerName]:{relativeContainer:relativeContainer}};patchedText=fluid.patchDefMap(patchedText,ourDef,"partialTemplateLayers",ptl,"last")}else{patchedText=fluid.patchDefMap(patchedText,ourDef,"templateLayer",layerName,"last")}fluid.writeParsedTemplate(layerName,docTemplate)}if(!oldLayers){patchedText=fluid.patchDefMap(patchedText,ourDef,"$layers",addLayers,"first")}ourSNI.text=patchedText;defMapList.forEach(((sni,index)=>{const nodeId=`fl-script-${layerName}-${index}`;const injRec=sni.url?{url:sni.url}:{text:sni.text};injRec.defMaps=sni.defMaps;injRec.nodeId=nodeId;injRec.variety="script";injRecs[nodeId]=injRec}));const styleNodes=fluid.querySelectorAll(vTree,"style");styleNodes.forEach(((styleNode,index)=>{const nodeId=`fl-style-${layerName}-${index}`;const src=styleNode.attrs?.src;const injRec=src?{url:src}:{text:styleNode.children[0]?.text};injRec.nodeId=nodeId;injRec.variety="style";injRecs[nodeId]=injRec}))}}return injRecs};fluid.parseSFC=function(rec,layerName){let oldText;return fluid.effect((text=>{if(text===oldText){console.log("Culling SFC injection effect since text has not changed");return}console.log("**** Beginning to parse SFC for layer ",layerName);oldText=text;const vTree=fluid.parseHTMLToTree(text);rec.injRecsSignal.value=fluid.sfcToInjRecs(vTree,layerName);rec.loadCompletion.value=true}),[rec.textSignal])};fluid.sfcStore=Object.create(null);fluid.templateStore=Object.create(null);fluid.documentInjections=new Map;fluid.noteLayerInjectionInProgress=function(injDone){const existing=fluid.documentInjections.get(injDone.dokkument);if(existing){const existingRecs=[...existing.injRecsSignal.peek()];const existingLayerIndex=existingRecs.findIndex((rec=>rec.layerName===injDone.layerName));if(existingLayerIndex!==-1){existingRecs[existingLayerIndex]=injDone}else{existingRecs.push(injDone)}existing.injRecsSignal.value=existingRecs}else{const rec={injRecsSignal:signal([])};rec.injectionsComplete=computed((()=>fluid.signalsToAvailable(rec.injRecsSignal.value).value));fluid.documentInjections.set(injDone.dokkument,rec)}};fluid.fetchParsedTemplate=function(layerName){return fluid.templateStore[layerName].value};fluid.writeParsedTemplate=function(layerName,template){const existing=fluid.templateStore[layerName];if(existing){existing.value=template}else{fluid.templateStore[layerName]=signal(template)}};fluid.readSFC=function(layerName){const rec=fluid.sfcStore[layerName];if(rec){return rec}else{const unavailable=fluid.unavailable(`SFC for ${layerName} is not available`);return fluid.sfcStore[layerName]={textSignal:signal(unavailable),injRecsSignal:signal(unavailable),docInjectEffects:new Map}}};fluid.loadSFC=function(layerName,url){console.log("loadSFC for ",layerName);const rec=fluid.readSFC(layerName);if(!rec.parseEffect){rec.loadCompletion=signal(fluid.unavailable(`SFC for ${layerName} is loading`,"I/O"));rec.url=url;rec.fetchSignal=fluid.fetchText(url);rec.fetchEffect=effect((()=>rec.textSignal.value=rec.fetchSignal.value));rec.parseEffect=fluid.parseSFC(rec,layerName)}return rec};fluid.subscribeDocToInjections=function(layerName,dokkument){const rec=fluid.readSFC(layerName);let docEffect=rec.docInjectEffects.get(dokkument);if(!docEffect){let oldInjRecs={};const injDone=signal(fluid.unavailable("Injection in progress"));injDone.layerName=layerName;injDone.dokkument=dokkument;const newDocEffect=fluid.effect((async function docInjectEffect(injRecs){const defBuffer=Object.create(null);fluid.startCaptureBufferDefs(defBuffer);try{const docInjRecs=Object.values(injRecs).map((injRec=>fluid.decodeInjectSFCElement(dokkument,injRec,rec.url,oldInjRecs,injRec.variety==="script"?fluid.scriptInjectionStyles:fluid.cssInjectionStyles))).filter((injRec=>injRec));const injsDone=docInjRecs.map((docInjRec=>fluid.doInjectSFCElement(docInjRec)));fluid.endCaptureBufferDefs();const injsDoneSignal=fluid.signalsToAvailable(injsDone);const res=fluid.signalToPromise(injsDoneSignal);await res;console.log(`Await for ${layerName} is done`)}finally{console.log(`Finally for ${layerName} is starting`);fluid.writeBufferDefs(defBuffer);injDone.value=true}Object.keys(oldInjRecs).forEach((nodeId=>{const newRec=injRecs[nodeId];if(!newRec){fluid.clearInjRec(nodeId)}}));oldInjRecs=injRecs}),[rec.injRecsSignal]);newDocEffect.injDone=injDone;rec.docInjectEffects.set(dokkument,newDocEffect);fluid.noteLayerInjectionInProgress(injDone);docEffect=newDocEffect}return docEffect.injDone};fluid.ensureImportsLoaded=function(shadow,layerName){const dokkument=fluid.findDocument(shadow);const importRec=fluid.importMap[layerName];if(importRec){return fluid.subscribeDocToInjections(layerName,dokkument)}else{return signal(true)}};fluid.insertChildContainer=function(strategy,key,templateTree,parentNode,referenceNode){const tagName=templateTree.children[0].tag;if(!tagName){return fluid.unavailable({cause:`Invalid template: Unable to determine tag name from ${templateTree.children[0]}`})}if(key){const child=[...parentNode.children].find((child=>child.getAttribute("data-fl-transient-key")===key));if(child){return child}}const dokkument=parentNode.ownerDocument;const newNode=dokkument.createElement(tagName);if(strategy==="first"){parentNode.insertBefore(newNode,parentNode.firstChild)}else if(strategy==="last"){parentNode.appendChild(newNode)}else if(strategy==="before"){parentNode.insertBefore(newNode,referenceNode)}else if(strategy==="after"){parentNode.insertBefore(newNode,referenceNode.nextSibling)}newNode.setAttribute("data-fl-transient-key",key);return newNode};fluid.viewContainerRegistry=new WeakMap;fluid.noteViewContainerRegistry=function(element,shadow){const existing=fluid.viewContainerRegistry.get(element);if(!existing||existing.path.length<shadow.path.length){fluid.viewContainerRegistry.set(element,shadow)}};fluid.shadowForElement=element=>{const shadow=fluid.viewContainerRegistry.get(element);return shadow&&!/^fullPageEditor-\d+\.inspectOverlay$/.test(shadow.path)?shadow:null};fluid.shadowForElementParent=element=>{while(element){const shadow=fluid.shadowForElement(element);if(shadow){return{shadow:shadow,container:element}}element=element.parentElement}};fluid.unavailableElement=fluid.unavailable("DOM element not available");fluid.allocateVNodeEffect=function(vnode,effectMaker){vnode.elementSignal||=signal(fluid.unavailableElement);const renderEffect=effectMaker(vnode);fluid.pushArray(vnode,"renderEffects",renderEffect);return renderEffect};fluid.bindDomTokens=function(templateEffects,vnode,rendered,applyFunc){if(fluid.isSignal(rendered)){const bindEffect=fluid.allocateVNodeEffect(vnode,(vnode=>{const togo=fluid.effect((function(element,text){if(!fluid.isUnavailable(element)){if(fluid.isUnavailable(text)){fluid.renderError(element,text)}else{applyFunc(element,text)}}}),[vnode.elementSignal,rendered],{free:true});togo.$variety="bindDomTokens";togo.$vnode=vnode;return togo}));templateEffects.push(bindEffect)}};fluid.bindContainer=function(templateEffects,vnode,self){const bindEffect=fluid.allocateVNodeEffect(vnode,(vnode=>{const togo=fluid.effect((function(element){fluid.noteViewContainerRegistry(element,self[$m])}),[vnode.elementSignal]);togo.$variety="bindContainer";togo.$vnode=vnode;return togo}));templateEffects.push(bindEffect);self.renderedContainer=vnode.elementSignal;self[$m].layerMap.renderedContainer.source="fluid.viewComponent"};fluid.removeDomListeners=function(vTreeRec){vTreeRec.forEach((({el:el,event:event,rawHandler:rawHandler,modifiers:modifiers,vnodeId:vnodeId})=>{el.removeEventListener(event,rawHandler,modifiers);if(vnodeId&&el.flEventsBound){delete el.flEventsBound[vnodeId]}}))};fluid.allocateEventBindingEffect=function(templateEffects,vnode){const bindEffect=fluid.allocateVNodeEffect(vnode,(vnode=>{const vTreeRec=[];const togo=fluid.effect((function(element){fluid.applyOns(vnode,vnode.shadow,element,vnode.on,vTreeRec);return()=>fluid.removeDomListeners(vTreeRec)}),[vnode.elementSignal]);togo.$variety="bindEvents";togo.$vnode=vnode;togo.vTreeRec=vTreeRec;return togo}));templateEffects.push(bindEffect)};fluid.liftNegate=negate=>negate?x=>!x:fluid.identity;fluid.mapSignal=(sig,func)=>func===fluid.identity?sig:fluid.computed((value=>func(value)),[sig]);fluid.filterObjKeys=(obj,func)=>Object.fromEntries(Object.entries(obj).filter((([key])=>func(key))));fluid.processVNodeAttribute=function(vnode,value,key,shadow,templateEffects){const firstChar=key.charCodeAt(0);if(firstChar===64){if(key.startsWith("@on")){fluid.pushArray(vnode,"on",{onKey:key.slice(3).toLowerCase(),onValue:value});fluid.allocateEventBindingEffect(templateEffects,vnode)}else if(key==="@class"){const parts=value.split(",").map((part=>part.trim()));const clazz=Object.fromEntries(parts.map((part=>{const[key,ref]=part.split(":");const negate=ref.startsWith("!");const effRef=negate?ref.substring(1):ref;const tokens=fluid.parseAtStringTemplate(effRef);const rendered=fluid.renderComputedStringTemplate(tokens,shadow);const negMap=fluid.liftNegate(negate);const renderedPrim=fluid.isSignal(rendered)?fluid.mapSignal(rendered.$tokens[0],negMap):negMap(rendered);return[key,renderedPrim]})));vnode["class"]=clazz}delete vnode.attrs[key]}else if(key!=="class"){const tokens=fluid.parseAtStringTemplate(value);const rendered=fluid.renderComputedStringTemplate(tokens,shadow);if(fluid.isSignal(rendered)){rendered.$source=value;fluid.bindDomTokens(templateEffects,vnode,rendered,((node,text)=>node.setAttribute(key,text)));vnode.attrs[key]=rendered}}};fluid.getSignalSource=function(ref){return fluid.isSignal(ref)?ref.$source:ref};fluid.editorRootRef=null;fluid.effVTree=function(vTree,elideParent){return elideParent?vTree.children[0]||vTree:vTree};fluid.isSimpleClassSelectorCutpoint=function(tree){return tree.length===1&&tree[0].predList.length===1&&tree[0].predList[0].clazz};fluid.matchSimpleClass=function(tree,clazz,results=[]){const thisClazz=tree.attrs?.["class"];if(thisClazz&&thisClazz.split(" ").includes(clazz)){results.push(tree)}if(tree.children){tree.children.forEach((child=>fluid.matchSimpleClass(child,clazz,results)))}return results};const relDispositions={before:0,after:1};fluid.compositeVTree=function(compositedTree,rec,layerName){const[disposition,selector]=rec.relativeContainer.split(":");const parsedSelector=fluid.parseSelector(selector,fluid.simpleCSSMatcher);const clazz=fluid.isSimpleClassSelectorCutpoint(parsedSelector);if(!clazz){return fluid.unavailable(`Error in partial template for ${layerName}: Support for complex selector ${selector} is not implemented`)}else{const nodes=fluid.matchSimpleClass(compositedTree,clazz);if(nodes.length!==1){return fluid.unavailable(`Error in partial template for ${layerName}: No exact match (${nodes.length}) for class selector .${clazz}`)}else{const target=nodes[0];const relDisposition=relDispositions[disposition];if(relDisposition===undefined){return fluid.unavailable(`Error in partial template for ${layerName}: Unrecognised disposition ${disposition} which should be "after" or "before"`)}const templateTree=fluid.copy(fluid.fetchParsedTemplate(layerName));const parentNode=target.parentNode;const index=parentNode.children.indexOf(target);parentNode.children.splice(index+relDisposition,0,fluid.effVTree(templateTree,true))}}return compositedTree};fluid.retemplatise=function(vnode){delete vnode.parentNode;if(vnode.children){vnode.children.forEach(fluid.retemplatise)}return vnode};fluid.shadowsToRoot=function(shadow){const togo=[];while(shadow){togo.push(shadow);shadow=shadow.parentShadow}return togo};fluid.findDocument=function(shadow){const shadows=fluid.shadowsToRoot(shadow).reverse();const container=fluid.find(shadows,(oneShadow=>{if(oneShadow.that){return oneShadow.that.container}else{const layers=oneShadow.mergeRecords.map((mergeRecord=>mergeRecord.layer)).reverse();return fluid.find(layers,(layer=>{const container=layer.container;return fluid.isSignal(container)||fluid.isDOMNode(container)?container:undefined}))}}));return container?fluid.deSignal(container).ownerDocument:undefined};fluid.activateTemplate=function(vtemplate,self){const shadow=self[$m];const selfEditingRef=fluid.editorRootRef||(fluid.editorRootRef=fluid.fetchContextReferenceSoft("fluid.editorRoot",["selfEditing"],shadow));const selfEditing=selfEditingRef.value;return untracked((()=>{const templateEffects=shadow.frameworkEffects.templateEffects=shadow.frameworkEffects.templateEffects||[];function processVNode(vnode){vnode.shadow=shadow;vnode._id=vnode._id||vnode_id++;if(vnode.text!==undefined){const tokens=fluid.parseAtStringTemplate(vnode.text);const rendered=fluid.renderComputedStringTemplate(tokens,shadow);fluid.bindDomTokens(templateEffects,vnode,rendered,((node,text)=>node.nodeValue=text));return Object.assign(vnode,{text:rendered})}else{const idValue=vnode.attrs?.["@id"];if(idValue){fluid.allocateVNodeEffect(vnode,(vnode=>{const disposable=function(){fluid.pushPotentia(shadow,idValue,[{mergeRecordType:"template"}])};disposable.$variety="$component";const parentTemplate=signal({tag:vnode.tag,attrs:fluid.filterObjKeys(vnode.attrs,(key=>key!=="@id")),children:vnode.children.map(fluid.retemplatise)});delete vnode.children;vnode.attrs=fluid.filterObjKeys(vnode.attrs,(key=>!key.startsWith("@")));const templateRecord={mergeRecordType:"template",layer:{$layers:"fluid.viewComponent",container:vnode.elementSignal,parentTemplate:parentTemplate}};fluid.pushPotentia(shadow,idValue,[templateRecord]);return disposable}))}fluid.each(vnode.attrs,((value,key)=>{fluid.processVNodeAttribute(vnode,value,key,shadow,templateEffects)}));if(vnode["class"]){const clazzSource=fluid.getSignalSource(vnode.attrs["class"])||"";const allClass=computed((()=>{const classes=Object.entries(vnode["class"]).map((([key,value])=>[key,fluid.deSignal(value)])).filter((([,value])=>value&&!fluid.isUnavailable(value))).map((([key])=>key));return clazzSource+" "+classes}));allClass.$variety="$allClass";allClass.$source=clazzSource;fluid.bindDomTokens(templateEffects,vnode,allClass,((node,text)=>node.setAttribute("class",text)));vnode.attrs["class"]=allClass}if(vnode.children!==undefined){vnode.children=vnode.children.map(processVNode)}}return vnode}const activateTemplate=tree=>{fluid.disposeEffects(templateEffects);const togo=processVNode(tree);fluid.acquireLoadDirectives(fluid.findDocument(shadow),vtemplate);templateEffects.forEach((effect=>effect.$site=self));return togo};const assignParents=(vnode,parentNode=null)=>{vnode.parentNode=parentNode;if(vnode.children){vnode.children.forEach((child=>assignParents(child,vnode)))}return vnode};if(!vtemplate){return fluid.unavailable("Template not configured")}const tree=fluid.copy(vtemplate);const useTree=fluid.effVTree(tree,self.elideParent);let compositedTree=assignParents(useTree);if(fluid.hasLayer(self,"fluid.partialViewComponent")){fluid.each(self.partialTemplateLayers,((rec,layerName)=>{compositedTree=fluid.compositeVTree(compositedTree,rec,layerName)}))}const activatedTree=activateTemplate(compositedTree);const filteredTree=selfEditing?selfEditingRef.$component.filterForSelfEditing(activatedTree,self):activatedTree;fluid.bindContainer(templateEffects,filteredTree,self);return filteredTree}))};fluid.unbindDom=function(){};fluid.bindDom=function(vnode,element){if(vnode.elementSignal){fluid.unbindDom(vnode,vnode.elementSignal.peek());vnode.elementSignal.value=element}};fluid.patchAttrs=function(vnode,element,isRoot){if(!isRoot){for(let i=element.attributes.length-1;i>=0;i--){const attrName=element.attributes[i].name;if(!(attrName in vnode.attrs)&&!attrName.startsWith("data-fl-transient")){element.removeAttribute(attrName)}}}for(const[key,value]of Object.entries(vnode.attrs)){if(!fluid.isSignal(value)&&element.getAttribute(key)!==value){element.setAttribute(key,value)}}};fluid.vnodeToSegs=function(vnode){return["$template",vnode.tag]};let vnode_id=1;fluid.patchChildren=function(vnode,element,isRoot=false){fluid.bindDom(vnode,element);if(vnode.text!==undefined&&!fluid.isSignal(vnode.text)&&vnode.text!==element.nodeValue){element.nodeValue=vnode.text}if(vnode.attrs!==undefined){fluid.patchAttrs(vnode,element,isRoot)}if(vnode.children!==undefined){const vcount=vnode.children.length;for(let i=0;i<vcount;++i){const vchild=vnode.children[i];let other=element.childNodes[i];if(!other||!fluid.matchNodeToVNode(other,vchild)){const fresh=fluid.nodeFromVNode(element.ownerDocument,vchild);if(other){other.replaceWith(fresh)}else{element.appendChild(fresh)}other=fresh}fluid.patchChildren(vchild,other)}for(let i=element.childNodes.length-1;i>=vcount;--i){element.childNodes[i].remove()}}};fluid.renderView=function(self,container,vTree){console.log(`renderView beginning for ${self[$m].path} with vTree ${vTree._id} container `,container.flDomId);fluid.patchChildren(vTree,container,true)};fluid.disableRendering=function(self){self.vTree=fluid.unavailable({cause:"Rendering is disabled",variety:"config"})};fluid.def("fluid.viewComponent",{$layers:"fluid.component",elideParent:true,container:"$compute:fluid.unavailable(Container not specified)",renderedContainer:fluid.unavailable({cause:"Component not rendered",variety:"config"}),templateTree:fluid.unavailable({cause:"No virtual DOM tree is configured",variety:"config"}),vTree:"$compute:fluid.activateTemplate({self}.templateTree, {self})",renderView:"$effect:fluid.renderView({self}, {self}.container, {self}.vTree)",$variety:"framework"});fluid.def("fluid.selfTemplate",{$layers:"fluid.viewComponent",templateTree:"{self}.parentTemplate",elideParent:false,$variety:"framework"});fluid.def("fluid.partialViewComponent",{relativeContainer:fluid.unavailable({cause:"Relative container not configured",variety:"config"}),$variety:"framework"});fluid.renderSourceUrl=sourceUrl=>` written in <a class="fl-source-link" href="{sourceUrl}">${sourceUrl.split("/").pop()}</a>`;fluid.renderFullSite=site=>{const path=site?` at <a href="#" class="fl-path-link">${fluid.renderSite(site)}</a>`:"";const layer=site&&fluid.layerForSite(site);const layerText=layer?` in layer ${layer}`:"";const sourceUrl=layer&&fluid.importMap[layer]?.url;const urlText=sourceUrl?fluid.renderSourceUrl(sourceUrl):"";return path+layerText+urlText};fluid.renderOneCause=cause=>{const siteText=Array.isArray(cause.site)?cause.site.map(fluid.renderFullSite).join("<br/>"):fluid.renderFullSite(cause.site);return`<li>${cause.message}${siteText}</li>`};fluid.renderError=function(container,unavailable){const errors=unavailable.causes.map(fluid.renderOneCause).join("\n");const markup=`<ul class="fl-error">${errors}</ul>`;container.innerHTML=markup};fluid.possiblyRenderError=function(shadow){if(shadow.that){const that=shadow.that;if(that.$layers.includes("fluid.viewComponent")){const vTree=fluid.deSignal(that.vTree);if(fluid.isErrorUnavailable(vTree)){fluid.renderError(fluid.deSignal(that.container),vTree)}}}else if(fluid.isErrorUnavailable(shadow.that)){const container=shadow.mergeRecords.reduce(((acc,record)=>record.container||acc),null);if(container){fluid.renderError(container,shadow.that)}}};fluid.registerCoOccurrence("fluid.viewComponentList",{inputLayers:["fluid.viewComponent","fluid.componentList"],outputLayers:["fluid.viewComponentList"]});fluid.def("fluid.viewComponentList",{$layers:"fluid.viewComponent",elideParent:false,vTree:"$compute:fluid.listViewTree({self}.list)",$variety:"framework"});fluid.listViewTree=function(list){return fluid.computed((componentList=>{const{designalArgs:components,unavailable:compUnavailable}=fluid.processSignalArgs(componentList);if(compUnavailable){return compUnavailable}else{const{designalArgs:childTrees,unavailable:treesUnavailable}=fluid.processSignalArgs(components.map((component=>component.vTree)));return treesUnavailable||{tag:"template",children:childTrees}}}),[list])};fluid.def("fluid.templateViewComponent",{$layers:"fluid.viewComponent",templateTree:"$compute:fluid.parseHTMLToTree({self}.template)",$variety:"framework"});fluid.def("fluid.sfcTemplateViewComponent",{$layers:"fluid.templateViewComponent",templateTree:"$compute:fluid.fetchParsedTemplate({self}.templateLayer)",$variety:"framework"});fluid.makeSelfBootEffect=function(dokkument){const selfBootQuery=fluid.liveQuerySelectorAll("*[fluid-layers]",dokkument,dokkument);return effect((()=>{const elements=selfBootQuery.value;elements.forEach((element=>{const existing=fluid.viewContainerRegistry.get(element);if(!existing){const layers=element.getAttribute("fluid-layers").split(" ").map((layer=>layer.trim()));const[firstLayer,...restLayers]=layers;const instance=fluid.initFreeComponent(firstLayer,{$layers:restLayers,container:element});fluid.viewContainerRegistry.set(element,instance[$t].shadow)}}))}))};fluid.bootDocument=function(dokkument){fluid.applyOnLoad((()=>{fluid.acquireModules(dokkument,dokkument.documentElement);fluid.docToImportMap(dokkument,dokkument.documentElement)}));return fluid.makeSelfBootEffect(dokkument)}};if(typeof fluid!=="undefined"){fluidViewScope(fluid)}
//# sourceMappingURL=fluid.core.min.js.map