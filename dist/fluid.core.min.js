"use strict";var{signal:signal,effect:effect,computed:computed,untracked:untracked}=preactSignalsCore;const fluidJSScope=function(fluid){fluid.version="Infusion 6.0.0";fluid.Error=Error;fluid.environment={fluid:fluid};fluid.global=fluid.global||typeof window!=="undefined"?window:typeof self!=="undefined"?self:{};fluid.invokeLater=function(func){return setTimeout(func,0)};fluid.defeatLogging=true;fluid.activityTracing=false;fluid.activityTrace=[];const activityParser=/(%\w+)/g;fluid.isComponent=()=>false;fluid.renderActivityArgument=function(arg){if(fluid.isComponent(arg)){return fluid.dumpComponentAndPath(arg)}else{return arg}};fluid.renderOneActivity=function(activity,nowhile){const togo=nowhile===true?[]:["    while "];const message=activity.message;let index=activityParser.lastIndex=0;while(true){const match=activityParser.exec(message);if(match){const key=match[1].substring(1);togo.push(message.substring(index,match.index));togo.push(fluid.renderActivityArgument(activity.args[key]));index=activityParser.lastIndex}else{break}}if(index<message.length){togo.push(message.substring(index))}return togo};fluid.renderActivity=function(activityStack,renderer){renderer=renderer||fluid.renderOneActivity;return activityStack.map(renderer)};fluid.activityStack=[];fluid.getActivityStack=function(){return fluid.activityStack};fluid.logActivity=function(activity){activity=activity||fluid.getActivityStack();const rendered=fluid.renderActivity(activity).reverse();if(rendered.length>0){fluid.log("Current activity: ");fluid.each(rendered,(function(args){fluid.log.apply(null,args)}))}};fluid.pushActivity=function(type,message,args){const record={type:type,message:message,args:args,time:(new Date).getTime()};if(fluid.activityTracing){fluid.activityTrace.push(record)}if(fluid.passLogLevel(fluid.logLevel.TRACE)){fluid.log.apply(null,fluid.renderOneActivity(record,true))}const activityStack=fluid.getActivityStack();activityStack.push(record)};fluid.popActivity=function(popframes){popframes=popframes||1;if(fluid.activityTracing){fluid.activityTrace.push({pop:popframes})}const activityStack=fluid.getActivityStack();const popped=activityStack.length-popframes;activityStack.length=popped<0?0:popped};fluid.FluidError=function(){const togo=Error.apply(this,arguments);this.message=togo.message;this.stack=togo.stack;return this};fluid.FluidError.prototype=Object.create(Error.prototype);fluid.logFailure=function(args,activity){fluid.log.apply(null,[fluid.logLevel.FAIL,"ASSERTION FAILED: "].concat(args));fluid.logActivity(activity)};fluid.renderCause=function(cause){let message=cause.message;if(cause.path){message+=" at path "+cause.path}if(cause.site){message+=fluid.dumpComponentAndPath(cause.site.that)}return message};fluid.renderUnavailable=function(unavailable){return["Causes:",...unavailable.causes.map((cause=>fluid.renderCause(cause)))].join("\n")};fluid.renderLoggingArg=function(arg){return arg===undefined?"undefined":fluid.isUnavailable(arg)?fluid.renderUnavailable(arg):fluid.isPrimitive(arg)||!fluid.isPlainObject(arg)?arg:JSON.stringify(arg)};fluid.builtinFail=function(args){const message=args.map(fluid.renderLoggingArg).join(" ");throw new fluid.FluidError("Assertion failure - check console for more details:\n"+message)};fluid.fail=function(...messages){const activity=fluid.makeArray(fluid.getActivityStack());fluid.popActivity(activity.length);if(fluid.failureEvent){fluid.failureEvent.fire(messages,activity)}else{fluid.logFailure(messages,activity);fluid.builtinFail(messages,activity)}};fluid.expect=function(name,target,members){fluid.transform(fluid.makeArray(members),(function(key){if(target[key]===undefined){fluid.fail(name+" missing required member "+key)}}))};fluid.isLogging=function(){return fluid.logLevelStack[0].priority>fluid.logLevel.IMPORTANT.priority};fluid.isLogLevel=function(arg){return fluid.isMarker(arg)&&arg.priority!==undefined};fluid.passLogLevel=function(testLogLevel){return testLogLevel.priority<=fluid.logLevelStack[0].priority};fluid.setLogging=function(enabled){let logLevel;if(typeof enabled==="boolean"){logLevel=fluid.logLevel[enabled?"INFO":"IMPORTANT"]}else if(fluid.isLogLevel(enabled)){logLevel=enabled}else{fluid.fail("Unrecognised fluid logging level ",enabled)}fluid.logLevelStack.unshift(logLevel);fluid.defeatLogging=!fluid.isLogging()};fluid.setLogLevel=fluid.setLogging;fluid.popLogging=function(){const togo=fluid.logLevelStack.length===1?fluid.logLevelStack[0]:fluid.logLevelStack.shift();fluid.defeatLogging=!fluid.isLogging();return togo};fluid.doBrowserLog=function(args){if(typeof console!=="undefined"){if(console.debug){console.debug.apply(console,args)}else if(typeof console.log==="function"){console.log.apply(console,args)}}};fluid.log=function(){const directArgs=fluid.makeArray(arguments);let userLogLevel=fluid.logLevel.INFO;if(fluid.isLogLevel(directArgs[0])){userLogLevel=directArgs.shift()}if(fluid.passLogLevel(userLogLevel)){fluid.loggingEvent.fire(directArgs)}};fluid.isPrimitive=function(value){const valueType=typeof value;return!value||valueType==="string"||valueType==="boolean"||valueType==="number"||valueType==="function"};fluid.isArrayable=function(totest){return Boolean(totest)&&Object.prototype.toString.call(totest)==="[object Array]"};fluid.isPlainObject=function(totest,strict){const string=Object.prototype.toString.call(totest);if(string==="[object Array]"){return!strict}else if(string!=="[object Object]"){return false}const prototype=Object.getPrototypeOf(totest);return prototype===null||prototype===Object.prototype||Object.getPrototypeOf(prototype)===null};fluid.typeCode=function(totest){return fluid.isPrimitive(totest)||!fluid.isPlainObject(totest)?"primitive":fluid.isArrayable(totest)?"array":"object"};fluid.isILReference=function(ref){return typeof ref==="string"&&ref.charAt(0)==="{"};fluid.isReferenceOrExpander=function(ref){return ref&&(fluid.isILReference(ref)||ref.expander)};fluid.isDOMNode=function(obj){return obj&&typeof obj.nodeType==="number"};fluid.isUncopyable=function(totest){return fluid.isPrimitive(totest)||!fluid.isPlainObject(totest)};fluid.notImplemented=function(){fluid.fail("This operation is not implemented")};fluid.identity=function(arg){return arg};fluid.freshContainer=function(tocopy){return fluid.isArrayable(tocopy)?[]:{}};fluid.testStrategyRecursion=function(funcName,segs){if(segs.length>fluid.strategyRecursionBailout){fluid.fail("Runaway recursion encountered in "+funcName+" - reached path depth of "+fluid.strategyRecursionBailout+" via path of "+segs.join(".")+"this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout")}};fluid.copy=function(tocopy,segs=[]){fluid.testStrategyRecursion("fluid.copy",segs);const copyMember=function(value,key){segs.push(key);const togo=fluid.copy(value,segs);segs.pop();return togo};if(fluid.isUncopyable(tocopy)){return tocopy}else if(Array.isArray(tocopy)){return tocopy.map(((value,key)=>copyMember(value,key)))}else{return fluid.transform(tocopy,copyMember)}};fluid.makeArray=function(arg){return arg===null||arg===undefined?[]:fluid.isPrimitive(arg)||typeof arg[Symbol.iterator]!=="function"?[arg]:[...arg]};fluid.pushArray=function(holder,member,topush){const array=holder[member]?holder[member]:holder[member]=[];if(Array.isArray(topush)){array.push.apply(array,topush)}else{array.push(topush)}};fluid.transform=function(source,func){if(source){const togo={};for(const key in source){const ret=func(source[key],key);if(ret!==fluid.NoValue){togo[key]=ret}}return togo}else{return source}};fluid.each=function(source,func){if(source){for(const key in source){func(source[key],key)}}};fluid.peek=function(array){return array.length===0?undefined:array[array.length-1]};fluid.remove_if=function(source,fn,target){if(fluid.isArrayable(source)){for(let i=source.length-1;i>=0;--i){if(fn(source[i],i)){if(target){target.unshift(source[i])}source.splice(i,1)}}}else{for(const key in source){if(fn(source[key],key)){if(target){target[key]=source[key]}delete source[key]}}}return target||source};fluid.iota=function(count,first){first=first||0;const togo=[];for(let i=0;i<count;++i){togo[togo.length]=first++}return togo};fluid.getMembers=function(holder,name){return fluid.transform(holder,(function(member){return fluid.get(member,name)}))};fluid.filterKeys=function(toFilter,keys,exclude){return fluid.remove_if($.extend({},toFilter),(function(value,key){return exclude^keys.indexOf(key)===-1}))};fluid.censorKeys=function(toCensor,keys){return fluid.filterKeys(toCensor,keys,true)};fluid.parseInteger=function(string){return isFinite(string)&&string%1===0?Number(string):NaN};fluid.clear=function(target){for(let i in target){delete target[i]}};fluid.freezeRecursive=function(tofreeze,segs){segs=segs||[];fluid.testStrategyRecursion("fluid.freezeRecursive",segs);if(fluid.isPlainObject(tofreeze)){fluid.each(tofreeze,(function(value,key){segs.push(key);fluid.freezeRecursive(value,segs);segs.pop()}));return Object.freeze(tofreeze)}else{return tofreeze}};fluid.marker=function(){};fluid.makeMarker=function(type,extra,mutable){const togo=Object.create(fluid.marker.prototype);Object.assign(togo,{...extra||{},...{type:type}});return mutable?togo:Object.freeze(togo)};fluid.NoValue=fluid.makeMarker("No Value");fluid.isMarker=function(totest,types){if(!(totest instanceof fluid.marker)){return false}if(!types){return true}else if(typeof types==="string"){return totest.type===types}else{return types.includes(totest.type)}};fluid.logLevelsSpec={FATAL:0,FAIL:5,WARN:10,IMPORTANT:12,INFO:15,TRACE:20};fluid.logLevel=fluid.transform(fluid.logLevelsSpec,((key,value)=>fluid.makeMarker(key,{priority:value})));fluid.logLevelStack=[fluid.logLevel.IMPORTANT];fluid.unavailable=(cause={},variety="error")=>fluid.makeMarker("Unavailable",{causes:fluid.makeArray(cause).map((oneCause=>{if(typeof oneCause==="string"){oneCause={message:oneCause}}if(!oneCause.type){oneCause.type="Unavailable"}return oneCause})),variety:variety},true);fluid.formatUnavailable=function(unavailable){return"Value is unavailable: causes are "+unavailable.causes.map((cause=>cause.message)).join("\n")};fluid.unavailableProxy=function(target){const proxy=new Proxy(target,{get:function(target,prop){if(prop===$t){return target}else if(prop===Symbol.toPrimitive){fluid.fail(fluid.formatUnavailable(target))}else if(prop==="toString"){return()=>fluid.formatUnavailable(target)}else{return proxy}},getOwnPropertyDescriptor:function(target,key){return{value:this.get(target,key),enumerable:true,configurable:true}},getPrototypeOf:()=>Object.getPrototypeOf(fluid.deSignal(target))});return proxy};fluid.error=(...args)=>fluid.makeMarker("Unavailable",{causes:[{variety:"error",message:args}]},true);fluid.isUnavailable=totest=>totest instanceof fluid.marker&&totest.type==="Unavailable";fluid.mergeUnavailable=function(existing,fresh){return!existing?fresh:fluid.unavailable(existing.causes.concat(fresh.causes))};fluid.coerceToPrimitive=function(string){return/^(true|false|null)$/.test(string)||/^[\[{0-9]/.test(string)&&!/^{[\w|\${]/.test(string)?JSON.parse(string):string};fluid.isSignal=value=>value instanceof preactSignalsCore.Signal;fluid.deSignal=ref=>{while(fluid.isSignal(ref)){ref=ref.value}return ref};fluid.defaultSignalOptions={flattenArg:fluid.deSignal};fluid.OldValue=fluid.makeMarker("Old Computed Value");fluid.processSignalArgs=function(args,options,oldValue){let unavailable=undefined;const designalArgs=[];const flattenArg=options?.flattenArg;for(let i=0;i<args.length;++i){let arg=args[i];if(arg instanceof preactSignalsCore.Signal){arg=flattenArg?flattenArg(arg,i):arg.value}if(arg===fluid.OldValue){arg=fluid.isUnavailable(oldValue)?null:oldValue}if(fluid.isUnavailable(arg)){unavailable=fluid.mergeUnavailable(unavailable,arg)}designalArgs.push(arg)}return{designalArgs:designalArgs,unavailable:unavailable}};fluid.computed=function(funcSignal,argSignals,options){return computed((function fluidComputed(oldValue){const{designalArgs:designalArgs,unavailable:unavailable}=fluid.processSignalArgs(argSignals,options||fluid.defaultSignalOptions,oldValue);const func=fluid.deSignal(funcSignal);return unavailable?unavailable:fluid.isUnavailable(func)?func:func.apply(null,designalArgs)}))};fluid.effect=function(func,args,options){const togo=effect((function fluidEffect(){const{designalArgs:designalArgs,unavailable:unavailable}=fluid.processSignalArgs(args,options||fluid.defaultSignalOptions);if(!unavailable){untracked((()=>func.apply(this,designalArgs)))}}));togo.$func=func;return togo};fluid.disposeEffects=function(effectStructure){if(effectStructure instanceof preactSignalsCore.Effect){effectStructure._dispose()}else if(Array.isArray(effectStructure)){effectStructure.forEach((effect=>effect._dispose()));effectStructure.length=0}else{Object.values(effectStructure).forEach((value=>fluid.disposeEffects(value)))}};fluid.singleSourceEffect=function(aComputed,fn){let oldValue=aComputed.value;return effect((()=>{const newValue=aComputed.value;if(oldValue!==newValue){fn(oldValue,newValue);oldValue=newValue}}))};fluid.sampleComputed=computed((()=>{}));const computedPrototype=Object.getPrototypeOf(fluid.sampleComputed);const computedPrototypeDescriptor=Object.getOwnPropertyDescriptor(computedPrototype,"value");fluid.delegateUnavailable=fluid.unavailable({message:"No written value for delegated signal"});fluid.DelegatedSignal=function(outerSignal,onWrite,onReset){const computer=computed((()=>{const targetValue=computer._target.value;return fluid.isUnavailable(targetValue)?computer._outerSignal.value:targetValue}));Object.setPrototypeOf(computer,fluid.DelegatedSignal.prototype);computer._outerSignal=outerSignal;computer._onWrite=onWrite;computer._onReset=onReset;computer._target=signal(fluid.delegateUnavailable);return computer};fluid.DelegatedSignal.prototype=fluid.sampleComputed;fluid.DelegatedSignal.prototype.reset=function(){if(this._onReset){this.onReset(this._target,this)}this._target.value=fluid.delegateUnavailable};Object.defineProperty(fluid.DelegatedSignal.prototype,"value",{get:computedPrototypeDescriptor.get,set:function(newValue){if(this._target){this._target.value=newValue}else{this._target=signal(newValue);if(this._onWrite){this._onWrite(this._target,this)}}}});fluid.delegatedSignal=function(outerSignal,onWrite,onReset){return new fluid.DelegatedSignal(outerSignal,onWrite,onReset)};fluid.getPathSegmentImpl=function(accept,path,i){let segment="";let escaped=false;const limit=path.length;for(;i<limit;++i){const c=path.charAt(i);if(!escaped){if(c==="."){break}else if(c==="\\"){escaped=true}else{segment+=c}}else{escaped=false;segment+=c}}accept[0]=segment;return i};fluid.parsePath=function(path){const togo=[],accept=[null];let index=0;const limit=path.length;while(index<limit){const firstdot=fluid.getPathSegmentImpl(accept,path,index);togo.push(accept[0]);index=firstdot+1}return togo};fluid.pathToSegs=function(path){return fluid.isPrimitive(path)?fluid.parsePath(path):path};fluid.composePath=function(prefix,toappend){toappend=toappend.toString();for(let i=0;i<toappend.length;++i){const c=toappend.charAt(i);if(c==="."||c==="\\"||c==="}"){prefix+="\\"}prefix+=c}return prefix};fluid.composeSegment=function(prefix,suffix){if(prefix.length!==0){prefix+="."}return fluid.composePath(prefix,suffix)};fluid.composeSegments=function(segments){let path="";for(let i=0;i<segments.length;++i){path=fluid.composeSegment(path,segments[i])}return path};fluid.get=function(root,path){const segs=fluid.pathToSegs(path);const limit=segs.length;for(let j=0;j<limit;++j){root=root?root[segs[j]]:undefined}return root};fluid.getThroughSignals=function(root,segs){const togo=computed((function getThroughSignals(){let move=fluid.deSignal(root);for(let j=0;j<segs.length;++j){if(!move||fluid.isUnavailable(move)){break}const seg=segs[j];if(!(seg in move)&&root[$m]){move=fluid.unavailable({messageKey:"NoMember",memberName:seg,layer:root});break}move=fluid.deSignal(move[seg])}return move}));togo.$variety="$ref";return togo};fluid.set=function(root,path,newValue){const segs=fluid.pathToSegs(path);for(let i=0;i<segs.length-1;++i){const seg=segs[i];if(!root[seg]){root[seg]=Object.create(null)}root=root[seg]}root[segs[segs.length-1]]=newValue};fluid.shallowCopy=function(source){return Array.isArray(source)?source.slice():{...source}};fluid.setImmutable=function(root,path,newValue){const segs=fluid.pathToSegs(path);if(segs.length===0){return newValue}else{let newRoot=fluid.shallowCopy(root);let current=newRoot;for(let i=0;i<segs.length-1;++i){const seg=segs[i];let next=current[seg];if(next===undefined||next===null){next={}}const copied=fluid.shallowCopy(next);current[seg]=copied;current=copied}current[segs[segs.length-1]]=newValue;return newRoot}};fluid.getRecInsist=function(root,segs){segs.forEach((seg=>{if(!root[seg]){root[seg]=Object.create(null)}root=root[seg]}));return root};fluid.forEachDeep=function(root,visitor,segs=[]){if(fluid.isPlainObject(root,true)){if(root[$m]){visitor(root[$m],segs)}fluid.each(root,((value,key)=>{segs.push(key);fluid.forEachDeep(value,visitor,segs);segs.pop()}))}};fluid.getGlobalValue=path=>{const value=fluid.get(fluid.global,path);return value===undefined?fluid.unavailable({message:"Global value "+path+" is not defined",path:path}):value};fluid.invokeGlobalFunction=function(functionPath,args){const func=fluid.getGlobalValue(functionPath);if(fluid.isUnavailable(func)){return fluid.mergeUnavailable(fluid.unavailable({message:"Error invoking global function: "+functionPath+" could not be located"}),func)}else{const argsArray=fluid.isArrayable(args)?args:fluid.makeArray(args);return func.apply(null,argsArray)}};fluid.setGlobalValue=(path,value)=>{fluid.set(fluid.global,path,value)};fluid.registerNamespace=function(path){let existing=fluid.getGlobalValue(path);if(fluid.isUnavailable(existing)){existing={};fluid.setGlobalValue(path,existing)}return existing};fluid.dumpEl=x=>x;fluid.renderTimestamp=x=>x;fluid.generateUniquePrefix=function(){return Math.floor(Math.random()*1e12).toString(36)+"-"};const fluid_prefix=fluid.generateUniquePrefix();fluid.fluidInstance=fluid_prefix;let fluid_guid=1;fluid.allocateGuid=function(){return fluid_prefix+fluid_guid++};fluid.extremePriority=4e9;fluid.priorityTypes={first:-1,last:1,before:0,after:0};fluid.extremalPriorities={none:0,transaction:10,testing:20,authoring:30};fluid.parsePriorityConstraint=function(constraint,fixedOnly,site){const segs=constraint.split(":");const type=segs[0];const lookup=fluid.priorityTypes[type];if(lookup===undefined){fluid.fail("Invalid constraint type in priority field "+constraint+": the only supported values are "+fluid.keys(fluid.priorityTypes).join(", ")+" or numeric")}if(fixedOnly&&lookup===0){fluid.fail("Constraint type in priority field "+constraint+" is not supported in a "+site+" record - you must use either a numeric value or first, last")}return{type:segs[0],target:segs[1]}};fluid.parsePriority=function(priority,count,fixedOnly,site){priority=priority||0;const togo={count:count||0,fixed:null,constraint:null,site:site};if(typeof priority==="number"){togo.fixed=-priority}else{togo.constraint=fluid.parsePriorityConstraint(priority,fixedOnly,site)}const multiplier=togo.constraint?fluid.priorityTypes[togo.constraint.type]:0;if(multiplier!==0){const target=togo.constraint.target||"none";const extremal=fluid.extremalPriorities[target];if(extremal===undefined){fluid.fail("Unrecognised extremal priority target "+target+": the currently supported values are "+fluid.keys(fluid.extremalPriorities).join(", ")+": register your value in fluid.extremalPriorities")}togo.fixed=multiplier*(fluid.extremePriority+extremal)}if(togo.fixed!==null){togo.fixed+=togo.count/1024}return togo};fluid.renderPriority=function(parsed){return parsed.constraint?parsed.constraint.target?parsed.constraint.type+":"+parsed.constraint.target:parsed.constraint.type:Math.floor(parsed.fixed)};fluid.compareByPriority=function(recA,recB){if(recA.priority.fixed!==null&&recB.priority.fixed!==null){return recA.priority.fixed-recB.priority.fixed}else{return(recA.priority.fixed===null)-(recB.priority.fixed===null)}};fluid.honourConstraint=function(array,firstConstraint,c){const constraint=array[c].priority.constraint;const matchIndex=array.findIndex((element=>element.namespace===constraint.target));if(matchIndex===-1){return true}else if(matchIndex>=firstConstraint){return false}else{const offset=constraint.type==="after"?1:0;const target=matchIndex+offset;const temp=array[c];for(let shift=c;shift>=target;--shift){array[shift]=array[shift-1]}array[target]=temp;return true}};fluid.sortByPriority=function(array){array.sort(fluid.compareByPriority);let firstConstraint=array.findIndex((element=>element.priority.constraint&&fluid.priorityTypes[element.priority.constraint.type]===0));if(firstConstraint===-1){firstConstraint=array.length}while(true){if(firstConstraint===array.length){return array}const oldFirstConstraint=firstConstraint;for(let c=firstConstraint;c<array.length;++c){const applied=fluid.honourConstraint(array,firstConstraint,c);if(applied){++firstConstraint}}if(firstConstraint===oldFirstConstraint){const holders=array.slice(firstConstraint);fluid.fail("Could not find targets for any constraints in "+holders[0].priority.site+" ",holders,": none of the targets ("+holders.map((holder=>holder.priority.constraint.target)).join(", ")+") matched any namespaces of the elements in (",array.slice(0,firstConstraint),") - this is caused by either an invalid or circular reference")}}};fluid.parsePriorityRecords=function(records,name){const array=fluid.hashToArray(records,"namespace",(function(newElement,oldElement){$.extend(newElement,oldElement);newElement.priority=fluid.parsePriority(oldElement.priority,0,false,name)}));fluid.sortByPriority(array);return array};fluid.registerNamespace("fluid.event");fluid.event.identifyListener=function(listener,soft){if(typeof listener!=="string"&&!listener.$$fluid_guid&&!soft){listener.$$fluid_guid=fluid.allocateGuid()}return listener.$$fluid_guid};fluid.event.impersonateListener=function(origListener,newListener){fluid.event.identifyListener(origListener);newListener.$$fluid_guid=origListener.$$fluid_guid};fluid.event.sortListeners=function(listeners){let togo=[];Object.values(listeners).forEach((oneNamespace=>{let headHard;for(let i=0;i<oneNamespace.length;++i){const thisListener=oneNamespace[i];if(!thisListener.softNamespace&&!headHard){headHard=thisListener}}if(headHard){togo.push(headHard)}else{togo=togo.concat(oneNamespace)}}));return fluid.sortByPriority(togo)};fluid.event.resolveListener=function(listener){const listenerName=listener.globalName||(typeof listener==="string"?listener:null);if(listenerName){const listenerFunc=fluid.getGlobalValue(listenerName);if(!listenerFunc){fluid.fail("Unable to look up name "+listenerName+" as a global function")}else{listener=listenerFunc}}return listener};fluid.nameComponent=function(that){return that?fluid.dumpComponentAndPath(that):"[unknown component]"};fluid.event.nameEvent=function(that,eventName){return eventName+" of "+fluid.nameComponent(that)};fluid.event.firer=function(){};fluid.makeEventFirer=function(options){options=options||{};const name=options.name||"<anonymous>";let that;const lazyInit=function(){that.listeners={};that.byId={};that.sortedListeners=[];that.onDestroy=null;that.addListener=function(listener,namespace,priority,softNamespace,listenerId){let record;if(that.destroyed){fluid.fail("Cannot add listener to destroyed event firer "+that.name)}if(!listener){return}if(fluid.isPlainObject(listener,true)&&!fluid.isApplicable(listener)){record=listener;listener=record.listener;namespace=record.namespace;priority=record.priority;softNamespace=record.softNamespace;listenerId=record.listenerId}if(typeof listener==="string"){listener={globalName:listener}}const id=listenerId||fluid.event.identifyListener(listener);namespace=namespace||id;record=Object.assign(record||{},{namespace:namespace,listener:listener,softNamespace:softNamespace,listenerId:listenerId,priority:fluid.parsePriority(priority,that.sortedListeners.length,false,"listeners")});that.byId[id]=record;const thisListeners=that.listeners[namespace]=fluid.makeArray(that.listeners[namespace]);thisListeners[softNamespace?"push":"unshift"](record);that.sortedListeners=fluid.event.sortListeners(that.listeners)};that.addListener.apply(null,arguments)};that=Object.create(fluid.event.firer.prototype);Object.assign(that,{eventId:fluid.allocateGuid(),name:name,ownerId:options.ownerId,typeName:"fluid.event.firer",destroy:function(){that.destroyed=true;fluid.each(that.onDestroy,(function(func){func()}))},addListener:function(){lazyInit.apply(null,arguments)},removeListener:function(listener){if(!that.listeners){return}let namespace,id,record;if(typeof listener==="string"){namespace=listener;record=that.listeners[namespace];if(!record){id=namespace;namespace=null}}else if(typeof listener==="function"){id=fluid.event.identifyListener(listener,true);if(!id){fluid.fail("Cannot remove unregistered listener function ",listener," from event "+that.name)}}const rec=that.byId[id];const softNamespace=rec&&rec.softNamespace;namespace=namespace||rec&&rec.namespace||id;delete that.byId[id];record=that.listeners[namespace];if(record){if(softNamespace){fluid.remove_if(record,(function(thisLis){return thisLis.listener.$$fluid_guid===id||thisLis.listenerId===id}))}else{record.shift()}if(record.length===0){delete that.listeners[namespace]}}that.sortedListeners=fluid.event.sortListeners(that.listeners)},fire:function(){const listeners=that.sortedListeners;if(options.promise){that.promisePayload=arguments[0]}if(!listeners||that.destroyed){return}for(let i=0;i<listeners.length;++i){const lisrec=listeners[i];if(typeof lisrec.listener!=="function"){lisrec.listener=fluid.event.resolveListener(lisrec.listener)}const listener=lisrec.listener;const ret=listener.apply(null,arguments);let value;if(options.preventable&&ret===false||that.destroyed){value=false}if(value!==undefined){return value}}}});if(options.promise){that.then=function(func){if("promisePayload"in that){func(that.promisePayload)}else{that.addListener(func)}}}return that};fluid.fireEvent=function(component,eventName,args){const firer=component.events&&component.events[eventName];if(firer){firer.fire.apply(null,fluid.makeArray(args))}};fluid.event.addListenerToFirer=function(firer,value,namespace,wrapper){wrapper=wrapper||(x=>x);if(fluid.isArrayable(value)){for(let i=0;i<value.length;++i){fluid.event.addListenerToFirer(firer,value[i],namespace,wrapper)}}else if(typeof value==="function"||typeof value==="string"){wrapper(firer).addListener(value,namespace)}else if(value&&typeof value==="object"){wrapper(firer).addListener(value.listener,namespace||value.namespace,value.priority,value.softNamespace,value.listenerId)}};fluid.event.resolveListenerRecord=function(records){return{records:records}};fluid.expandImmediate=function(material){fluid.fail("fluid.expandImmediate could not be loaded - please include FluidIL.js in order to operate IL event with descriptor "+material)};fluid.mergeListeners=function(that,events,listeners){fluid.each(listeners,(function(value,key){let firer,namespace;if(fluid.isILReference(key)){firer=fluid.expandImmediate(key,that);if(!firer){fluid.fail("Error in listener record: key "+key+' could not be looked up to an event firer - did you miss out "events." when referring to an event firer?')}}else{const keydot=key.indexOf(".");if(keydot!==-1){namespace=key.substring(keydot+1);key=key.substring(0,keydot)}if(!events[key]){fluid.fail("Listener registered for event "+key+" which is not defined for this component")}firer=events[key]}const record=fluid.event.resolveListenerRecord(value,that,key,namespace,true);fluid.event.addListenerToFirer(firer,record.records,namespace,record.adderWrapper)}))};fluid.eventFromRecord=function(eventSpec,eventKey,that){const isILEvent=eventSpec&&(typeof eventSpec!=="string"||fluid.isILReference(eventSpec));let event;if(isILEvent){if(!fluid.event.resolveEvent){fluid.fail("fluid.event.resolveEvent could not be loaded - please include FluidIL.js in order to operate IL driven event with descriptor ",eventSpec)}else{event=fluid.event.resolveEvent(that,eventKey,eventSpec)}}else{event=fluid.makeEventFirer({name:fluid.event.nameEvent(that,eventKey),preventable:eventSpec==="preventable",promise:eventSpec==="promise",ownerId:that.id})}return event};fluid.mergeListenerPolicy=function(target,source,key){if(typeof key!=="string"){fluid.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got "+key+" from ",source)}const hasNamespace=!fluid.isILReference(key)&&key.indexOf(".")!==-1;return hasNamespace?source||target:fluid.arrayConcatPolicy(target,source)};fluid.makeMergeListenersPolicy=function(merger,modelRelay){return function(target,source){target=target||{};if(modelRelay&&(fluid.isArrayable(source)||"target"in source&&(typeof source.target==="string"||source.target.segs))){target[""]=merger(target[""],source,"")}else{fluid.each(source,(function(listeners,key){target[key]=merger(target[key],listeners,key)}))}return target}};fluid.validateListenersImplemented=function(that){const errors=[];fluid.each(that.events,(function(event,name){fluid.each(event.sortedListeners,(function(lisrec){if(lisrec.listener===fluid.notImplemented||lisrec.listener.globalName==="fluid.notImplemented"){errors.push({name:name,namespace:lisrec.namespace,componentSource:fluid.model.getSimple(that.options.listeners,[name+"."+lisrec.namespace,0,"componentSource"])})}}))}));return errors};fluid.arrayConcatPolicy=function(target,source){return fluid.makeArray(target).concat(fluid.makeArray(source))};fluid.loggingEvent=fluid.makeEventFirer({name:"logging event"});fluid.addTimestampArg=function(args){const arg0=fluid.renderTimestamp(new Date)+":  ";args.unshift(arg0)};fluid.loggingEvent.addListener(fluid.doBrowserLog,"log");fluid.loggingEvent.addListener((x=>x),"filterArgs","before:log");fluid.loggingEvent.addListener(fluid.addTimestampArg,"addTimestampArg","after:filterArgs");fluid.upgradeError=function(originError,whileMsg){const error=originError instanceof Error?originError:fluid.isPrimitive(originError)?{message:originError}:fluid.extend({},originError);error.message=error.message+whileMsg;return error};fluid.failureEvent=fluid.makeEventFirer({name:"failure event"});fluid.failureEvent.addListener(fluid.builtinFail,"fail");fluid.failureEvent.addListener(fluid.logFailure,"log","before:fail");fluid.C3_merge=function(seqs){fluid.log(`\n\nCPL[${seqs[0][0]}]=${JSON.stringify(seqs)}`);let res=[];let i=0;while(true){let nonemptyseqs=seqs.filter((seq=>seq.length>0));if(nonemptyseqs.length===0){return res}i++;fluid.log(`\n${i} round: candidates...`);let cand=null;for(let seq of nonemptyseqs){cand=seq[0];fluid.log(` ${cand}`);let nothead=nonemptyseqs.filter((s=>s.indexOf(cand)>0));if(nothead.length>0){cand=null}else{break}}if(!cand){fluid.fail(`Inconsistent hierarchy for layer ${res[0]}: conflict between parent orders ${nonemptyseqs.map((ns=>ns.toString())).join(", ")}`)}res.push(cand);for(let seq of nonemptyseqs){while(seq[0]===cand){seq.shift()}}}};fluid.C3_precedence=function(C,defs,visited){if(visited.has(C)){fluid.fail(`Circular hierarchy detected - layer ${C} has already been visited`)}visited.add(C);const def=defs[C];if(!def){fluid.fail(`Parent layer ${C} referenced which is not defined`)}const parents=Array.from(defs[C].$layers);const precLists=parents.map((parent=>fluid.C3_precedence(parent,defs,visited)));const merged=fluid.C3_merge([[C]].concat(precLists).concat([parents]));visited.delete(C);return merged};fluid.C3_precedence_parents=function(parents,defs){const visited=new Set;const precLists=parents.map((parent=>fluid.C3_precedence(parent,defs,visited)));const merged=fluid.C3_merge(precLists);return merged};fluid.proxySymbol=Symbol("fluid.proxyTarget");const $t=fluid.proxySymbol;fluid.unProxy=target=>target?.[$t]?target[$t]:target;fluid.metadataSymbol=Symbol("fluid.metadata");const $m=fluid.metadataSymbol;fluid.makeLayer=function(memberName,parent){const togo=Object.create(null);togo[$m]={type:"layer",memberName:memberName,parent:parent};return togo};fluid.layerStore=signal({});fluid.layerHistory=[];fluid.newLayer=function(layerName,layerValue){const store=fluid.layerStore.value;const newStore={...store,[layerName]:signal(layerValue)};fluid.layerStore.value=newStore;fluid.layerHistory.push({type:"newLayer",store:newStore,newLayer:layerName})};fluid.readLayer=function(layerName){const store=fluid.layerStore.peek();const layerSig=store[layerName];if(layerSig){return layerSig}else{return store[layerName]=signal(fluid.unavailable({message:"Layer "+layerName+" is not defined",path:["layer",layerName]}))}};fluid.writeLayer=function(layerName,layer){const store=fluid.layerStore.peek();const layerSig=store[layerName];const layerValue={raw:layer};if(layerSig){layerSig.value=layerValue}else{fluid.newLayer(layerName,layerValue)}};fluid.deleteLayer=function(layerName){const currentStore=fluid.layerStore.value;const newStore={...currentStore};delete newStore[layerName];fluid.layerStore.value=newStore;fluid.layerHistory.push({type:"deleteLayer",store:newStore,deleteLayer:layerName})};fluid.readerExpandLayer=function(layer){return{...layer,$layers:fluid.makeArray(layer.$layers)}};fluid.mergeRecordTypes={def:1e3,subcomponent:700,user:600,distribution:300,template:200,live:100,defParents:0};fluid.mergeLayers=function(target,segs,layerMap,layers,mergeRecords){const clayers=layers.length;const allKeysRec={};layers.forEach((layer=>{if(fluid.isPlainObject(layer,true)){Object.keys(layer).forEach((key=>allKeysRec[key]=true))}}));delete allKeysRec["$variety"];const allKeys=Object.keys(allKeysRec);allKeys.forEach((key=>{let count=0;let last,newTarget;let lastIndex=-1;for(let i=0;i<clayers;++i){const layer=layers[i];if(fluid.isPlainObject(layer)&&key in layer){++count;last=layer[key];lastIndex=i}}if(count>1&&fluid.isPlainObject(last,true)){newTarget=fluid.makeLayer(key,target);const newLayers=layers.map((layer=>layer?.[key]));segs.push(key);fluid.mergeLayers(newTarget,segs,layerMap,newLayers,mergeRecords);segs.pop()}else{newTarget=last}target[key]=newTarget;fluid.set(layerMap,[...segs,key,$m,"source"],mergeRecords[lastIndex].mergeRecordName)}))};fluid.extractPolicy=function(layer,layerMap,segs=[]){const recurse=function(value,key){segs.push(key);fluid.extractPolicy(value,layerMap,segs);segs.pop()};if(fluid.isPlainObject(layer,true)){const allKeys=Object.keys(layer);if("$reactiveRoot"in layer){fluid.set(layerMap,[...segs,$m,"reactiveRoot"],true);if(allKeys.length!==1){fluid.fail("Unexpected extra keys together with $reactiveRoot: "+allKeys.join(", "))}}else{fluid.transform(layer,recurse)}}else if(Array.isArray(layer)){layer.forEach(recurse)}};fluid.mergeLayerRecords=function(root,mergeRecords){const layerMap={},segs=[];mergeRecords.forEach((mergeRecord=>{if(!mergeRecord.priority){mergeRecord.priority=fluid.mergeRecordTypes[mergeRecord.mergeRecordType]}}));mergeRecords.sort(((a,b)=>b.priority-a.priority));const layers=mergeRecords.map((mergeRecord=>mergeRecord.layer));layers.forEach((layer=>fluid.extractPolicy(layer,layerMap)));fluid.mergeLayers(root,segs,layerMap,layers,mergeRecords);return layerMap};fluid.coOccurrenceRegistry=[];fluid.resolveCoOccurrences=function(layerNames){const togo=[];const existing=new Set(layerNames);for(const record of fluid.coOccurrenceRegistry){const{inputNames:inputNames,outputNames:outputNames}=record;const allPresent=inputNames.every((name=>existing.has(name)));if(allPresent){for(const outputName of outputNames){if(!existing.has(outputName)){togo.push(outputName)}}}}return togo};class HierarchyResolver{constructor(flatDefsIn={}){this.flatDefs=Object.assign({},flatDefsIn)}storeParents(layer,rootLayer){return layer.$layers.map((layerName=>{if(layerName===rootLayer){return signal(fluid.unavailable(`Layer name ${layerName} circularly refers to layer ${rootLayer}`))}else{return this.storeLayer(layerName,rootLayer)}}))}storeLayer(layerName,rootLayer){let layerComputer=this.flatDefs[layerName];if(!layerComputer){this.flatDefs[layerName]="in progress";this.flatDefs[layerName]=layerComputer=computed((()=>{const layer=fluid.readLayer(layerName).value;if(fluid.isUnavailable(layer)){return layer}else{const readerExpanded=fluid.readerExpandLayer(layer.raw);const parentComputers=this.storeParents(readerExpanded,rootLayer||layerName);const{unavailable:unavailable}=fluid.processSignalArgs(parentComputers);return unavailable||readerExpanded}}))}return layerComputer}resolveHierarchyRound=function(layerHierarchy,layerNames){const newCoOccurrences=fluid.resolveCoOccurrences(layerHierarchy);newCoOccurrences.map((layerName=>this.storeLayer(layerName)));layerNames.unshift(...newCoOccurrences);return newCoOccurrences.length>0};resolve(layerNames){const flatDefs=this.flatDefs;while(true){fluid.each(flatDefs,(def=>def.value));const{unavailable:unavailable}=fluid.processSignalArgs(Object.values(flatDefs));if(unavailable){return unavailable}else{const veryFlatDefs=fluid.transform(flatDefs,(def=>def.value));const order=fluid.C3_precedence_parents(layerNames,veryFlatDefs).reverse();if(this.resolveHierarchyRound(order,layerNames)){continue}const mergeRecords=order.map(((oneLayerName,i)=>({mergeRecordType:"def",mergeRecordName:oneLayerName,priority:fluid.mergeRecordTypes.def-i,layer:veryFlatDefs[oneLayerName]}))).concat({mergeRecordType:"defParents",mergeRecordName:"defParents",priority:fluid.mergeRecordTypes.defParents,layer:{$layers:order}});const merged={};return{mergeRecords:mergeRecords,merged:merged,layerMap:fluid.mergeLayerRecords(merged,mergeRecords)}}}}}fluid.HierarchyResolver=HierarchyResolver;fluid.hasLayer=function(layer,layerName){return layer.$layers&&layer.$layers.includes(layerName)};fluid.readMergedDef=function(layerName){const resolver=new fluid.HierarchyResolver;const resolved=computed((()=>{resolver.storeLayer(layerName);return resolver.resolve([layerName])}));return fluid.getThroughSignals(resolved,["merged"])};fluid.makeComponentCreator=function(componentName){const creator=function(){return fluid.initFreeComponent(componentName,arguments)};const existing=fluid.getGlobalValue(componentName);if(existing){Object.assign(creator,existing)}fluid.setGlobalValue(componentName,creator)};fluid.writeDef=function(layerName,layer){fluid.writeLayer(layerName,layer);fluid.makeComponentCreator(layerName)};fluid.def=function(layerName,layer){if(layer===undefined){return fluid.readLayer(layerName).value.raw}else{fluid.writeDef(layerName,layer)}};fluid.inEvaluationMarker=Object.freeze({__CURRENTLY_IN_EVALUATION__:true});fluid.def("fluid.function",{});fluid.invokeGradedFunction=function(name,spec){const defaults=fluid.def(name).value;if(!defaults||!defaults.argumentMap||!fluid.hasGrade(defaults,"fluid.function")){fluid.fail("Cannot look up name "+name+" to a function with registered argumentMap - got defaults ",defaults)}const args=[];fluid.each(defaults.argumentMap,(function(value,key){args[value]=spec[key]}));return fluid.invokeGlobalFunction(name,args)};const charStart="(?:[\\w\\u00c0-\\uFFFF*_-";fluid.simpleCSSMatcher={regexp:new RegExp("([#.]?)("+charStart+"]|\\\\.)+)","g"),charToTag:{"":"tag","#":"id",".":"clazz"}};fluid.ILSSMatcher={regexp:new RegExp("([&#]?)("+charStart+"]|\\.|\\/)+)","g"),charToTag:{"":"context","&":"context","#":"id"}};const childSeg=new RegExp("\\s*(>)?\\s*","g");fluid.parseSelector=function(selstring,strategy){const togo=[];selstring=selstring.trim();const regexp=strategy.regexp;regexp.lastIndex=0;let lastIndex=0;while(true){const atNode=[];let first=true;while(true){const segMatch=regexp.exec(selstring);if(!segMatch){break}if(segMatch.index!==lastIndex){if(first){fluid.fail("Error in selector string - cannot match child selector expression starting at "+selstring.substring(lastIndex))}else{break}}const thisNode={};const text=segMatch[2];const targetTag=strategy.charToTag[segMatch[1]];if(targetTag){thisNode[targetTag]=text}atNode[atNode.length]=thisNode;lastIndex=regexp.lastIndex;first=false}childSeg.lastIndex=lastIndex;const fullAtNode={predList:atNode};const childMatch=childSeg.exec(selstring);if(!childMatch||childMatch.index!==lastIndex){fluid.fail("Error in selector string - can not match child selector expression at "+selstring.substring(lastIndex))}if(childMatch[1]===">"){fullAtNode.child=true}togo[togo.length]=fullAtNode;if(childSeg.lastIndex>=selstring.length){break}lastIndex=childSeg.lastIndex;regexp.lastIndex=childSeg.lastIndex}return togo};fluid.oldStringTemplate=function(template,values){let keys=Object.keys(values);keys=keys.sort(((keya,keyb)=>keyb.length-keya.length));for(let i=0;i<keys.length;++i){const key=keys[i];const templatePlaceholder="%"+key;const replacementValue=values[key];let indexOfPlaceHolder=-1;while((indexOfPlaceHolder=template.indexOf(templatePlaceholder))!==-1){template=template.slice(0,indexOfPlaceHolder)+replacementValue+template.slice(indexOfPlaceHolder+templatePlaceholder.length)}}return template};const tagRE=/@\{((?:.)+?)\}/g;fluid.parseContextReference=function(reference,index){index=index||0;const endcpos=reference.indexOf("}",index+1);const context=reference.substring(index+1,endcpos);const colpos=reference.indexOf(":");let name;if(colpos!==-1){name=reference.substring(colpos+1);reference=reference.substring(0,colpos)}let path=reference.substring(endcpos+1,reference.length);if(path.charAt(0)==="."){path=path.substring(1)}return{context:context,path:path,name:name}};fluid.parseStringTemplate=function(template){const tokens=[];let lastIndex=0;let match;const parseKey=key=>({context:"self",path:key});while(match=tagRE.exec(template)){const index=match.index;if(index>lastIndex){tokens.push(template.slice(lastIndex,index))}const exp=match[1].trim();if(exp.startsWith("{")){const endIndex=template.indexOf("}",tagRE.lastIndex);if(endIndex===-1){throw new Error("Unmatched '{' in template: "+template)}const fullBody=template.slice(index+2,endIndex);tokens.push({raw:fullBody,parsed:fluid.parseContextReference(fullBody)});tagRE.lastIndex=endIndex+1}else{tokens.push({raw:exp,parsed:parseKey(exp)})}lastIndex=tagRE.lastIndex}if(lastIndex<template.length){tokens.push(template.slice(lastIndex))}return tokens};fluid.stringTemplate=function(template,model){const tokens=fluid.parseStringTemplate(template);const segs=tokens.map((token=>typeof token==="string"?token:fluid.get(model,token.parsed.path)));return segs.join("")}};var fluid=fluid||{};fluidJSScope(fluid);var exports={fluidJSScope:fluidJSScope};"use strict";const fluidILScope=function(fluid){var{signal:signal,computed:computed,effect:effect}=preactSignalsCore;const $m=fluid.metadataSymbol;const $t=fluid.proxySymbol;fluid.componentConstructor=function(){};fluid.shadow=function(){};Object.defineProperty(fluid.componentConstructor,"name",{value:"fluid.componentConstructor"});fluid.isComponent=function(obj){return obj&&obj.constructor===fluid.componentConstructor};fluid.isShadow=function(obj){return obj&&obj.constructor===fluid.shadow};fluid.freshComponent=function(props,shadow){const instance=Object.create(fluid.componentConstructor.prototype);fluid.each(props,((value,key)=>{instance[key]=signal(value)}));if(!instance.$id){const id=fluid.allocateGuid();instance.$id=id}shadow=shadow||Object.create(fluid.shadow.prototype);shadow.that=instance;instance[$m]=shadow;return instance};fluid.dumpLayerNames=function(that){return" layerNames: "+JSON.stringify(that.$layers)};fluid.dumpThat=function(that){return`{ id: ${that.$id} ${fluid.dumpLayerNames(that)}`};fluid.dumpThatStack=function(thatStack){const togo=fluid.transform(thatStack,(function(that){const path=that[$m].path;return fluid.dumpThat(that)+(path?" - path: "+path:"")}));return togo.join("\n")};fluid.dumpComponentPath=function(that){const path=that[$m].path;return path||"** no path registered for component **"};fluid.dumpComponentAndPath=function(that){return"component "+fluid.dumpThat(that)+" at path "+fluid.dumpComponentPath(that)};fluid.visitComponentChildren=function(shadow,visitor,options,segs){segs=segs||[];for(const name in shadow.childComponents){const childShadow=shadow.childComponents[name];if(options.visited&&options.visited[childShadow.$id]){continue}segs.push(name);if(options.visited){options.visited[childShadow.$id]=true}if(visitor(childShadow,name,segs,segs.length-1)){return true}if(!options.flat){fluid.visitComponentChildren(childShadow,visitor,options,segs)}segs.pop()}};fluid.contextName=1;fluid.memberName=2;fluid.layerNamesToScope=function(targetScope,layerNames,shadow){fluid.clear(targetScope);fluid.each(layerNames,(function(layerName){if(!fluid.isReferenceOrExpander(layerName)){const rec={value:shadow,priority:fluid.contextName};targetScope[layerName]=rec;targetScope[fluid.computeNickName(layerName)]=rec}}));return targetScope};fluid.applyToScope=function(scope,key,shadow,priority){const existing=scope[key];if(!existing||priority===fluid.memberName){scope[key]={value:shadow,priority:priority}}};fluid.cacheLayerScopes=function(parentShadow,shadow){const rootComponent=shadow.instantiator.rootComponent;shadow.childrenScope=Object.create(parentShadow?parentShadow.variableScope:null);shadow.childrenScope[$m]="childrenScope-"+shadow.path;shadow.ownScope=Object.create(shadow.childrenScope);shadow.ownScope[$m]="ownScope-"+shadow.path;shadow.variableScope=Object.create(shadow.ownScope);shadow.variableScope[$m]="variableScope-"+shadow.path;return effect((function scopeEffect(){const layers=shadow.computer?.value?.$layers||[];fluid.layerNamesToScope(shadow.ownScope,layers,shadow);fluid.applyToScope(shadow.ownScope,shadow.memberName,shadow,fluid.memberName);fluid.each(shadow.ownScope,(function(rec,context){if(shadow.parentShadow&&shadow.parentShadow.that!==rootComponent){fluid.applyToScope(shadow.parentShadow.childrenScope,context,rec.value,rec.priority)}if(shadow.ownScope["fluid.resolveRoot"]){fluid.applyToScope(rootComponent[$m].childrenScope,context,rec.value,rec.priority)}}))}))};fluid.clearScope=function(parentShadow,child,childShadow){fluid.each(childShadow.ownScope,((rec,context)=>{if(parentShadow.childrenScope[context].value===child){delete parentShadow.childrenScope[context]}}))};fluid.clearComponentIndexes=function(instantiator,destroyRec){const shadow=destroyRec.shadow;fluid.clearScope(shadow,destroyRec.child,destroyRec.childShadow,destroyRec.name);delete instantiator.pathToComponent[destroyRec.childPath];delete shadow.childComponents[destroyRec.name]};fluid.doDestroy=function(instantiator,destroyRec){const shadow=destroyRec.childShadow,that=destroyRec.child;fluid.each(shadow.injectedPaths,(function(troo,injectedPath){const segs=fluid.parsePath(injectedPath);const parentPath=segs.slice(0,-1);const otherShadow=instantiator.pathToComponent[parentPath];instantiator.clearComponent(otherShadow,fluid.peek(segs),that)}));fluid.clearComponentIndexes(instantiator,destroyRec);shadow.lifecycleStatus="destroyed";const child=destroyRec.childShadow.that;fluid.fireEvent(child,"afterDestroy",[child,destroyRec.name,destroyRec.shadow.that])};fluid.instantiator=function(){const that={pathToComponent:{}};function recordComponent(parentShadow,shadow,name,created){shadow.instantiator=that;const path=parentShadow?fluid.composeSegment(parentShadow.path,name):name;if(created){shadow.path=path;shadow.memberName=name;shadow.parentShadow=parentShadow;shadow.childComponents={};shadow.frameworkEffects={};shadow.frameworkEffects.scopeEffect=fluid.cacheLayerScopes(parentShadow,shadow)}else{shadow.injectedPaths=shadow.injectedPaths||{};shadow.injectedPaths[path]=true;const contextHash=shadow.contextHash.value;const keys=fluid.keys(contextHash);fluid.remove_if(keys,(function(key){return contextHash&&contextHash[key]===fluid.memberName}));keys.push(name);keys.forEach((function(context){if(!parentShadow.scope.hasOwnProperty(context)){parentShadow.scope[context]=shadow}}))}if(that.pathToComponent[path]){fluid.fail("Error during instantiation - path "+path+" which has just created component "+fluid.dumpThat(shadow)+" has already been used for component "+fluid.dumpThat(that.pathToComponent[path])+" - this is a circular instantiation or other oversight."+" Please clear the component using instantiator.clearComponent() before reusing the path.")}that.pathToComponent[path]=shadow}that.recordKnownComponent=function(parentShadow,shadow,name,created){const existing=parentShadow.childComponents[name];if(existing){if(existing!==shadow){fluid.fail("Attempt to register component at path ",existing.path," which has already been used for component ",existing)}}else{parentShadow.childComponents[name]=shadow;recordComponent(parentShadow,shadow,name,created)}};that.allocateSimpleComponent=function(parentShadow,name,props){const fresh=fluid.freshComponent(props);if(parentShadow===null){recordComponent(null,fresh[$m],"",true)}else{that.recordKnownComponent(parentShadow,fresh[$m],name,true)}return fresh};that.clearComponent=function(shadow,name,childShadow,destroyRecs,nested,path){destroyRecs=destroyRecs||[];path=path||shadow.path;const childPath=fluid.composeSegment(path,name);childShadow=childShadow||shadow.childComponents[name];const created=childShadow.path===childPath;const destroyRec={childShadow:childShadow,name:name,shadow:shadow,childPath:childPath};if(created){if(fluid.isDestroyedShadow(childShadow)){fluid.fail('Cannot destroy component which is already in status "'+childShadow.lifecycleStatus+'"')}childShadow.lifecycleStatus="destroying";fluid.disposeEffects(childShadow.frameworkEffects);fluid.each(childShadow.childComponents,((gchildShadow,memberName)=>that.clearComponent(childShadow,memberName,gchildShadow,destroyRecs,true)));destroyRecs.push(destroyRec)}else{fluid.remove_if(childShadow.injectedPaths,(function(troo,path){return path===childPath}));fluid.clearComponentIndexes(that,destroyRec)}if(!nested){destroyRecs.forEach((function(destroyRec){fluid.doDestroy(that,destroyRec)}))}};return Object.assign(that,fluid.freshComponent())};fluid.globalInstantiator=fluid.instantiator();fluid.constructRootComponents=function(instantiator){instantiator.rootComponent=instantiator.allocateSimpleComponent(null,"",{$layers:["fluid.rootComponent"]});const rootShadow=instantiator.rootShadow=instantiator.rootComponent[$m];instantiator.resolveRootComponent=instantiator.allocateSimpleComponent(rootShadow,"resolveRootComponent",{$layers:["fluid.resolveRootComponent"]});const resolveRootShadow=instantiator.resolveRootComponent[$m];resolveRootShadow.childrenScope=rootShadow.childrenScope;instantiator.recordKnownComponent(resolveRootShadow,instantiator,"instantiator",true);resolveRootShadow.childrenScope.instantiator={value:instantiator,priority:fluid.memberName}};fluid.computeNickName=function(layerName){const segs=fluid.parsePath(layerName);return fluid.peek(segs)};fluid.isDestroyedShadow=function(shadow,strict){return shadow.lifecycleStatus==="destroyed"||!strict&&shadow.lifecycleStatus==="destroying"};fluid.isDestroyed=function(that,strict){const shadow=that?.[$t]?.shadow||that[$m];return fluid.isDestroyedShadow(shadow,strict)};fluid.computeGlobalMemberName=function(layerName,id){const nickName=fluid.computeNickName(layerName);return nickName+"-"+id};fluid.upgradePrimitiveFunc=function(rec,key){if(rec&&fluid.isPrimitive(rec)){const togo={};togo[key||(typeof rec==="string"&&rec.charAt(0)!=="{"?"funcName":"func")]=rec;togo.args=fluid.NO_ARGUMENTS;return togo}else{return rec}};fluid.compactStringToRec=function(string,type){const openPos=string.indexOf("(");const closePos=string.indexOf(")");if(openPos===-1^closePos===-1||openPos>closePos){fluid.fail("Badly-formed compact "+type+" record without matching parentheses: "+string)}if(openPos!==-1&&closePos!==-1){const trail=string.substring(closePos+1);if(trail.trim()!==""){fluid.fail("Badly-formed compact "+type+" record "+string+" - unexpected material following close parenthesis: "+trail)}const prefix=string.substring(0,openPos);const body=string.substring(openPos+1,closePos).trim();const args=body===""?[]:body.split(",").map((str=>str.trim())).map(fluid.coerceToPrimitive);const togo=fluid.upgradePrimitiveFunc(prefix,null);togo.args=args;return togo}else if(type==="$method"||type==="$compute"){return{funcName:string}}else{fluid.fail("Unrecognised compact record "+string+" with no arguments with type ",type)}return string};fluid.resolveContext=function(context,shadow,resolver){const contextUnavailable=()=>fluid.unavailable({message:"Cannot resolve context "+context+" from component at path "+shadow.path,site:shadow});return computed((()=>{if(context==="self"){return shadow.that}else if(context==="/"){return shadow.instantiator.rootComponent}else if(context==="$oldValue"){return fluid.OldValue}else{const local=resolver?resolver(context):fluid.NoValue;if(local===fluid.NoValue){const resolvedRec=shadow.variableScope[context];if(resolvedRec){const resolved=resolvedRec.value;return resolved instanceof fluid.shadow?resolved.computer.value||contextUnavailable():resolved}else{return contextUnavailable()}}else{return local}}}))};fluid.getForComponent=function(shadow,path){const segs=fluid.pathToSegs(path);if(segs.length===0){return shadow.computer}else{const getter=fluid.getThroughSignals(shadow.computer,segs);return Object.assign(getter,{site:shadow,segs:segs,$variety:"$ref"})}};fluid.pathToLive=function(shadow,path){const segs=fluid.pathToSegs(path);let existing=fluid.get(shadow.liveLayer,segs);if(!existing){const oldValue=fluid.deSignal(fluid.getForComponent(shadow,path).value);const valueSignal=signal(oldValue);fluid.set(shadow.liveLayer,segs,valueSignal);console.log("Upgrading path ",path," to live");shadow.potentia.value=Object.assign({},shadow.potentia.value);return valueSignal}else{return existing}};fluid.setForComponent=function(component,path,value){const segs=fluid.pathToSegs(path),shadow=component[$m];const reactiveSegs=fluid.findReactiveRoot(shadow.shadowMap,segs);const existing=fluid.pathToLive(shadow,reactiveSegs||segs);const surplusSegs=reactiveSegs&&segs.slice(reactiveSegs.length,segs.length);const updated=reactiveSegs?fluid.setImmutable(existing.value,surplusSegs,value):value;existing.value=updated;return existing};fluid.fetchContextReference=function(ref,shadow,resolver){const parsed=fluid.isPrimitive(ref)?fluid.parseContextReference(ref):ref;const refComputer=computed((function fetchContextReference(){const target=fluid.resolveContext(parsed.context,shadow,resolver).value;return fluid.isUnavailable(target)?fluid.mergeUnavailable(fluid.unavailable({message:"Cannot fetch path "+parsed.path+" of context "+parsed.context+" which didn't resolve",path:shadow.path}),target):fluid.isComponent(target)?fluid.getForComponent(target[$m],parsed.path):fluid.get(target,parsed.path)}));return Object.assign(refComputer,{parsed:parsed,site:shadow,$variety:"$contextRef"})};fluid.renderComputedStringTemplate=function(tokens,shadow){if(tokens.length===0){return""}else if(tokens.length===1&&typeof tokens[0]==="string"){return tokens[0]}else{const liveTokens=tokens.map((token=>fluid.isPrimitive(token)?token:fluid.fetchContextReference(token.parsed,shadow)));const togo=fluid.computed((function(...tokens){return tokens.join("")}),liveTokens);togo.$tokens=liveTokens;return togo}};fluid.deSignalToSite=function(ref,shadowCursor){while(fluid.isSignal(ref)){if(ref.$variety==="$ref"){const shadowMap=ref.site.shadowMap;shadowCursor={ref:ref,shadow:ref.site,segs:ref.segs,shadowRec:fluid.get(shadowMap,ref.segs)}}else if(ref.$variety==="$component"&&!fluid.isUnavailable(ref.value)){shadowCursor={shadow:ref.shadow,segs:[],shadowRec:ref.shadow.shadowMap};break}else{shadowCursor={}}ref=ref.value}return{...shadowCursor,value:ref}};fluid.findReactiveRoot=function(shadowMap,segs){let current=shadowMap;for(let i=0;i<segs.length;++i){const seg=segs[i];const shadowRec=current?.[seg];if(shadowRec?.[$m]?.reactiveRoot){return segs.slice(0,i+1)}current=shadowRec}return null};fluid.transferShadowMap=function(shadowMap,layerMap){Object.entries(layerMap).forEach((([key,value])=>{if(key!==$m){const rec=shadowMap[key]={};fluid.transferShadowMap(rec,value)}}));if(layerMap?.[$m]?.reactiveRoot){const rec=fluid.getRecInsist(shadowMap,[$m]);rec.reactiveRoot=true}};fluid.flattenSignals=function(root,strategy,shadowRecIn){const{value:value,shadowRec:shadowRec,segs:segs,shadow:shadow,ref:ref}=fluid.deSignalToSite(root,shadowRecIn);if(fluid.isUnavailable(value)){return strategy==="methodStrategy"?undefined:value}else{if(fluid.isSignal(value)){if(value.$variety==="$component"){return fluid.proxyMat(value,value.shadow,[])}else{fluid.fail("Unexpected unresolved signal value from fluid.deSignalToSite",value)}}else if(fluid.isPrimitive(value)||!fluid.isPlainObject(value)){return value}}const inReactiveRoot=shadow&&fluid.findReactiveRoot(shadow.shadowMap,segs);if(inReactiveRoot&&(strategy==="methodStrategy"||strategy==="effectStrategy")){return fluid.proxyMat(ref,shadow,segs)}else{const mapper=(member,key)=>{const togo=fluid.flattenSignals(member,strategy,{shadow:shadow,segs:segs.concat([key]),shadowRec:shadowRec?.[key]});return togo};if(shadowRec?.[$m]?.hasSignalChild){if(fluid.isArrayable(value)){return value.map(mapper)}else{return fluid.transform(value,mapper)}}else{return value}}};fluid.resolveArgMaterial=function(material,shadow,resolver){if(fluid.isPrimitive(material)){return fluid.isILReference(material)?fluid.fetchContextReference(material,shadow,resolver):material}else if(Array.isArray(material)){return material.map((member=>fluid.resolveArgMaterial(member,shadow,resolver)))}else if(fluid.isPlainObject(material,true)){return fluid.transform(material,(member=>fluid.resolveArgMaterial(member,shadow,resolver)))}else{return material}};fluid.makeArgResolver=function(){const that={backing:[],resolve:function(context){const argNum=+context;return Number.isInteger(+argNum)?argNum in that.backing?that.backing[argNum]:fluid.unavailable({message:"No argument at position "+context+" was supplied to this method call"}):fluid.NoValue}};return that};const methodFlattener=root=>fluid.flattenSignals(root,"methodStrategy");const effectFlattener=root=>fluid.flattenSignals(root,"effectStrategy");fluid.expandMethodRecord=function(record,shadow,key,segs){const func=fluid.resolveFuncReference(record,shadow);let togo;if(record.args){const resolver=fluid.makeArgResolver();const argRecs=fluid.makeArray(record.args);togo=function applyMethod(...args){resolver.backing=args;const resolvedArgs=fluid.resolveArgMaterial(argRecs,shadow,resolver.resolve);const flatArgs=resolvedArgs.map(methodFlattener);const resolvedFunc=fluid.deSignal(func);if(fluid.isUnavailable(resolvedFunc)){fluid.fail("Couldn't invoke method at path ",segs," of component ",shadow,resolvedFunc)}return resolvedFunc.apply(shadow,flatArgs)}}else{togo=function applyDirectMethod(...args){const resolvedFunc=fluid.deSignal(func);return resolvedFunc.apply(shadow.that,[shadow.that,...args])}}return togo};fluid.resolveFuncReference=function(rec,shadow){return rec.funcName?fluid.getGlobalValue(rec.funcName):fluid.isILReference(rec.func)?fluid.fetchContextReference(rec.func,shadow):rec.func};fluid.resolveFuncRecord=function(rec,shadow){const func=fluid.resolveFuncReference(rec,shadow);const args=fluid.makeArray(rec.args);const resolvedArgs=fluid.resolveArgMaterial(args,shadow);let unavailable;if(!func){unavailable=fluid.unavailable(`Unable to resolve reference to function from entries ${rec.func} or ${rec.funcName}`)}else if(fluid.isUnavailable(func)){unavailable=func}return{func:func,resolvedArgs:resolvedArgs,unavailable:unavailable}};fluid.expandComputeRecord=function(record,shadow){const{func:func,resolvedArgs:resolvedArgs,unavailable:unavailable}=fluid.resolveFuncRecord(record,shadow);if(unavailable){return unavailable}else{const togo=fluid.computed(func,resolvedArgs,{flattenArg:fluid.flattenSignals});togo.$variety="$compute";return togo}};fluid.expandEagerComputeRecord=function(record,shadow){const togo=fluid.expandComputeRecord(record,shadow);if(fluid.isUnavailable(togo)){return togo}else{togo.$variety="$eagerCompute";return togo}};fluid.expandEffectRecord=function(record,shadow){console.log("ExpandEffectRecord for "+record.funcName+" at "+shadow.memberName);const{func:func,resolvedArgs:resolvedArgs,unavailable:unavailable}=fluid.resolveFuncRecord(record,shadow);if(unavailable){return unavailable}else{const togo=fluid.effect(func,resolvedArgs,{flattenArg:effectFlattener});togo.$variety="$effect";return togo}};fluid.expandReactiveRecord=function(record,shadow){const togo=typeof record==="string"?fluid.fetchContextReference(record,shadow):signal(record);togo.$variety="$reactiveRoot";return togo};fluid.pushSubcomponentPotentia=function(shadow,memberName,expanded,scope){const subLayerRecord={mergeRecordType:"subcomponent",mergeRecordName:`subcomponent:${memberName}`,layer:expanded};return fluid.pushPotentia(shadow,memberName,[subLayerRecord],expanded.$layers,scope)};fluid.expandComponentRecord=function(record,shadow,key){const expanded=fluid.readerExpandLayer(record);const sourceRecord=expanded.$for;if(sourceRecord){const sourceSignal=fluid.fetchContextReference(sourceRecord.source,shadow);let listShadow;const componentList=fluid.computed((source=>{const allKeys=[];const pushSubcomponentPotentia=function(value,subKey){allKeys.push(""+subKey);const scope={};if(sourceRecord.value!==undefined){scope[sourceRecord.value]={value:value,source:sourceSignal,sourcePath:subKey}}if(sourceRecord.key!==undefined){scope[sourceRecord.key]={value:subKey,source:sourceSignal,sourcePath:subKey}}return fluid.pushSubcomponentPotentia(listShadow,subKey,expanded,scope)};let togo;if(fluid.isArrayable(source)){togo=source.map(pushSubcomponentPotentia)}else{togo=Object.entries(source).map((([key,value])=>pushSubcomponentPotentia(value,key)))}const goneKeys=Object.keys(listShadow.childComponents).filter((k=>!allKeys.includes(k)));const goneShadows=goneKeys.map((k=>listShadow.childComponents[k]));goneShadows.forEach((shadow=>shadow.potentia.value=fluid.emptyPotentia));return togo.map((computer=>fluid.proxyMat(computer,computer.shadow,[])))}),[sourceSignal]);componentList.$variety="$componentList";componentList.$source=sourceSignal;const listLayer={$layers:["fluid.componentList"],list:componentList,length:fluid.getThroughSignals(componentList,["length"])};const listComputer=fluid.pushSubcomponentPotentia(shadow,key,listLayer);listShadow=listComputer.shadow;return listComputer}else{return fluid.pushSubcomponentPotentia(shadow,key,expanded)}};fluid.elementExpanderRecord=function(){};fluid.expandElementTypes=[{key:"$method",handler:fluid.expandMethodRecord},{key:"$compute",handler:fluid.expandComputeRecord},{key:"$eagerCompute",handler:fluid.expandEagerComputeRecord,isEager:true},{key:"$effect",handler:fluid.expandEffectRecord,isEffect:true},{key:"$reactiveRoot",handler:fluid.expandReactiveRecord},{key:"$component",handler:fluid.expandComponentRecord}].map((rec=>Object.assign(Object.create(fluid.elementExpanderRecord.prototype),rec)));fluid.siteSignal=function(signal,shadow,segs){signal.site=shadow;signal.segs=[...segs];return signal};fluid.mountSignalRecord=function(handlerRecord,record,shadow,segs){const allSegs=[...segs,$m];const oldRec=fluid.get(shadow.oldShadowMap,allSegs);const rec=fluid.getRecInsist(shadow.shadowMap,allSegs);rec.signalRecord=record;rec.handlerRecord=handlerRecord;if(oldRec){rec.proxy=oldRec.proxy}if(oldRec&&oldRec.signalRecord===record){return rec.signalProduct=oldRec.signalProduct}else if(!handlerRecord.isEffect){const product=rec.signalProduct=handlerRecord.handler(record,shadow,fluid.peek(segs),segs);fluid.siteSignal(product,shadow,segs);return product}};fluid.expandElement=function(shadow,element,segs){if(fluid.isPlainObject(element,true)){const handlerRecord=fluid.expandElementTypes.find((record=>element[record.key]));if(handlerRecord){return fluid.mountSignalRecord(handlerRecord,element[handlerRecord.key],shadow,segs)}else{return element}}else if(fluid.isILReference(element)){const togo=fluid.fetchContextReference(element,shadow);fluid.siteSignal(togo,shadow,segs);return togo}else{return element}};fluid.expansionCache=Object.create(null);fluid.expandCompactElementImpl=function(element){const c=element.charAt(0);if(c==="$"){const colpos=element.indexOf(":");if(colpos===-1){fluid.fail("Badly-formed compact record ",element," without colon")}else{const type=element.substring(0,colpos);if(!fluid.expandElementTypes.find((record=>record.key===type))){fluid.fail("Unrecognised compact record type ",type)}const body=element.substring(colpos+1);const rec=fluid.compactStringToRec(body,type);return{[type]:rec}}}};fluid.expandCompactElement=function(element){if(typeof element==="string"){const existing=fluid.expansionCache[element];if(existing){return existing}else{const expanded=fluid.expandCompactElementImpl(element);if(expanded){fluid.expansionCache[element]=expanded;return expanded}}}};fluid.markSignalised=function(shadowMap,segs,uncess=1){for(let i=0;i<segs.length;++i){const seg=segs[i];const rec=fluid.getRecInsist(shadowMap,[seg,$m]);if(i<segs.length-uncess){rec.hasSignalChild=true}shadowMap=shadowMap[seg]}};fluid.expandLayer=function(target,flatMerged,shadow,segs){fluid.each(flatMerged,(function expandOneLayer(value,key){segs.push(key);const uncompact=fluid.expandCompactElement(value);const expanded=fluid.expandElement(shadow,uncompact||value,segs);if(fluid.isPlainObject(expanded,true)){const expandedInner={};fluid.expandLayer(expandedInner,value,shadow,segs);target[key]=expandedInner}else{target[key]=expanded;if(fluid.isSignal(expanded)){const uncess=expanded.$variety==="$componentList"||expanded.$variety==="$list"?0:1;fluid.markSignalised(shadow.shadowMap,segs,uncess)}}segs.pop()}))};fluid.flatMergedRound=function(shadow,resolver,layerNames){if(layerNames.length>0){layerNames.forEach((layerName=>resolver.storeLayer(layerName)));return resolver.resolve(layerNames)}else{return fluid.unavailable({message:"Component has no layers",site:shadow})}};fluid.flatMergedComputer=function(shadow){return computed((function flatMergedComputer(){const{layerNames:layerNames,mergeRecords:mergeRecords}=shadow.potentia.value;const mergeRecordLayerNames=mergeRecords.map((mergeRecord=>fluid.makeArray(mergeRecord.layer.$layers))).flat();const allLayerNames=[...layerNames,...mergeRecordLayerNames].reverse();const resolver=new fluid.HierarchyResolver;const resolved=fluid.flatMergedRound(shadow,resolver,allLayerNames);if(fluid.isUnavailable(resolved)){return resolved}else{const layers=resolved.mergeRecords.concat(mergeRecords).concat({mergeRecordType:"live",mergeRecordName:"live",layer:shadow.liveLayer});const flatMerged=fluid.makeLayer("flatMerged",shadow);shadow.layerMap=fluid.mergeLayerRecords(flatMerged,layers);return flatMerged}}))};fluid.scheduleEffects=function(shadow){const expandEffect=(newRecord,segs)=>{newRecord.signalProduct=newRecord.handlerRecord.handler(newRecord.signalRecord,shadow);fluid.siteSignal(newRecord.signalProduct,shadow,segs)};fluid.forEachDeep(shadow.shadowMap,((newRecord,segs)=>{if(newRecord.handlerRecord?.isEffect){const oldRecord=fluid.get(shadow.oldShadowMap,segs)?.[$m];if(!oldRecord||newRecord.signalRecord!==oldRecord.signalRecord||!oldRecord.signalProduct){expandEffect(newRecord,segs)}}else if(newRecord.handlerRecord?.isEager){newRecord.signalProduct.value}}));delete shadow.oldShadowMap;if(fluid.isEmptyPotentia(shadow.potentia.peek())){shadow.instantiator.clearComponent(shadow.parentShadow,shadow.memberName,shadow)}};fluid.disposeLayerEffects=function(shadow){fluid.forEachDeep(shadow.oldShadowMap,((oldRecord,segs)=>{const newRecord=fluid.get(shadow.shadowMap,segs)?.[$m];if(oldRecord.handlerRecord?.isEffect&&(!newRecord||newRecord.signalRecord!==oldRecord.signalRecord)){oldRecord.signalProduct._dispose()}}))};fluid.applyScope=function(target,newScope){fluid.clear(target);Object.assign(target,newScope)};fluid.pushPotentia=function(parentShadow,memberName,mergeRecords,layerNames=[],variableScope){const existing=parentShadow.childComponents[memberName];if(existing){const shadow=existing;const oldPotentia=shadow.potentia.peek();const writtenLayers=new Set(mergeRecords.map((mergeRecord=>mergeRecord.mergeRecordType)));const filteredRecords=oldPotentia.mergeRecords.filter((mergeRecord=>!writtenLayers.has(mergeRecord.mergeRecordType)));const newMergeRecords=filteredRecords.concat(mergeRecords.filter((mergeRecord=>mergeRecord.layer)));const newLayerNames=oldPotentia.layerNames||layerNames;const potentia={mergeRecords:newMergeRecords,layerNames:newLayerNames};shadow.potentia.value=potentia;fluid.applyScope(shadow.variableScope,variableScope);return shadow.computer}else{return fluid.computeInstance({mergeRecords:mergeRecords,layerNames:layerNames},parentShadow,memberName,variableScope)}};fluid.effectGuardDepth=0;fluid.scheduleEffectsQueue=[];fluid.queueScheduleEffects=function(shadow){fluid.scheduleEffectsQueue.push(shadow);if(fluid.effectGuardDepth===0){const active=fluid.scheduleEffectsQueue.reverse();fluid.scheduleEffectsQueue=[];active.forEach((shadow=>{shadow.effectScheduler=effect((()=>fluid.scheduleEffects(shadow,shadow.computer.value)));shadow.effectScheduler.$variety="effectScheduler"}))}};fluid.computeInstance=function(potentia,parentShadow,memberName,variableScope){const instantiator=parentShadow.instantiator;const shadow=Object.create(fluid.shadow.prototype);shadow.potentia=signal(potentia);shadow.liveLayer=Object.create(null);shadow.shadowMap=Object.create(null);shadow.instanceId=0;shadow.flatMerged=fluid.flatMergedComputer(shadow);const computer=computed((function computeInstance(){shadow.oldShadowMap=shadow.shadowMap;shadow.shadowMap=Object.create(null);const flatMerged=shadow.flatMerged.value;let instance;if(fluid.isUnavailable(flatMerged)){instance=flatMerged}else{fluid.transferShadowMap(shadow.shadowMap,shadow.layerMap);instance=fluid.freshComponent(potentia.props,shadow);instance.instanceId=shadow.instanceId++;console.log("Allocated instanceId "+shadow.instanceId+" at site "+shadow.path);fluid.expandLayer(instance,flatMerged,shadow,[])}fluid.disposeLayerEffects(shadow);return instance}));computer.$variety="$component";shadow.computer=computer;computer.shadow=shadow;try{++fluid.effectGuardDepth;instantiator.recordKnownComponent(parentShadow,shadow,memberName,true);fluid.applyScope(shadow.variableScope,variableScope)}finally{--fluid.effectGuardDepth}fluid.queueScheduleEffects(shadow);return computer};fluid.expectLiveAccess=function(shadow,prop){if(shadow.lifecycleStatus==="destroyed"){throw Error(`Cannot access member ${prop} of component which has been destroyed`)}};fluid.getPenThroughSignals=function(target,segs){let it=fluid.deSignal(target);for(let i=0;i<segs.length-1;++i){const move=it[segs[i]];it=fluid.deSignal(move)}return it};fluid.mutatingArrayMethods=Object.fromEntries(["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"].map((key=>[key,true])));fluid.proxyMat=function(target,shadow,segs){const rec=fluid.getRecInsist(shadow.shadowMap,[...segs,$m]);const existing=rec.proxy;if(existing){return existing}else{const getHandler=function(target,prop){if(prop===$t){return target}fluid.expectLiveAccess(shadow,prop);const deTarget=fluid.deSignal(target);if(prop===Symbol.toStringTag){return Object.prototype.toString.call(deTarget)}else{const nextSegs=[...segs,prop];const upSignals=fluid.get(shadow.shadowMap,nextSegs)?.[$m]?.hasSignalChild;const inReactive=fluid.findReactiveRoot(shadow.shadowMap,nextSegs);const next=fluid.isUnavailable(deTarget)&&segs.length>0?undefined:inReactive?fluid.getForComponent(shadow,nextSegs):deTarget[prop];const proxyNext=upSignals||inReactive;if(Array.isArray(deTarget)&&typeof deTarget[prop]==="function"){if(fluid.mutatingArrayMethods[prop]){const liveSignal=fluid.pathToLive(shadow,segs);const forked=[...liveSignal.value];return function(){const togo=Array.prototype[prop].apply(forked,arguments);liveSignal.value=forked;return togo}}else{const unwrapped=deTarget.map(((element,key)=>getHandler(target,key)));return Array.prototype[prop].bind(unwrapped)}}else if(proxyNext||fluid.isSignal(next)){const upcoming=fluid.deSignal(next);return fluid.isUnavailable(upcoming)?fluid.unavailableProxy(upcoming):next.$variety==="$component"?fluid.proxyMat(next,next.shadow,[]):fluid.isPrimitive(upcoming)||!proxyNext?upcoming:fluid.proxyMat(next,shadow,nextSegs)}else{return next}}};const setHandler=function(target,prop,value){fluid.expectLiveAccess(shadow,prop);const nextSegs=[...segs,prop];if(fluid.isSignal(target)&&target.$variety==="$contextRef"){const resolvedRec=shadow.variableScope[target.parsed.context];let innerContext=target.parsed.context,innerPath=target.parsed.path;if(resolvedRec.source){const innerRef=resolvedRec.source;innerContext=innerRef.parsed.context;innerPath=fluid.composePath(innerRef.parsed.path,resolvedRec.sourcePath)}const resolved=fluid.resolveContext(shadow,innerContext);const innerNext=fluid.getPenThroughSignals(resolved,innerPath)}fluid.setForComponent(shadow.that,nextSegs,value);return true};const proxy=new Proxy(target,{get:getHandler,set:setHandler,ownKeys:()=>Reflect.ownKeys(fluid.deSignal(target)),getOwnPropertyDescriptor:function(target,key){return{value:this.get(target,key),enumerable:true,configurable:true}},getPrototypeOf:()=>Object.getPrototypeOf(fluid.deSignal(target))});return rec.proxy=proxy}};fluid.unwrapProxy=function(maybeProxy){const target=maybeProxy?.[$t];return target?fluid.deSignal(target):maybeProxy};fluid.initFreeComponent=function(componentName,initArgs){const instantiator=fluid.globalInstantiator;const id=fluid.allocateGuid();const instanceName=fluid.computeGlobalMemberName(componentName,id);const argLayer=initArgs[0]||{};const ourLayerNames=[componentName].concat(fluid.makeArray(argLayer.$layers));const userLayerRecord={mergeRecordType:"user",layer:{...argLayer}};const potentia={props:{$id:id},layerNames:ourLayerNames,mergeRecords:[userLayerRecord]};const computer=fluid.computeInstance(potentia,instantiator.rootComponent[$m],instanceName);const proxy=fluid.proxyMat(computer,computer.shadow,[]);return proxy};fluid.destroy=function(path,instantiator){instantiator=instantiator||fluid.globalInstantiator;const segs=fluid.parsePath(path);if(segs.length===0){fluid.fail("Cannot destroy the root component")}const that=instantiator.pathToComponent[path];fluid.destroyComponent(that)};fluid.emptyPotentia=Object.freeze({layerNames:[],mergeRecords:[]});fluid.isEmptyPotentia=function(potentia){return potentia.layerNames.length===0&&potentia.mergeRecords.length===0};fluid.destroyComponent=function(proxy){proxy[$t].shadow.potentia.value=fluid.emptyPotentia};fluid.def("fluid.component",{events:{onCreate:0,onDestroy:0,afterDestroy:0},destroy:"$method:fluid.destroyComponent({self})",$variety:"framework"});fluid.def("fluid.componentList",{$layers:"fluid.component",$variety:"framework"});fluid.def("fluid.resolveRoot",{$layers:"fluid.component",$variety:"framework"});fluid.def("fluid.resolveRootSingle",{$layers:"fluid.resolveRoot",$variety:"framework"});fluid.constructRootComponents(fluid.globalInstantiator);fluid.fetch=function(url,options,strategy){const togo=signal(fluid.unavailable({message:`Pending I/O for URL ${url}`,variety:"I/O"}));fetch(url,options).then((response=>strategy(response))).then((data=>{console.log("Received data ",data);togo.value=data})).catch((err=>togo.value=fluid.unavailable({message:`I/O failure for URL ${url} - ${err}`,variety:"error"})));return togo};fluid.fetchText=function(url,options){return fluid.fetch(url,options,(async response=>response.text()))};fluid.fetchJSON=function(url,options){return fluid.fetch(url,options,(async response=>response.json()))};fluid.toPromise=function(component,path){const pathSignal=fluid.getForComponent(component[$m],path);return new Promise((resolve=>{const effect=fluid.effect((function(pathValue){resolve(pathValue);effect._dispose()}),[pathSignal])}))};fluid.importMap={}};if(typeof fluid!=="undefined"){fluidILScope(fluid)}"use strict";const fluidViewScope=function(fluid){const $m=fluid.metadataSymbol;const $t=fluid.proxySymbol;fluid.parseDOM=function(template){const fragment=document.createRange().createContextualFragment(template);return fragment.firstElementChild};fluid.importOneUrlResource=function(layerName,relPath){return{url:fluid.importMap[layerName].urlBase+relPath,variety:"importUrlResource"}};fluid.importUrlResource=function(layerName,relPath){return typeof relPath==="string"?fluid.importOneUrlResource(layerName,relPath):fluid.isArrayable(relPath)?relPath.map((oneRelPath=>fluid.importOneUrlResource(layerName,oneRelPath))):null};fluid.vNodeToDom=function(vnode){const root=fluid.nodeFromVNode(vnode);fluid.patchChildren(vnode,root);return root};fluid.cssInjectionStyles={literal:{construct:()=>({tag:"style",attrs:{type:"text/css"},children:[""]}),update:(node,rec)=>{node.firstChild.nodeValue=rec}},link:{construct:()=>({tag:"link",attrs:{rel:"stylesheet",type:"text/css"}}),update:(node,rec)=>{node.setAttribute("href",rec.url)}}};fluid.scriptInjectionStyles={literal:{construct:()=>({tag:"script",attrs:{type:"text/javascript"},children:[""]}),update:(node,rec)=>{node.firstChild.nodeValue=rec}},link:{construct:()=>({tag:"script",attrs:{async:"false",type:"text/javascript"}}),update:(node,rec)=>{node.setAttribute("src",rec.url)}}};fluid.injectCSS=function(css,layerCssId,url){const injStyle=typeof css==="string"?"literal":"link";const injRec=fluid.cssInjectionStyles[injStyle];let existing=document.getElementById(layerCssId);if(!existing){existing=fluid.vNodeToDom(injRec.construct());existing.id=layerCssId;document.head.appendChild(existing)}if(injStyle==="literal"){css+=`\n/*# sourceURL=${url}*/`}injRec.update(existing,css)};fluid.injectScript=function(script,scriptNodeId){const injStyle=typeof script==="string"?"literal":"link";const injRec=fluid.scriptInjectionStyles[injStyle];let existing=document.getElementById(scriptNodeId);if(existing){existing.remove()}const fresh=fluid.vNodeToDom(injRec.construct());fresh.id=scriptNodeId;fresh.async=false;injRec.update(fresh,script);document.head.appendChild(fresh)};fluid.urlBaseRegistry={};fluid.templateBaseUrl=function(raw){const tidy=raw.replace(/}\//g,"}");return fluid.stringTemplate(tidy,fluid.urlBaseRegistry)};fluid.acquireUrlBases=function(root){const urlBaseNodes=[...root.querySelectorAll("fluid-url-base")];urlBaseNodes.forEach((node=>{const id=node.getAttribute("id");const src=node.getAttribute("src");fluid.urlBaseRegistry[id]=src.endsWith("/")?src:src+"/"}));return urlBaseNodes.map((node=>({node:node})))};fluid.acquireImports=function(root){const togo=[];const importNodes=[...root.querySelectorAll("fluid-import")];importNodes.forEach((node=>{const layerName=node.getAttribute("layer");const url=fluid.templateBaseUrl(node.getAttribute("src"));fluid.importMap[layerName]={loadStyle:"sfc",url:url};togo.push({layerName:layerName,url:url,node:node});fluid.loadSFC(layerName,url)}));return togo};fluid.acquireLoadDirectives=function(root){const removeAll=recs=>recs.forEach((rec=>rec.node.remove()));removeAll(fluid.acquireUrlBases(root));removeAll(fluid.acquireImports(root))};fluid.sfcStore={};fluid.readSFC=function(layerName){const rec=fluid.sfcStore[layerName];if(rec){return rec}else{return fluid.sfcStore[layerName]={textSignal:signal(fluid.unavailable(`SFC for ${layerName} is not available`))}}};fluid.loadSFCScript=function(src,layerName,index,usedKeys){const nodeId=`fl-script-${layerName}-${index}`;const url=fluid.templateBaseUrl(src);fluid.injectScript({url:url},layerName);usedKeys.push(nodeId)};const parseDefRegex=/fluid\.def\("([^"]+)",\s*({[\s\S]*?\n})\)/;fluid.applySFCScripts=function(scriptNodes,layerName,usedKeys){let defBody,foundLayerName,unavailable,trailingScript;scriptNodes.forEach(((scriptNode,index)=>{const script=scriptNode.innerText;const src=scriptNode.getAttribute("src");if(src){fluid.loadSFCScript(src,layerName,index,usedKeys)}else{const match=script.match(parseDefRegex);if(match){foundLayerName=match[1];defBody=match[2];trailingScript=script.substring(match[0].length+2).trim()}}}));if(foundLayerName!==layerName){unavailable=fluid.unavailable(`Error in SFC: Expected definition for layer ${layerName} but found ${foundLayerName} instead`)}return{defBody:defBody,trailingScript:trailingScript,unavailable:unavailable}};fluid.applySFCStyles=function(styleNodes,layerName,usedKeys,url){styleNodes.forEach(((scriptNode,index)=>{let script=scriptNode.innerText;const src=scriptNode.getAttribute("src");if(src){script={url:fluid.templateBaseUrl(src)}}const nodeId=`fl-style-${layerName}-${index}`;fluid.injectCSS(script,nodeId,url);usedKeys.push(nodeId)}))};fluid.toAbsoluteUrl=url=>/^\w+:\/\//.test(url)?url:new URL(url,document.location.href).href;fluid.$fluidParsedDef=null;fluid.parseSFC=function(textSignal,layerName,url){const applyValue=(target,key,value)=>{if(value){const trimmed=value.trim();if(trimmed){target[key]=trimmed}}};const usedKeys=[];let oldText;return fluid.effect((text=>{if(text===oldText){console.log("Culling SFC injection effect since text has not changed");return}oldText=text;usedKeys.forEach((key=>document.getElementById(key).remove()));usedKeys.length=0;const sfc=fluid.parseDOM("<sfc>"+text+"</sfc>");const scriptNodes=sfc.querySelectorAll("script");if(scriptNodes.length===0){return{layerName:layerName,def:fluid.unavailable("No script node found in SFC for layer "+layerName)}}let def;const{defBody:defBody,trailingScript:trailingScript,unavailable:unavailable}=fluid.applySFCScripts(scriptNodes,layerName,usedKeys);if(unavailable){def=unavailable;fluid.def(layerName,def)}else{const absUrl=fluid.toAbsoluteUrl(url);eval?.(`fluid.$fluidParsedDef = ${defBody}\n//# sourceURL=${absUrl}-def`);def=fluid.$fluidParsedDef;const template=sfc.querySelector("template")?.innerHTML;applyValue(def,"template",template);const styleNodes=sfc.querySelectorAll("style");fluid.applySFCStyles(styleNodes,layerName,usedKeys,absUrl);def.$layers=["fluid.templateViewComponent",...fluid.makeArray(def.$layers)];fluid.def(layerName,def);if(trailingScript){const nodeId=`fl-script-${layerName}-trailingScript`;fluid.injectScript(trailingScript+`\n//# sourceURL=${absUrl}`,nodeId);usedKeys.push(nodeId)}}}),[textSignal])};fluid.loadSFC=function(layerName,url){const rec=fluid.readSFC(layerName);rec.parseEffect=fluid.parseSFC(rec.textSignal,layerName,url);rec.fetchSignal=fluid.fetchText(url);rec.fetchEffect=effect((()=>rec.textSignal.value=rec.fetchSignal.value));return rec};fluid.updateArrayIfDifferent=function(signal,newArray){const currentArray=signal.value;if(currentArray.length!==newArray.length||currentArray.some(((item,index)=>item!==newArray[index]))){signal.value=newArray}};fluid.applyOnLoad=function(func){if(document.readyState==="complete"){func()}else{document.addEventListener("DOMContentLoaded",func)}};fluid.liveQuery=function(selector,root=null){const togo=signal([]);const context=root||document;const updateMatches=()=>{const upcoming=Array.from(context.querySelectorAll(selector));fluid.updateArrayIfDifferent(togo,upcoming)};const observer=new MutationObserver((()=>{console.log("Observer update");updateMatches()}));const init=()=>{observer.observe(context,{childList:true,subtree:true});updateMatches()};fluid.applyOnLoad(init);togo._dispose=()=>observer.disconnect();return togo};fluid.liveQueryOne=function(selector,root=null){const noElement=fluid.unavailable({cause:"No element matches selector "+selector,variety:"I/O"});const query=fluid.liveQuery(selector,root);const togo=computed((()=>query.value.length===0?noElement:query.value[0]));togo._dispose=query._dispose();return togo};fluid.insertChildContainer=function(strategy,key,template,parentNode,referenceNode){const tagMatch=template.match(/^\s*<(\S+)/);const tagName=tagMatch?tagMatch[1]:null;if(!tagName){return fluid.unavailable({cause:"Invalid template: Unable to determine tag name from "+template})}if(key){const child=[...parentNode.children].find((child=>child.getAttribute("data-fl-transient-key")===key));if(child){return child}}const newNode=document.createElement(tagName);if(strategy==="first"){parentNode.insertBefore(newNode,parentNode.firstChild)}else if(strategy==="last"){parentNode.appendChild(newNode)}else if(strategy==="before"){parentNode.insertBefore(newNode,referenceNode)}else if(strategy==="after"){parentNode.insertBefore(newNode,referenceNode.nextSibling)}newNode.setAttribute("data-fl-transient-key",key);return newNode};fluid.elementToVNode=function(element){const tag=element.tagName.toLowerCase();const attrs={};for(let i=0;i<element.attributes.length;i++){const attr=element.attributes[i];attrs[attr.name]=attr.value}return{tag:tag,attrs:attrs}};fluid.domToVDom=function(node){if(node.nodeType===Node.TEXT_NODE){const text=node.nodeValue.trim();return text===""?null:{text:text}}if(node.nodeType===Node.ELEMENT_NODE){const togo=fluid.elementToVNode(node);const children=[];for(let i=0;i<node.childNodes.length;++i){const child=fluid.domToVDom(node.childNodes[i]);if(child!==null){children.push(child)}}togo.children=children;return togo}return null};const systemModifiers=["ctrl","shift","alt","meta"];const modifierGuards={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,modifiers)=>systemModifiers.some((m=>e[`${m}Key`]&&!modifiers[m]))};const hyphenateRE=/\B([A-Z])/g;const modifierRE=/\.([\w-]+)/g;fluid.parseModifiers=raw=>{let modifiers;raw=raw.replace(modifierRE,((_,m)=>{(modifiers||(modifiers={}))[m]=true;return""}));return{event:raw,modifiers:modifiers}};fluid.hyphenate=str=>str.replace(hyphenateRE,"-$1").toLowerCase();fluid.applyOns=function(segs,shadow,el,on){if(on){on.forEach((({onKey:onKey,onValue:onValue})=>fluid.applyOn(segs,shadow,el,onKey,onValue)))}};fluid.applyOn=(segs,shadow,el,onKey,onValue)=>{let{event:event,modifiers:modifiers}=fluid.parseModifiers(onKey);let handler;if(onValue.includes("=")){const parts=onValue.split("=").map((part=>part.trim()));if(parts.length!==2){fluid.fail("Unrecognised event assignment binding without lefthand and righthand "+onValue)}const[lh,rh]=parts;const parsedLH=fluid.parseContextReference(lh);const target=fluid.resolveContext(parsedLH.context,shadow);let rvalue;if(fluid.isILReference(rh)){const parsedRH=fluid.parseContextReference(rh);const value=fluid.fetchContextReference(parsedRH,shadow);rvalue=fluid.deSignal(value)}else{rvalue=fluid.coerceToPrimitive(rh)}handler=()=>fluid.setForComponent(target.value,parsedLH.path,rvalue)}else{const parsed=fluid.compactStringToRec(onValue,"DOMEventBind");handler=fluid.expandMethodRecord(parsed,shadow,null,segs)}if(event==="click"){if(modifiers?.right){event="contextmenu"}if(modifiers?.middle){event="mouseup"}}const rawHandler=e=>{if(modifiers){if("key"in e&&!(fluid.hyphenate(e.key)in modifiers)){return}for(const key in modifiers){const guard=modifierGuards[key];if(guard&&guard(e,modifiers)){return}}}return handler(e)};el.addEventListener(event,rawHandler,modifiers)};fluid.unavailableElement=fluid.unavailable("DOM element not available");fluid.allocateVNodeEffect=function(vnode,effectMaker){vnode.elementSignal||=signal(fluid.unavailableElement);const renderEffect=effectMaker(vnode);fluid.pushArray(vnode,"renderEffects",renderEffect);return renderEffect};fluid.bindDomTokens=function(templateEffects,vnode,rendered,applyFunc){if(fluid.isSignal(rendered)){const templateEffect=fluid.allocateVNodeEffect(vnode,(vnode=>{const togo=fluid.effect((function(element,text){applyFunc(element,text)}),[vnode.elementSignal,rendered]);togo.$variety="bindDomTokens";togo.$vnode=vnode;return togo}));templateEffects.push(templateEffect)}};fluid.liftNegate=negate=>negate?x=>!x:fluid.identity;fluid.mapSignal=(sig,fun)=>fun===fluid.identity?sig:fluid.computed((value=>fun(value)),[sig]);fluid.processAttributeDirective=function(vnode,value,key,shadow){if(key==="@id"){fluid.allocateVNodeEffect(vnode,(vnode=>{const disposable=function(){fluid.pushPotentia(shadow,value,[{mergeRecordType:"template"}])};disposable.$variety="$component";delete vnode.children;const templateRecord={mergeRecordType:"template",layer:{$layers:"fluid.viewComponent",container:vnode.elementSignal}};fluid.pushPotentia(shadow,value,[templateRecord]);return disposable}))}else if(key==="@class"){const parts=value.split(",").map((part=>part.trim()));const clazz=Object.fromEntries(parts.map((part=>{const[key,ref]=part.split(":");const negate=ref.startsWith("!");const effRef=negate?ref.substring(1):ref;const tokens=fluid.parseStringTemplate(effRef);const rendered=fluid.renderComputedStringTemplate(tokens,shadow);const negMap=fluid.liftNegate(negate);const renderedPrim=fluid.isSignal(rendered)?fluid.mapSignal(rendered.$tokens[0],negMap):negMap(rendered);return[key,renderedPrim]})));vnode["class"]=clazz}};fluid.getSignalSource=function(ref){return fluid.isSignal(ref)?ref.$source:ref};fluid.parseTemplate=function(element,self){const shadow=self[$m];const templateEffects=shadow.frameworkEffects.templateEffects=shadow.frameworkEffects.templateEffects||[];function processVNode(vnode){vnode.shadow=shadow;if(vnode.text!==undefined){const tokens=fluid.parseStringTemplate(vnode.text);const rendered=fluid.renderComputedStringTemplate(tokens,shadow);fluid.bindDomTokens(templateEffects,vnode,rendered,((node,text)=>node.nodeValue=text));return Object.assign(vnode,{text:rendered})}else{fluid.each(vnode.attrs,((value,key)=>{const firstChar=key.charCodeAt(0);if(firstChar===64){if(key.startsWith("@on")){fluid.pushArray(vnode,"on",{onKey:key.slice(3).toLowerCase(),onValue:value})}else{fluid.processAttributeDirective(vnode,value,key,shadow)}delete vnode.attrs[key]}else if(key!=="class"){const tokens=fluid.parseStringTemplate(value);const rendered=fluid.renderComputedStringTemplate(tokens,shadow);if(fluid.isSignal(rendered)){rendered.$source=value;fluid.bindDomTokens(templateEffects,vnode,rendered,((node,text)=>node.setAttribute(key,text)));vnode.attrs[key]=rendered}}}));if(vnode["class"]){const clazzSource=fluid.getSignalSource(vnode.attrs["class"])||"";const allClass=computed((()=>{const classes=Object.entries(vnode["class"]).map((([key,value])=>[key,fluid.deSignal(value)])).filter((([,value])=>value)).map((([key])=>key));return clazzSource+" "+classes}));allClass.$variety="$allClass";allClass.$source=clazzSource;fluid.bindDomTokens(templateEffects,vnode,allClass,((node,text)=>node.setAttribute("class",text)));vnode.attrs["class"]=allClass}if(vnode.children!==undefined){vnode.children=vnode.children.map(processVNode)}}return vnode}function parseTemplate(tree){fluid.disposeEffects(templateEffects);const togo=processVNode(tree);templateEffects.forEach((effect=>effect.$site=self));return togo}fluid.acquireLoadDirectives(element);const tree=fluid.domToVDom(element);const togo=parseTemplate(tree);return togo};fluid.unbindDom=function(){};fluid.bindDom=function(vnode,element){if(vnode.elementSignal){fluid.unbindDom(vnode,vnode.elementSignal.peek());vnode.elementSignal.value=element}};fluid.nodeFromVNode=function(vnode){if(typeof vnode==="string"){return document.createTextNode(vnode)}else if(vnode.text){return document.createTextNode(vnode.text)}else{return document.createElement(vnode.tag)}};fluid.matchNodeToVNode=function(node,vnode){if(typeof vnode==="string"||vnode.text){return node.nodeType===Node.TEXT_NODE}else{return node.nodeType===Node.ELEMENT_NODE&&node.tagName.toLowerCase()===vnode.tag}};fluid.patchAttrs=function(vnode,element){for(let i=element.attributes.length-1;i>=0;i--){const attrName=element.attributes[i].name;if(!(attrName in vnode.attrs)&&!attrName.startsWith("data-fl-transient")){element.removeAttribute(attrName)}}for(const[key,value]of Object.entries(vnode.attrs)){if(!fluid.isSignal(value)&&element.getAttribute(key)!==value){element.setAttribute(key,value)}}};fluid.vnodeToSegs=function(vnode){return["$template",vnode.tag]};fluid.patchChildren=function(vnode,element,maybeFreshRoot){fluid.bindDom(vnode,element);if(vnode.text!==undefined){element.textContent=vnode.text}if(vnode.attrs!==undefined){fluid.patchAttrs(vnode,element)}if(maybeFreshRoot&&!element.flEventsBound){fluid.applyOns(fluid.vnodeToSegs(vnode),vnode.shadow,element,vnode.on);element.flEventsBound=true}if(vnode.children!==undefined){const vcount=vnode.children.length;for(let i=0;i<vcount;++i){const vchild=vnode.children[i];let other=element.childNodes[i];if(!other||!fluid.matchNodeToVNode(other,vchild)){const fresh=fluid.nodeFromVNode(vchild);fluid.applyOns(fluid.vnodeToSegs(vchild),vchild.shadow,fresh,vchild.on);if(other){other.replaceWith(fresh)}else{element.appendChild(fresh)}other=fresh}fluid.patchChildren(vchild,other)}for(let i=element.childNodes.length-1;i>=vcount;--i){element.childNodes[i].remove()}}};fluid.viewContainerRegistry=new WeakMap;fluid.renderView=function(self,container,vTree,elideParent){fluid.viewContainerRegistry.set(container,self);vTree.elementSignal||=signal(fluid.unavailableElement);let useTree=vTree;if(!elideParent){useTree=fluid.elementToVNode(container);useTree.children=[vTree]}fluid.patchChildren(useTree,container,elideParent);self.renderedContainer=vTree.elementSignal};fluid.disableRendering=function(self){self.vTree=fluid.unavailable({cause:"Rendering is disabled",variety:"config"})};fluid.def("fluid.viewComponent",{$layers:"fluid.component",elideParent:true,container:"$compute:fluid.unavailable(Container not specified)",renderedContainer:fluid.unavailable({cause:"Component not rendered",variety:"config"}),vTree:fluid.unavailable({cause:"No virtual DOM tree is configured",variety:"config"}),renderView:"$effect:fluid.renderView({self}, {self}.container, {self}.vTree, {self}.elideParent)",css:fluid.unavailable({cause:"No CSS is configured",variety:"config"}),renderCSS:"$effect:fluid.renderCSS({self})",$variety:"framework"});fluid.coOccurrenceRegistry.push({inputNames:["fluid.viewComponent","fluid.componentList"],outputNames:["fluid.viewComponentList"]});fluid.def("fluid.viewComponentList",{$layers:"fluid.viewComponent",elideParent:true,vTree:"$compute:fluid.listViewTree({self}.list)",$variety:"framework"});fluid.listViewTree=function(list){return fluid.computed((componentList=>{const{designalArgs:components,unavailable:compUnavailable}=fluid.processSignalArgs(componentList);if(compUnavailable){return compUnavailable}else{const{designalArgs:childTrees,unavailable:treesUnavailable}=fluid.processSignalArgs(components.map((component=>component.vTree)));return treesUnavailable||{tag:"template",children:childTrees}}}),[list])};const layerWatchers={};fluid.applyLayerWatcher=function(layerName,nodeId,shadow,segs,material,injectFunc){if(!layerWatchers[nodeId]){const layerSig=fluid.readLayer(layerName);if(layerSig){const materialSignal=fluid.getForComponent(shadow,segs);const watcher=fluid.effect((material=>injectFunc(material,nodeId)),[materialSignal]);layerWatchers[nodeId]=watcher}else{injectFunc(material,nodeId)}}};fluid.getValueAndLayer=function(shadow,segs){const value=fluid.getForComponent(shadow,segs).value;const layerName=fluid.get(shadow.layerMap,[...segs,$m,"source"]);return{value:value,layerName:layerName}};fluid.renderCSS=function(self){const shadow=self[$t].shadow;const cssSegs=["css"];const{value:css,layerName:layerName}=fluid.getValueAndLayer(shadow,cssSegs);const nodeId="fl-css-"+layerName;fluid.applyLayerWatcher(layerName,nodeId,shadow,cssSegs,css,fluid.injectCSS)};fluid.def("fluid.templateViewComponent",{$layers:"fluid.viewComponent",templateDOM:"$compute:fluid.parseDOM({self}.template)",vTree:"$compute:fluid.parseTemplate({self}.templateDOM, {self})",$variety:"framework"});fluid.applyOnLoad((()=>{fluid.acquireUrlBases(document);fluid.acquireImports(document)}));fluid.selfBootQuery=fluid.liveQuery("*[fluid-layers]");fluid.selfBootEffect=effect((()=>{const elements=fluid.selfBootQuery.value;elements.forEach((element=>{const existing=fluid.viewContainerRegistry.get(element);if(!existing){const layers=element.getAttribute("fluid-layers");const instance=fluid.viewComponent({$layers:layers,container:element});fluid.viewContainerRegistry.set(element,instance)}}))}));fluid.def("fluid.globalDismissal",{$layers:["fluid.resolveRoot","fluid.viewComponent"],container:document,clicked:0,register:{$effect:{func:self=>{self.container.addEventListener("click",(e=>{const noDismiss=e.target.closest(".fl-no-dismiss");if(!noDismiss){++self.clicked}}))},args:"{self}"}}});fluid.globalDismissalInstance=fluid.globalDismissal()};if(typeof fluid!=="undefined"){fluidViewScope(fluid)}
//# sourceMappingURL=fluid.core.min.js.map